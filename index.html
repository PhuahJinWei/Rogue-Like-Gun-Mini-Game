<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Rogue-like Gun Mini-Game — v8.4.9</title>

<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Rajdhani:wght@500;600;700&display=swap" rel="stylesheet">
<style>
	* { box-sizing: border-box; }
	html, 
	body {
		height:100%;
		width:100%;
		overflow:hidden;
		overscroll-behavior:none;
	}
	body {
	margin:0;
		font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial;
		background: linear-gradient(180deg, #0b0f1a 0%, #0e1526 100%);
		color:#fff;
		display:flex; align-items:center; justify-content:center;
		padding:0;
		touch-action: manipulation;
	}
	.fit-wrap {
		transform-origin:center center;
		width:var(--frame-w);
		height:var(--frame-h);
	}
	:root { --frame-w: 600px; --frame-h: 1080px; --canvas-h: 750px; }
	.game-frame {
		display:inline-block;
		width: var(--frame-w);
		height: var(--frame-h);
		padding: 0;
		overflow: hidden;
		background-image: url('src/img/background_grey.png');
		background-repeat: no-repeat;
		background-position: center center;
		background-size: contain;
		background-color: #32342F;
		
		/* --- prevents dragging --- */
		user-select: none;
		-webkit-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-webkit-user-drag: none;
		-webkit-touch-callout: none;
		-webkit-tap-highlight-color: transparent;
		
		/* --- default font --- */
		font-size: 20px;
		font-family: 'Rajdhani', sans-serif;
		font-weight: 600;
		font-variant-numeric: lining-nums tabular-nums;
		letter-spacing: .05em;
		color: #F9F6F1;
	}
	.game-shell {
		width:var(--frame-w); max-width:100%;
	}
	.game-overlay.hidden { display:none; }
	.game-overlay {
		position: fixed;
		inset: 0;
		z-index: 10000;
		display: grid;
		place-items: center;
		background: rgba(0,0,0,.7);
	}
	.default-div-btn {
		width: 100%;
		height: 100%;
		cursor: pointer;
		
		background-size: 100% 100%;
		background-position: center;
	}

	/* ============================ TOP HUD ============================ */
	.hud {
		position: relative;
		height: 168px;
		width: 100%;
		background-image: url('src/img/UI_battlefield_topHUD.png');
		background-size: 100% 100%;
		background-repeat: no-repeat;
		background-position: center;
		margin: 0 0 -60px 0;
		z-index: 3;
	}
	.hud .num { position:absolute; color:#fff; font-weight:900; text-shadow: 0 1px 2px rgba(0,0,0,.6); -webkit-user-select:none; user-select:none; }
	.hud .num.big { font-size: 28px; line-height: 1; }
	.hud .num.sm  { font-size: 18px; font-weight:800; }
	.hud .right { text-align:right; }
	
	
	/* ------------- Scoreboard ------------- */
	:root {
		--wave-left: 42px; --wave-top: 76px; --wave-w: 80px; --wave-h: 55px; --wave-txt-size: 50px;
		--level-left: 191px; --level-top: 28px; --level-w: 40px; --level-h: 33px; --level-txt-size: 24px;
		--exp-left: 268px; --exp-top: 34px; --exp-w: 188px; --exp-h: 14.5px;
		--coin-left: 185px; --coin-top: 71px; --coin-w: 100px; --coin-txt-size: 17px;
		--score-left: 340px; --score-top: 71px; --score-w: 100px; --score-txt-size: 17px;
	}
	#waveNum {
		left: var(--wave-left);
		top: var(--wave-top);
		width: var(--wave-w);
		height: var(--wave-h);
		text-align:center;
		font-family: 'Bebas Neue', sans-serif;
		font-size: var(--wave-txt-size);
		font-weight: 700;
		letter-spacing: .08em;
		color: #F9FAF5;
		text-shadow: 0 1px 0 #000, 0 -1px 0 #000, 1px 0 0 #000, -1px 0 0 #000;
	}
	#levelNum {
		left: var(--level-left);
		top: var(--level-top);
		width: var(--level-w);
		height: var(--level-h);
		font-size: var(--level-txt-size);
		font-family: 'Rajdhani', sans-serif;
		font-weight: 600;
		font-variant-numeric: lining-nums tabular-nums;
		letter-spacing: .12em;
		-webkit-text-stroke: 1px #282824;
		text-shadow: 0 1px 0 #000, 0 -1px 0 #000, 1px 0 0 #000, -1px 0 0 #000;
		text-align:left;
	}
	.exp-track {
		position:absolute;
		overflow:hidden;
		left: var(--exp-left);
		top: var(--exp-top);
		width: var(--exp-w);
		height: var(--exp-h);
	}
	.exp-frame {
		position:absolute;
		left:0; top:0;
		height:100%; width:100%;
		background-image: url('src/img/UI_battlefield_topHUD_expframe.png');
		background-size: cover;
		background-position:center;
		z-index:2;
	}
	.exp-fill {
		position:absolute;
		left:0; top:0;
		height:100%; width:0%;
		background: linear-gradient(
			to bottom,
			#ffe886 0%,
			#f8c24e 35%,
			#ee9430 70%,
			#d9781c 100%
		);
		transition: width .2s ease;
		border-radius: inherit;
		z-index:1;
	}
	#coinNum {
		left: var(--coin-left);
		top: var(--coin-top);
		width: var(--coin-w);
		text-align: right;
		font-size: var(--coin-txt-size);
		font-family: 'Rajdhani', sans-serif;
		font-weight: 600;
		font-variant-numeric: lining-nums tabular-nums;
		letter-spacing: .12em;
		color: #FACD2B;
	}
	#scoreNum {
		left: var(--score-left);
		top: var(--score-top);
		width: var(--score-w);
		text-align: right;
		font-size: var(--score-txt-size);
		font-family: 'Rajdhani', sans-serif;
		font-weight: 600;
		font-variant-numeric: lining-nums tabular-nums;
		letter-spacing: .12em;
		color: #F7F4EF;
	}
	/* ------------- Button ------------- */
	:root {
		--speed-left: 474px; --speed-top: 33px; --speed-size: 49px; --speed-txt-size: 25px;
		--pause-left: 534px; --pause-top: 33px; --pause-size: 49px;
	}
	.hud-btn {
		position:absolute;
		background: transparent;
		border: none;
		color:#fff;
		cursor:pointer;
	}
	#speedBtn {
		left: var(--speed-left);
		top: var(--speed-top);
		width: var(--speed-size);
		height: var(--speed-size);
		font-size: var(--speed-txt-size);
		font-family: 'Rajdhani', sans-serif;
		font-weight: 700;
		letter-spacing: .04em;
		color: #FBF8F1;
		-webkit-text-stroke: 1px #000;
		text-shadow: #000;
		line-height: 1;
	}
	#pauseBtn {
		left: var(--pause-left);
		top: var(--pause-top);
		width: var(--pause-size);
		height: var(--pause-size);
	}


	/* ========================== Middle Section ========================== */
	.stage-wrap {
		display:flex;
		align-items:center;
		justify-content:center;
		padding:0;
		margin:0;
	}
	.stage {
		width: var(--frame-w);
		height: var(--canvas-h);
		position: relative;
		background-image: url('src/img/background_battlefield_1000x1250.png');
		background-size: cover; background-position:center;
		border:none; border-radius:0; box-shadow:none;
	}
	.soldier-sprite{
		position: absolute;
		left: 50%;
		transform: translateX(-50%);
		bottom: 0;
		width: 118px;
		height: 128px;
		pointer-events: none;
	}
	canvas {
		display:block; width:100%; height:100%;
	}
	
	
	/* ============================ HP Bar ============================ */
	.hp-container {
		position: relative;
		height: 46px;
		width: 100%;
		padding: 10px 14px;
		background-image: url('src/img/background_grey.png');
		background-size: cover;
		background-position: center;
	}
	.hp-frame {
		position: absolute;
		left:0; top:0;
		height:100%; width:100%;
		background-image: url('src/img/UI_battlefield_hp-container_frame.png');
		background-size: cover;
		background-position:center;
		z-index:2;
	}
	.hp-bar {
		position:relative;
		width:100%;
		height:100%;
		background:transparent;
		overflow:hidden;
		border:none;
		z-index:1;
	}
	.hp-bar .fill {
		position:absolute;
		left:0; top:0;
		height:100%; width:100%;
		background: linear-gradient(
			to bottom,
			#FD746F 15%,
			#EE3435 40%,
			#F03638 60%,
			#C81A3B 80%,
			#DE2342 100%
		);
		transition: width .2s ease;
		border-radius: inherit;
	}
	.hp-bar .text {
		position:absolute;
		inset:0;
		display:flex;
		align-items:center;
		justify-content:center;
		pointer-events:none;
		color:white;
		font-size: 21px;
		font-family: 'Rajdhani', sans-serif;
		font-weight: 800;
		font-variant-numeric: lining-nums tabular-nums;
		letter-spacing: .12em;
		-webkit-text-stroke: 0.6px #661E1A;
		text-shadow: 0 1px 0 #000, 0 -1px 0 #000, 1px 0 0 #000, -1px 0 0 #000;
	}
	
	
	/* ============================ Pause Overlay ============================ */
	.pause-panel { background:#0b1220; border:1px solid #1f2937; border-radius:14px; padding:18px; text-align:center; width:80%; max-width:360px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); }
	.pause-actions { display:flex; gap:10px; justify-content:center; }
	.pause-actions button { background:#111827; border:1px solid #1f2937; color:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700; }
	.pause-actions button:hover { filter: brightness(1.1); transform: translateY(-1px); }
	.pause-actions button.primary { background:#14532d; border-color:#166534; }
	
	
	/* ============================ Trait Overlay ============================ */
	:root {
		--trait-panel-w: 560px;
		--trait-layout-top-h: 659px;
		--trait-layout-bot-h: 89px;
		--trait-card-h: 134px;
		--trait-card-gap: 8px;
		--trait-card-icon-size: 133px;
		--trait-card-border-color: #2A94DB;
		--trait-card-radio-size: 38px;
	}
	.trait-panel {
		display: flex;
		width: var(--trait-panel-w);
		flex-direction: column;
		background: transparent;
		overflow: hidden;
		overscroll-behavior:none;
	}
	.trait-layout-top {
		display: grid;
		flex: 0 0 var(--trait-layout-top-h);
		height: var(--trait-layout-top-h);
		grid-template-columns: 1fr;
		padding-top: 95px;
		background-image: url('src/img/UI_trait_overlay_top2.png');
		background-size: cover;
		background-position: top center;
		overflow: hidden;
	}
	.trait-layout-bottom {
		display: block;
		height: var(--trait-layout-bot-h);
		flex: 1 1 auto;
		overflow-y: auto;
		background-image: url('src/img/UI_trait_overlay_bottom.png');
		background-size: cover;
		background-position: center;
	}
	#traitCards.trait-vertical {
		display: flex;
		flex-direction: column;
		height: 100%;
		gap: var(--trait-card-gap);
	}
	.trait-card {
		height: var(--trait-card-h);
		display: grid;
		grid-template-columns: 46px var(--trait-card-icon-size) 1fr;
		align-items: center;
		cursor: pointer;
	}
	.trait-radio {
		display: grid;
		height: 100%;
		place-items: center; 
	}
	.trait-radio::before {
		content:"";
		width: var(--trait-card-radio-size);
		height: var(--trait-card-radio-size);
	}
	.trait-card.selected .trait-radio::before {
		background-image: url('src/img/UI_trait_card_radio_selected.png');
		background-size: cover;
		background-position: center;
		pointer-event: none;
	}
	.trait-icon {
		width: var(--trait-card-h);
		height: var(--trait-card-h);
		display: grid;
		place-items: center;
		overflow: hidden;
		border-radius: 13px;
		border: 0;
	}
	.trait-card.selected .trait-icon {
		border: 2px solid var(--trait-card-border-color);
	}
	.trait-icon-img {
		width: 79px;
		height: 79px;
	}
	.trait-text {
		height: 100%;
		display: flex;
		padding: 0px 15px 0px 20px;
		flex-direction: column;
		justify-content: center;
	}
	.trait-title {
		font: 800 19px/1.0 "Rajdhani", system-ui, sans-serif;
		letter-spacing: .01em;
		color: #e5efff;
		position: relative;
		padding-bottom: 8px;
	}
	.trait-title::after {
		content: "";
		position: absolute;
		left: 0; right: 0; bottom: 0;
		height: 2px;
		background: #45B4BF;
	}
	.trait-desc {
		font: 600 15px/1.35 "Rajdhani", system-ui, sans-serif;
		letter-spacing: .01em;
		color: #b7c3d6;
		padding-top: 4px;
	}
	.trait-desc .accent {
		color: #63b3ff;
		font-weight: 800;
	}
	.trait-actions { 
		display: flex;
		height: 100%;
		width: var(--trait-panel-w);
		justify-content: center;
	}
	#traitActionRow1 { padding: 18px 38px 18px 37px; gap: 10px; }
	#traitActionRow2 { padding: 6px 0; }
	
	#traitStartBtn {
		width: 200px;
		aspect-ratio: 200 / 62;
		max-width: 200px;
		background-image: url('src/img/UI_trait_select_button_enabled.png');
		background-size: cover;
		background-position: center;
		cursor: pointer;
	}
	#traitStartBtn.is-disabled {
		background-image: url('src/img/UI_trait_select_button_disabled.png');
		background-size: cover;
		background-position: center;
		cursor: not-allowed;
	}
	
	/* ======================== View Trait Overlay ======================== */
	#traitPanelView {
		aspect-ratio: 892 / 1160;
		background-image: url('src/img/UI_trait_overlay_view_background.png');
		background-size: cover;
		background-position: center;
	}
	#traitViewRow1 {
		width: 100%;
		height: 59px;
		padding: 0px 10px 0px 83px;
		gap: 15px;
		display: flex;
	}
	#traitViewRow2 {
		height: 630px;
		margin-top: 39px;
		padding: 0px 20px 30px;
	}
	#traitViewTitle {
		width: 100%;
		height: 100%;
	}
	#closeTraitViewerBtn {
		height: 100%;
		width: auto;
		aspect-ratio: 1 / 1;
	}
	.trait-list::-webkit-scrollbar { display: none; }
	.trait-list {
		display: flex;
		flex-direction: column;
		gap: 12px;
		height: 100%;
		overflow-y: auto;
		-ms-overflow-style: none;
		scrollbar-width: none;
	}
	.trait-pill {
		display: inline-block;
		height: auto;
		padding:5px 10px;
		justify-content:space-between;
		align-items:center;
		
		border-style: solid;
		border-width: 12px;
		border-image-source: url('src/img/UI_trait_overlay_view_traitpill_background.png');
		border-image-slice: 12 fill;
		border-image-repeat: repeat;
		
		font: 600 17px/1.0 "Rajdhani", system-ui, sans-serif;
		letter-spacing: .01em;
		text-align:center;
	}
	.trait-pill span { color:#4799BC; }
	
	
	.btn { background:#6b7280; border:0; color:#fff; padding:8px 14px; border-radius:8px; font-weight:700; cursor:pointer; }
	.btn:hover { background:#818a99; }


	/* ============================ Inventory ============================ */
	.inventory-wrap{
		position: relative;
		height: 160px;
		width: 100%;
		background-image: url('src/img/background_grey.png');
		background-size: cover;
		background-position: center;
	}
	.inventory-frame {
		position: absolute;
		left:0; top:0;
		inset: 0;
		height:100%; width:100%;
		background-image: url('src/img/UI_battlefield_inventory_frame.png');
		background-size: cover;
		background-position:center;
		z-index:1;
	}
	.inventory-grid {
		position: absolute;
		top: 4px;
		left: 20px;
		display: grid;
		grid-template-columns: repeat(8, 67px);
		grid-auto-rows: 67px;
		column-gap: 3.4px;
		row-gap: 3.5px;
		z-index: 2;
	}
	.slot{
		position: relative;
		width: 100%;
		height: 100%;
		box-sizing: border-box;
		padding: 0;
		display: block;
		overflow: hidden;
	}
	.slot-layer{
		position: absolute;
		inset: 0;
		width: 100%;
		height: 100%;
		display: block;
		pointer-events: none;
		-webkit-user-drag: none;
		-webkit-touch-callout: none;
		-webkit-tap-highlight-color: transparent;
		border: 2.5px solid #252620;
		border-radius: 5px;
	}
	.slot-bg {
		object-fit: fill;
		z-index: 1;
	}
	.slot-gun {
		object-fit: contain;
		object-position: center;
		z-index: 2;
	}
	.slot-cd {
		position:absolute;
		inset:0;
		pointer-events:none;
		opacity:0;
		--cd: 0;
		background: 
			conic-gradient(
				from 0deg,
				transparent 0deg,
				transparent calc(var(--cd) * 360deg),
				rgba(0,0,0,.55) calc(var(--cd) * 360deg),
				rgba(0,0,0,.55) 360deg
		);
		z-index: 3;
	}

	/* ============================ Boss warning banner ============================ */
	.warn-banner {
		position: absolute;
		top: 8px; left: 50%; transform: translateX(-50%);
		padding: 6px 12px;
		background: rgba(220,38,38,0.6); color:#fff;
		border: 1px solid rgba(220,38,38,0.85);
		border-radius: 10px; font-weight: 900; letter-spacing: 1px;
		text-transform: uppercase; pointer-events: none; backdrop-filter: blur(2px);
		z-index: 3; opacity: 0; text-shadow: 0 1px 2px rgba(0,0,0,0.45);
	}
	.warn-banner.show { opacity:1; }
	@keyframes warnPulse { 0% {opacity:0;} 30% {opacity:1;} 70% {opacity:1;} 100% {opacity:0;} }


	/* ============================ Shop Overlay ============================ */
	:root {
		--shop-panel-w: 560px;
		--shop-layout-top-h: 620px;
		--shop-layout-bot-h: 330px;
		/* shop-layout-bot-h */ --shop-layout-bot-offer-h: 230px;
		/* shop-layout-bot-h */ --shop-layout-bot-btn: 100px;
		--shop-start-button-w: 413;
		--shop-start-button-h: 90;
		--shop-start-button-w-ratio: 55%;
		--shop-gun-offer-count: 3;
	}
	.shop-overlay.hidden {display: none;}
	.shop-overlay {
		position: fixed;
		inset: 0;
		z-index: 10000;
		display: grid;
		place-items: center;
		background: rgba(0, 0, 0, 0.8);
	}
	.shop-panel {
		display: flex;
		width: var(--shop-panel-w);
		flex-direction: column;
		background: transparent;
		overflow: hidden;
		overscroll-behavior:none;
	}
	.shop-layout-top {
		display: grid;
		flex: 0 0 var(--shop-layout-top-h);
		height: var(--shop-layout-top-h);
		grid-template-columns: 1fr;
		gap: 12px;
		background-image: url('src/img/UI_shop_overlay_background.png');
		background-size: cover;
		background-position: center;
	}
	.shop-title {
		font-weight: 800;
		font-size: 38px;
		line-height: 1.1;
		letter-spacing: .08em;
		text-align: center;
		text-shadow: 0 1px 0 #3E3E3C;
		padding:11px;
	}
	.shop-grid-wrap {
		display: grid;
		place-items: center;
	}
	.shop-grid {
		position: relative;
		touch-action: none;
	}
	.shop-layout-offer.viewMode { display: none; }
	.shop-layout-offer {
		height: 229px;
		flex: 1 1 auto;
		overflow: hidden;
		background-image: url('src/img/UI_shop_overlay_offer_background.png');
		background-size: cover;
		background-position: center;
		touch-action: none;
	}
	.shop-offer {
		display: grid;
		position: relative;
		height: var(--shop-layout-bot-offer-h);
		padding: 30px;
		gap: 10px;
		grid-template-columns: repeat(var(--shop-gun-offer-count), minmax(90px, 1fr));
	}
	.shop-layout-bottom {
		height: 101px;
		flex: 1 1 auto;
		overflow: hidden;
		background-image: url('src/img/UI_shop_overlay_bottom_background.png');
		background-size: cover;
		background-position: center;
	}
	.shop-actions {
		width: var(--shop-panel-w);
		display: flex;
		justify-content: center;
		align-items: center;
	}
	#shopActionRow1 { padding: 8px 0px 20px 0px; gap:4px; height: var(--shop-layout-bot-btn);  }
	#shopActionRow2 { padding: 6px 0px; }
	
	#btnShop_weaponRemoval, 
	#btnShop_rerollOffer {
		width: 263px;
		aspect-ratio: 530 / 141;
	}
	#btnShop_weaponRemoval {
		background-image: url('src/img/UI_shop_offer_removal_button.png');
		padding: 12px 0px;
		text-align: center;
	}
	#btnShop_rerollOffer {
		background-image: url('src/img/UI_shop_offer_button_reroll_enabled.png');
		padding: 12px 0px;
		text-align: center;
	}
	#btnShop_rerollOffer.disabled {
		background-image: url('src/img/UI_shop_offer_button_reroll_disabled.png');
		color: #F31307;
	}
	#btnShop_weaponRemoval.viewMode, #btnShop_rerollOffer.viewMode { display: none; }
	
	.shop-start-button.viewMode { display: none; }
	.shop-start-button {
		width: 55%;
		aspect-ratio: var(--shop-start-button-w) / var(--shop-start-button-h);
		max-width: var(--shop-start-button-w)px;
		background-image: url('src/img/UI_shop_start_button.png');
		background-size: cover;
		background-position: center;
		cursor: pointer;
	}
	#btnShop_close_view.viewMode { display: none; }
	#btnShop_close_view {
		background-image: url('src/img/UI_shop_view_close_button.png');
		display: grid;
		place-items: center;
		text-align: center;
		width: 40%;
		aspect-ratio: 373 / 115;
		cursor: pointer;
	}
	
	
	/* ------- Shop Gun ------- */
	.gun-chip {
		position: relative;
		width: 90px;
		height: 60px;
		user-select: none;
		cursor: grab;
	}
	.gun-chip:active {
		cursor: grabbing;
	}
	.gun-placed {
		position: absolute;
		width: calc(48px * 4);
		height: calc(48px * 2);
		pointer-events: auto;
		cursor: grab;
	}
	.gun-sprite,
	.gun-sprite-mini {
		position: absolute;
		left: 0;
		top: 0;
		pointer-events: none;
		image-rendering: pixelated;
		image-rendering: crisp-edges;
	}
	.drag-ghost {
		position: fixed;
		z-index: 10001;
		pointer-events: none;
		touch-action: none;
		opacity: .9;
	}
	.drag-hidden {
		opacity: 0;
		visibility: hidden;
	}
	.placement-preview {
		position: absolute;
		left: 0;
		top: 0;
		pointer-events: none;
		z-index: 5000; /* under ghost (10001) but above grid cells */
	}
	@keyframes mergeShinePulse {
		0% {
			filter: brightness(1) saturate(1);
			box-shadow:
				0 0 4px rgba(255,255,200,0.4),
				0 0 8px rgba(255,255,150,0.25);
		}
		50% {
			filter: brightness(1.9) saturate(1.4);
			box-shadow:
				0 0 6px rgba(255,255,255,0.9),
				0 0 14px rgba(255,255,160,0.6),
				0 0 22px rgba(255,255,120,0.35);
		}
		100% {
			filter: brightness(1) saturate(1);
			box-shadow:
				0 0 4px rgba(255,255,200,0.4),
				0 0 8px rgba(255,255,150,0.25);
		}
	}
	.merge-glow .p-cell,
	.merge-glow .mini-cell {
		animation: mergeShinePulse 1.7s ease-in-out infinite;
	}
</style>

<!-- ---- Imports ---- -->
<script src="src/js/error-log.js"></script>

</head>
<body>
<div id="fitWrap" class="fit-wrap">
<div class="game-frame">
<div class="game-shell">

	<!-- =============== Top HUD =============== -->
	<div class="hud" id="topHUD">
		<div id="waveNum"  class="num big">1</div>
			<div id="levelNum" class="num">1</div>
			<div class="exp-track">
				<div class="exp-fill" id="expFill"></div>
				<div class="exp-frame"></div>
			</div>
		<div id="coinNum"  class="num sm right">0</div>
		<div id="scoreNum" class="num sm right">0</div>
		<button id="speedBtn" class="hud-btn" data-sfx="src/sfx/button_press_default.mp3">1x</button>
		<button id="pauseBtn" class="hud-btn" data-sfx="src/sfx/button_battle_pause.mp3"></button>
	</div>

	<!-- =============== Battlefield =============== -->
	<div class="stage-wrap">
	<div class="stage">
		<canvas id="game"></canvas>
		<img id="soldierSprite" src="src/img/character_model_1_angle_3.gif" class="soldier-sprite" alt="soldier">
		<div id="bossWarn" class="warn-banner">BOSS APPROACHING</div>

		<!-- ----- Pause / Restart Overlay ----- -->
		<div id="pause-overlay" class="game-overlay hidden">
		<div class="pause-panel">
			<div class="pause-actions">
				<button id="viewTraitsBtn" class="btn">View All Traits</button>
				<button id="resumeBtn" class="primary">▶︎</button>
				<button id="restartBtn">Restart</button>
			</div>
		</div>
		</div>
			
		<!--  ----- Trait overlay ----- -->
		<div id="traitOverlay" class="game-overlay hidden">
		<div class="trait-panel">
			<div class="trait-layout-top">
				<div id="traitCards" class="trait-cards"></div>
			</div>
			<div class="trait-layout-bottom">
				<div id="traitActionRow1" class="trait-actions">
					<div id="btn_viewInventory" class="default-div-btn"></div>
					<div id="btn_viewTraits" class="default-div-btn"></div>
				</div>
			</div>
			<div id="traitActionRow2" class="trait-actions">
				<div id="traitStartBtn" class="default-div-btn is-disabled"></div>
			</div>
		</div>
		</div>
		
		<!--  ----- View Trait overlay ----- -->
		<div id="traitOverlayViewer" class="game-overlay hidden">
		<div id="traitPanelView" class="trait-panel">
			<div id="traitViewRow1">
				<div id="traitViewTitle" class="shop-title">Traits</div>
				<div id="closeTraitViewerBtn" class="default-div-btn"></div>
			</div>
			<div id="traitViewRow2">
				<div id="traitList" class="trait-list"></div>
			</div>
		</div>
		</div>
			
		<!-- Shop overlay -->
		<div id="shopOverlay" class="game-overlay hidden">
		<div class="shop-panel">
			<div class="shop-layout-top">
				<div id="shopTitle" class="shop-title">Shop</div>
				<div class="shop-grid-wrap"><div id="shopGrid" class="shop-grid"></div></div>
			</div>
			<div id="shopLayoutOffer" class="shop-layout-offer">
				<div id="shopOffer" class="shop-offer"></div>
			</div>
			<div class="shop-layout-bottom">
				<div id="shopActionRow1" class="shop-actions">
					<div id="btnShop_weaponRemoval" class="default-div-btn">Weapon Removal</div>
					<div id="btnShop_rerollOffer" class="default-div-btn"></div>
					<div id="btnShop_close_view" class="default-div-btn">Return</div>
				</div>
			</div>
			<div id="shopActionRow2" class="shop-actions">
				<div id="shopStartBtn" class="shop-start-button"></div>
			</div>
		</div>
		</div>

	</div>
	</div>
	
	<!-- =============== Bottom Section =============== -->
	<!-- Barricade HP -->
	<div class="hp-container">
	<div class="hp-bar" id="hpBar">
		<div class="fill" id="hpFill"></div>
		<div class="text" id="hpText">100%</div>
	</div>
	<div class="hp-frame"></div>
	</div>

	<!-- Inventory -->
	<div class="inventory-wrap">
		<div class="inventory-frame"></div>
		<div class="inventory-grid" id="inventoryGrid"></div>
	</div>
		
</div>
</div>
</div>

<script>
(function(){
	if (typeof window!=='undefined' && typeof window.openShopOverlay!=='function') {
		window.__pendingShopCalls = [];
		window.openShopOverlay = function(){ window.__pendingShopCalls.push([].slice.call(arguments)); };
	}
})();

(() => {
	// ==================== Config ==================== //
	
	//game frame
	const FRAME_W  = 600, FRAME_H  = 1065;
	const CANVAS_W = FRAME_W, CANVAS_H = 750;
	
	//game canvas
	const W = CANVAS_W, H = CANVAS_H;
	const BARRICADE_Y = H - 155;
	const BARRICADE_HP_MAX = 500;
	
	//Game Speed
	const SPEED_STORAGE_KEY = 'rlg_speed_v1';
	
	//Wave-based
	const CURRENT_WAVE = 10;
	const WAVE_1_COUNT = 8;
	const WAVE_INCREASE = 1.01;
	const GROUPS_PER_WAVE = 5;
	const GROUP_INTERVAL_BASE = 20.0;
	const MOB_INTERVAL_BASE = 0.50;
	const MOB_INTERVAL_MIN  = 0.30;
	const MOB_INTERVAL_DECAY_PER_WAVE = 0.3;
	const CONTACT_DAMAGE_INTERVAL = 3.0;
	const MOB_HP_PER_WAVE = 0.04;
	
	// Banner + spacing config
	const BOSS_WARN_FLASHES = 2;
	const BOSS_WARN_TOTAL_DURATION = 2;
	const BOSS_MINI_TO_BOSS_INTERVAL = 0.2;
	
	//DPS number
	const DMG_NUM_LIFETIME = 2.0;   // seconds total (auto-remove after this)
	const DMG_NUM_VY0      = -3;  // initial upward jump (px/s)
	const DMG_NUM_GRAVITY  = 2.5;   // pulls the number back down (px/s^2)
	const DMG_NUM_POP_TIME = 1.0;  // quick pop scale duration on spawn (s)
	
	//Mobs
	const MOBS = {
		"A": {name:"Mob A", hp: 80, exp: 10, speed: 18, dps: 20, size: 45, coin: 130, score: 100 },
		"B": {name:"Mob B", hp: 80, exp: 10+290, speed: 20, dps: 20, size: 45, coin: 130, score: 100 }
	};
	const MINI_BOSS_A = { name: "Mini-boss Type A", hp: 1000, exp: 100, speed: 15, dps: 30, size: 70, coin: 500, score: 500, tier: "mini" };
	const BOSS_A = { name: "Boss Type A", hp: 2000, exp: 1000, speed: 10, dps: 50, size: 100, coin: 1000, score: 1000, tier: "boss" };
	
	//Weapons
	const CRIT_RATE = 0.15;
	const CRIT_MULT = 1.5;
	const BULLET_RADIUS_SIZE = 8;
	const BULLET_SPEED = 250;
	const GUN_MULTITARGET_PROBILITY = 0.6; //chance of focusing on nearest, ++ to allow more multi-targetting
	const GUNS = {
		"submachinegun":
		{
			1:{ 
				name:"submachinegun",
				tags:"normal",
				range:460,
				bulletsPerUse:4,
				timeBetweenBullets:0.20,
				damage:30,
				postUseCooldown: 5.0/2.5,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			2: {
				name:"submachinegun",
				tags:"normal",
				range:460,
				bulletsPerUse:4,
				timeBetweenBullets:0.18,
				damage:40,
				postUseCooldown: 2,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			3: {
				name:"submachinegun",
				tags:"normal",
				range:460,
				bulletsPerUse:6,
				timeBetweenBullets:0.18,
				damage:60, postUseCooldown: 2,
				bulletSpeed:BULLET_SPEED,
				ability: "submachinegun_T3_GuaranteedCritAfter5"
			},
			4: {
				name:"submachinegun",
				tags:"normal",
				range:480,
				bulletsPerUse:6,
				timeBetweenBullets:0.16,
				damage:80,
				postUseCooldown: 2,
				bulletSpeed:BULLET_SPEED,
				ability: "submachinegun_T3_GuaranteedCritAfter5"
			}
		},
		"pistol":
		{
			1:{ 
				name:"pistol",
				tags:"normal",
				range:400,
				bulletsPerUse:3,
				timeBetweenBullets:0.20,
				damage:30,
				postUseCooldown: 1,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			2: {
				name:"pistol",
				tags:"normal",
				range:400,
				bulletsPerUse:3,
				timeBetweenBullets:0.20,
				damage:40,
				postUseCooldown: 1,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			3: {
				name:"pistol",
				tags:"normal",
				range:400,
				bulletsPerUse:3,
				timeBetweenBullets:0.20,
				damage:60, 
				postUseCooldown: 1,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			4: {
				name:"pistol",
				tags:"normal",
				range:400,
				bulletsPerUse:3,
				timeBetweenBullets:0.20,
				damage:80,
				postUseCooldown: 1,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			}
		},
		"sniperriffle":
		{
			1:{ 
				name:"sniperriffle",
				tags:"normal",
				range:650,
				bulletsPerUse:1,
				timeBetweenBullets:0,
				damage:130,
				postUseCooldown: 9,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			2: {
				name:"sniperriffle",
				tags:"normal",
				range:650,
				bulletsPerUse:1,
				timeBetweenBullets:0,
				damage:140,
				postUseCooldown: 9,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			3: {
				name:"sniperriffle",
				tags:"normal",
				range:650,
				bulletsPerUse:1,
				timeBetweenBullets:0,
				damage:160,
				postUseCooldown: 9,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			4: {
				name:"sniperriffle",
				tags:"normal",
				range:650,
				bulletsPerUse:1,
				timeBetweenBullets:0,
				damage:180,
				postUseCooldown: 9,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			}
		},
		"assultriffle":
		{
			1:{ 
				name:"assultriffle",
				tags:"normal",
				range:460,
				bulletsPerUse:4,
				timeBetweenBullets:0.20,
				damage:30,
				postUseCooldown: 5.0/2.5,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			2: {
				name:"assultriffle",
				tags:"normal",
				range:460,
				bulletsPerUse:4,
				timeBetweenBullets:0.18,
				damage:40,
				postUseCooldown: 2,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			3: {
				name:"assultriffle",
				tags:"normal",
				range:460,
				bulletsPerUse:6,
				timeBetweenBullets:0.18,
				damage:60, postUseCooldown: 2,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			4: {
				name:"assultriffle",
				tags:"normal",
				range:480,
				bulletsPerUse:6,
				timeBetweenBullets:0.16,
				damage:80,
				postUseCooldown: 2,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			}
		},
		"grenadelauncher":
		{
			1:{ 
				name:"grenadelauncher",
				tags:"normal",
				range:460,
				bulletsPerUse:4,
				timeBetweenBullets:0.20,
				damage:30,
				postUseCooldown: 5.0/2.5,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			2: {
				name:"grenadelauncher",
				tags:"normal",
				range:460,
				bulletsPerUse:4,
				timeBetweenBullets:0.18,
				damage:40,
				postUseCooldown: 2,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			3: {
				name:"grenadelauncher",
				tags:"normal",
				range:460,
				bulletsPerUse:6,
				timeBetweenBullets:0.18,
				damage:60, postUseCooldown: 2,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			},
			4: {
				name:"grenadelauncher",
				tags:"normal",
				range:480,
				bulletsPerUse:6,
				timeBetweenBullets:0.16,
				damage:80,
				postUseCooldown: 2,
				bulletSpeed:BULLET_SPEED,
				ability: ""
			}
		}
	};
	
	//Traits
	const TRAIT_DMG_UP = [5,7,10];
	const TRAIT_RELOAD_DOWN = [3,5,7];
	const TRAIT_POINT_UP = [5,10,15];
	
	const ROMAN = ['I','II','III'];
	const TRAIT_BASE_CARD_COUNT = 3;
	const TRAIT_EXTRA_CARD_CHANCE = 0.40;
	const TRAITS = [
		{
			id: 'normal_dmg_up',
			scope: 'global',
			statKey: 'normal_dmg_increase',
			statBase: 0,
			formatTotal: v => v + '%',
			name: (tier) => 'Normal Attack Damage Increase ' + ROMAN[tier-1],
			desc: (tier) => 'Increases normal attack damage by ',
			scaling: (tier) => TRAIT_DMG_UP[tier-1],
			apply: (tier)=>{
				state.normal_dmg_increase += TRAIT_DMG_UP[tier-1];
			}
		},
		{
			id: 'normal_dmg_reload',
			scope: 'global',
			statKey: 'normal_reload_decrease',
			statBase: 0,
			formatTotal: v => v + '%',
			name: (tier) => 'Normal Attack Reload Time Decrease ' + ROMAN[tier-1],
			desc: (tier) => 'Decrease Normal Attack Reload Time by ',
			scaling: (tier) => TRAIT_RELOAD_DOWN[tier-1],
			apply: (tier)=>{
				state.normal_reload_decrease += TRAIT_RELOAD_DOWN[tier-1];
			}
		},
		{
			id: 'gold_up',
			scope: 'global',
			statKey: 'goldGainBonus',
			statBase: 0,
			formatTotal: v => v + '%',
			name: (tier) => 'Gold Gain Increase ' + ROMAN[tier-1],
			desc: (tier) => 'Increases Goin gained from killing monsters by ',
			scaling: (tier) => TRAIT_POINT_UP[tier-1],
			apply: (tier)=>{
				state.goldGainBonus += TRAIT_POINT_UP[tier-1];
			}
		},
		{
			id: 'exp_up',
			scope: 'global',
			statKey: 'expGainBonus',
			statBase: 0,
			formatTotal: v => v + '%',
			name: (tier) => 'EXP Gain Increase ' + ROMAN[tier-1],
			desc: (tier) => 'Increases EXP gained from killing monsters by ',
			scaling: (tier) => TRAIT_POINT_UP[tier-1],
			apply: (tier)=>{
				state.expGainBonus += TRAIT_POINT_UP[tier-1];
			}
		}
	];
	
	
	// ============= Display ============= //
	//Bind constants to DOM/CSS
	const root = document.documentElement;
	root.style.setProperty('--frame-w',  FRAME_W  + 'px');
	root.style.setProperty('--frame-h',  FRAME_H  + 'px');
	root.style.setProperty('--canvas-h', CANVAS_H + 'px');
	
	const canvas = document.getElementById('game');
	canvas.width = CANVAS_W;
	canvas.height = CANVAS_H;
	
	const fitWrap = document.getElementById('fitWrap');
	function fitToViewport() {
		const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
		const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
		const scaleW = vw / FRAME_W;
		const scaleH = vh / FRAME_H;
		const s = Math.min(scaleW, scaleH, 1);
		fitWrap.style.transform = `scale(${s})`;
	}
	window.addEventListener('resize', fitToViewport);
	window.addEventListener('orientationchange', fitToViewport);
	fitToViewport();
	
	// ===== Soldier Facing Angle GIF ===== //
	const soldierSpriteEl = document.getElementById('soldierSprite');
	const SOLDIER_ANGLES = [
		'src/img/character_model_1_angle_1.gif', // far-left
		'src/img/character_model_1_angle_2.gif', // left
		'src/img/character_model_1_angle_3.gif', // up (default)
		'src/img/character_model_1_angle_4.gif', // right
		'src/img/character_model_1_angle_5.gif'  // far-right
	];
	const _soldierImgs = SOLDIER_ANGLES.map(src => { const i=new Image(); i.src=src; return i; });
	let _soldierIdx = 2;
	if (soldierSpriteEl) soldierSpriteEl.src = SOLDIER_ANGLES[_soldierIdx];

  
  // === Weapon instances (equipped guns) ===
  function makeWeaponInstance(key, tier){
    const def = (GUNS[key] && GUNS[key][tier]) ? GUNS[key][tier] : null;
    if (!def) throw new Error("Unknown weapon/tier: "+key+" T"+tier);
    return {
      key, tier,
      stats: { ...def },
      mode: 'idle',
      timer: 0,
      burstLeft: 0,
      shotsSinceAbility: 0
    };
  }
  
function formatGunLabel(w){ return `${w.stats.name} T${w.tier}`; }
  function findClosestEnemy(range=Infinity){
    const p = state.player; const r2 = range===Infinity ? Infinity : range*range;
    let best=null, bestD2=Infinity;
    for (const m of state.enemies){
      if (m.dead) continue;
      const dx = p.x - m.cx, dy = p.y - m.cy, d2 = dx*dx + dy*dy;
      if (d2 < bestD2 && d2 <= r2){ bestD2=d2; best=m; }
    }
    return best;
  }
  function pickTargetForWeapon(w){
    const nearest = findClosestEnemy(w.stats.range);
    if (!nearest) return null;
    if (Math.random() < GUN_MULTITARGET_PROBILITY) return nearest;
    const p = state.player, r2 = w.stats.range*w.stats.range;
    const pool = [];
    for (const m of state.enemies){
      if (m.dead) continue;
      const dx=p.x-m.cx, dy=p.y-m.cy, d2=dx*dx+dy*dy;
      if (d2<=r2) pool.push(m);
    }
    if (pool.length===0) return null;
    return pool[(Math.random()*pool.length)|0];
  }
  
	// ================= Sound Effects ================= //
	const bgm = new Audio('src/sfx/bgm_battlefield_loop.mp3');
	bgm.loop = true;
	bgm.preload = 'auto';
	bgm.volume = 0.3;
	window.bgm = bgm;
	
	window.addEventListener('pointerdown', function unlock(){
		bgm.play().catch(()=>{});
		window.removeEventListener('pointerdown', unlock);
	}, { once:true });
	function ensureBgmPlaying(reset=false){
		if (reset) bgm.currentTime = 0;
		if (bgm.paused) bgm.play().catch(()=>{});
	}
	document.addEventListener('pointerdown', function unlock() { //unlock audio once (iOS/Safari)
		const a = new Audio();
		a.play().catch(()=>{}).finally(()=>a.pause());
		document.removeEventListener('pointerdown', unlock);
	}, { once: true });
	
	//play audio (stackable)
	function makeSfx(path, { volume = 0.6, pool = 3 } = {}) {
		const poolArr = Array.from({ length: pool }, () => {
			const a = new Audio(path);
			a.preload = 'auto';
			a.volume = volume;
			return a;
		});
		let i = 0;
		return () => {
			const a = poolArr[i];
			i = (i + 1) % poolArr.length;
			a.currentTime = 0;
			a.play().catch(() => {}); // ignore autoplay guards
		};
	}
	
	//play audio (unstackable)
	function makeSfxMonophonic(path, { volume = 0.6 } = {}) {
		const a = new Audio(path);
		a.preload = 'auto';
		a.volume = volume;

		let playing = false;

		// Always clear 'playing' on pause/ended/error (overlay/tabs often cause 'pause')
		a.addEventListener('ended', () => { playing = false; });
		a.addEventListener('pause',  () => { playing = false; });
		a.addEventListener('error',  () => { playing = false; });

		// iOS/Safari unlock for this element
		const unlockOnce = () => {
			a.play().then(() => a.pause()).catch(() => {});
			window.removeEventListener('pointerdown', unlockOnce);
		};
		window.addEventListener('pointerdown', unlockOnce, { once: true });

		function playNow() {
			try { a.currentTime = 0; } catch (_) {}
			playing = true;
			a.play().catch(() => { playing = false; });
		}
		
		return function play() {
			// If overlay/tab paused the element, clear stale state
			if (playing && (a.paused || a.ended)) playing = false;
			if (playing) return;
			playNow();
		};
	}
	
	//Pause Audio
	function fadeAudio(a, to, ms = 200) {
		const from=a.volume, steps=Math.max(1,Math.floor(ms/16)); let i=0;
		if (to>0 && a.paused) a.play().catch(()=>{});
		const id=setInterval(()=>{ i++; a.volume = from + (to-from)*(i/steps);
		if(i>=steps){ clearInterval(id); if(to===0) a.pause(); }},16);
	}
	
	//sfx upon click on div
	document.querySelectorAll('[data-sfx]').forEach(el => {
		const play = makeSfx(el.dataset.sfx, { volume: 0.6, pool: 4 });
		el.addEventListener('pointerdown', play);
	});
	
	//mob death sfx
	const SFX_MOB_DEATH = makeSfx('src/sfx/mob_death.mp3', { volume: 0.5, pool: 8 });
	
	//fire gun sfx
	const SFX_GUN_FIRE_CACHE = new Map();
	function playGunFire(name){
		const slug = String(name);
		if (!SFX_GUN_FIRE_CACHE.has(slug)) {
			SFX_GUN_FIRE_CACHE.set(slug, makeSfxMonophonic(`src/sfx/gun_${slug}_fire.mp3`, { volume: 0.5, pool: 6 }));
		}
		try { SFX_GUN_FIRE_CACHE.get(slug)(); } catch (e) {}
	}
	
	
	// ============== Game State ============== //
	const state = {
		paused: false, gameOver: false, wave: 1,
		toSpawn: 0, enemies: [], bullets: [],
		coins: 0, score: 0, kills: 0,
		player: { x: W/2, y: H - 40, size: 16, level: 1, exp: 0, expToNext: 50 },
		speedMult: 1, inventory: new Array(16).fill(null),
		groupIndex: 0, groupSizes: [], groupMobIndex: 0, groupIntervalTimer: 0, mobIntervalTimer: 0, mobIntervalWave: 0,
		specialsQueued: { mini: false, boss: false }, specialsSpawned: false,
		specialsProgress: 0, specialsTimer: 0
	};

	
	
	// ============== Delare Element ID ============== //
	const ctx = canvas.getContext('2d');
	const pauseOverlay = document.getElementById('pause-overlay');
	const resumeBtn = document.getElementById('resumeBtn');
	const restartBtn = document.getElementById('restartBtn');
	const pauseBtn = document.getElementById('pauseBtn');
	const speedBtn = document.getElementById('speedBtn');
	const bossWarn = document.getElementById('bossWarn');
	const waveNumEl = document.getElementById('waveNum');
	const levelNumEl = document.getElementById('levelNum');
	const expFill = document.getElementById('expFill');
	const coinNumEl = document.getElementById('coinNum');
	const scoreNumEl = document.getElementById('scoreNum');
	const traitOverlay = document.getElementById('traitOverlay');
	const traitCardsBox = document.getElementById('traitCards');
	const traitOverlayViewer = document.getElementById('traitOverlayViewer');
	const traitListBox = document.getElementById('traitList');
	const closeTraitViewerBtn = document.getElementById('closeTraitViewerBtn');
	const traitStart  = document.getElementById('traitStartBtn');


	// =============== Utilities Functions =============== //
	const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

	function roundRect(ctx,x,y,w,h,r) { 
		const m=Math.min(w,h)/2; r=Math.min(r,m);
		ctx.beginPath(); ctx.moveTo(x+r,y);
		ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
		ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
	}
	
	// --- Waves ---
	function waveCountFor(n) {
		let c = WAVE_1_COUNT;
		for (let i = 1; i < n; i++) c = Math.max(1, Math.ceil(c * WAVE_INCREASE));
		return c;
	}
	function scaleHP(baseHp, wave) {
		if (!wave || wave <= 1) return baseHp;
		return Math.round(baseHp * (1 + (wave - 1) * MOB_HP_PER_WAVE)); //x0.1 per wave (linear)
		//return Math.round(baseHp * Math.pow(MOB_HP_PER_WAVE, (wave - 1))); //x1.07^waves (exponential)
	}
	function splitIntoGroups(total, groups) {
		const sizes = new Array(groups).fill(0);
		if (total <= 0) return sizes;
		const base = Math.floor(total / groups);
		let rem = total - base * groups;
		for (let i = 0; i < groups; i++) sizes[i] = base;
		while (rem-- > 0) sizes[Math.floor(Math.random()*groups)]++;
		for (let i = 0; i < groups; i++) if (sizes[i] === 0 && total >= groups) sizes[i] = 1;
		let sum = sizes.reduce((a,b)=>a+b,0);
		while (sum > total) { const i = sizes.findIndex(s=>s>1); sizes[i]--; sum--; }
		return sizes;
	}
	function computeFacingIndex() {
		if (state.player.aimVX != null && state.player.aimVY != null) {
			const vx = state.player.aimVX, vy = state.player.aimVY;
			const deg = Math.atan2(vx, -vy) * 180 / Math.PI; // −180..+180
			const clamped = Math.max(-90, Math.min(90, deg));
			return Math.min(4, Math.max(0, Math.floor((clamped + 90) / 36)));
		}
		const t = findClosestEnemy();
		if (!t) return 2;
		const dx = t.cx - state.player.x, dy = t.cy - state.player.y;
		const deg = Math.atan2(dx, -dy) * 180 / Math.PI;
		const clamped = Math.max(-90, Math.min(90, deg));
		return Math.min(4, Math.max(0, Math.floor((clamped + 90) / 36)));
	}
	function effectiveTimeBetweenBullets(w){
		const cdr = state.normalAttackReloadDec || 0;
		return w.stats.timeBetweenBullets * (1 - cdr);
	}
	function effectivePostUseCooldown(w){
		let cdrPct = 0;
		switch (w.stats.tags){
			case 'normal': cdrPct = state.normal_reload_decrease || 0; break;
			case 'aoe':    cdrPct = state.aoe_reload_decrease    || 0; break;
			case 'pierce': cdrPct = state.pierce_reload_decrease || 0; break;
		}
		return w.stats.postUseCooldown * (1 - cdrPct/100);
	}



  // ============ Class ============ //
	class Mob
	{
		constructor(type, x, yStart) {
			this.type = type; this.x = x; this.y = yStart;
			this.w = type.size; this.h = type.size; 
			const __baseHp = type.hp;
			const __wave   = (state && state.wave) ? state.wave : 1;
			const __scaled = scaleHP(__baseHp, __wave);
			this.hpMax = __scaled;
			this.hp = __scaled;
			this.contact = false; this.contactTimer = 0; this.dead = false; this.tookDamage = false;
		}
		get cx() { return this.x + this.w/2; }
		get cy() { return this.y + this.h/2; }
		
		update(dt) {
			if (this.dead) return;
			if (!this.contact) {
				this.y += this.type.speed * dt;
				if (this.y + this.h >= BARRICADE_Y) { this.y = BARRICADE_Y - this.h; this.contact = true; this.contactTimer = 0; }
			}
			else {
				this.contactTimer += dt;
				while (this.contactTimer >= CONTACT_DAMAGE_INTERVAL) { this.contactTimer -= CONTACT_DAMAGE_INTERVAL; applyBarrageDamage(this.type.dps); }
			}
		}
		hit(dmg) {
			if (this.dead) return;
			this.hp -= dmg;
			if (this.type.tier) this.tookDamage = true;
			if (this.hp <= 0) { this.dead = true; SFX_MOB_DEATH(); onMobKilled(this); }
		}
		draw(ctx) {
			if (this.dead) return;
			ctx.save();
			if (this.type.tier === "boss") { ctx.fillStyle = '#ef4444'; ctx.strokeStyle = '#b91c1c'; }
			else if (this.type.tier === "mini") { ctx.fillStyle = '#f59e0b'; ctx.strokeStyle = '#b45309'; }
			else { ctx.fillStyle = '#22d3ee'; ctx.strokeStyle = '#0ea5b7'; }
			ctx.lineWidth = 1.5;
			roundRect(ctx, this.x, this.y, this.w, this.h, 6);
			ctx.fill(); ctx.stroke();

			if (this.type.tier && this.tookDamage) {
				const ratio = clamp(this.hp / this.hpMax, 0, 1);
				const barW = this.w, barH = 4;
				ctx.fillStyle = '#0f172a';
				ctx.fillRect(this.x, this.y - 6, barW, barH);
				ctx.fillStyle = '#fca5a5';
				ctx.fillRect(this.x, this.y - 6, barW * ratio, barH);
			}
			ctx.restore();
		}
	}
	class Bullet
	{
		constructor(x, y, dirX, dirY, speed, dmg, crit=false) {
			const len = Math.hypot(dirX, dirY) || 1;
			this.vx = (dirX/len) * speed; this.vy = (dirY/len) * speed;
			this.x = x; this.y = y; this.r = BULLET_RADIUS_SIZE; this.dmg = dmg; this.crit = crit; this.dead = false;
		}
		update(dt) {
			if (this.dead) return;
			this.x += this.vx * dt; this.y += this.vy * dt;
			if (this.x < -12 || this.x > W + 12 || this.y < -12 || this.y > H + 12) { this.dead = true; return; }
			for (const m of state.enemies) {
				if (m.dead) continue;
				const cx = Math.max(m.x, Math.min(this.x, m.x + m.w));
				const cy = Math.max(m.y, Math.min(this.y, m.y + m.h));
				const dx = this.x - cx, dy = this.y - cy;

				if (dx*dx + dy*dy <= this.r*this.r) {
					m.hit(this.dmg);
					// spawn damage number slightly above the mob
					const showX = cx;
					const showY = m.y - 6;
					(state.dmgNums || (state.dmgNums = [])).push(new DmgNum(showX, showY, this.dmg, this.crit));
					this.dead = true;
					break;
				}
			}
		}
		draw(ctx) {
			if (this.dead) return;
			ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
			ctx.fillStyle = this.crit ? '#fb7185' : '#fbbf24'; ctx.fill();
			ctx.shadowColor = this.crit ? '#fecdd3' : '#fde68a'; ctx.shadowBlur = 10; ctx.restore();
		}
	}
	class DmgNum
	{
		constructor(x, y, val, crit=false) {
			this.x = x + (Math.random()*8 - 4);
			this.y = y;
			this.val  = Math.round(val);
			this.crit = crit;
			
			this.age  = 0;
			this.life = DMG_NUM_LIFETIME;
			
			// jump physics
			this.vx = (Math.random() * 20 - 10);
			this.vy = DMG_NUM_VY0;
		}
		update(dt) {
			this.age += dt;
			this.vy  += DMG_NUM_GRAVITY * dt;
			this.x   += this.vx * dt;
			this.y   += this.vy * dt;
		}
		draw(ctx) {
			const a = Math.max(0, 1 - this.age / this.life);
			let s = 1;
			if (this.age < DMG_NUM_POP_TIME) {
				const t = 1 - (this.age / DMG_NUM_POP_TIME); //dmg poptime
				s = 1 + 0.25 * t;
			}
			ctx.save();
			ctx.globalAlpha = a;
			ctx.translate(this.x, this.y);
			ctx.scale(s, s);
			ctx.font = this.crit ? '600 25px "Rajdhani", sans-serif' : '600 22px "Rajdhani", sans-serif';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			ctx.lineWidth = 3;
			ctx.strokeStyle = 'rgba(0,0,0,0.6)';
			ctx.fillStyle   = this.crit ? '#f59e0b' : '#FFFFFA'; // orange crit, white normal
			ctx.strokeText(this.val, 0, 0);
			ctx.fillText(this.val, 0, 0);
			ctx.restore();
		}
	}
	
	
	// =============== Core Game Functions =============== //
	// Player
	function drawSoldier(ctx) {
		const p = state.player;
		ctx.save(); ctx.translate(p.x, p.y);
		ctx.fillStyle = '#a78bfa'; ctx.strokeStyle = '#7c3aed'; ctx.lineWidth = 1;
		ctx.beginPath(); ctx.moveTo(0,-p.size); ctx.lineTo(p.size*.9,p.size); ctx.lineTo(-p.size*.9,p.size); ctx.closePath();
		ctx.fill(); ctx.stroke();
		const t = findClosestInRange();
		if (t) {
			const dx = t.cx - p.x, dy = t.cy - p.y;
			const len = Math.hypot(dx, dy) || 1; const ux = dx/len, uy = dy/len;
			ctx.beginPath(); ctx.moveTo(0, -p.size*0.5); ctx.lineTo(ux*18, uy*18 - p.size*0.5);
			ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 3; ctx.stroke();
		}
		ctx.restore();
	}
	function updateSoldier(dt) {
		if (!state.weapons || state.weapons.length === 0) return;
		for (const w of state.weapons) {
			w.timer -= dt;
			
			if (w.lockoutTotal > 0 && (w.mode === 'burst' || w.mode === 'cooldown')) {
				w.lockoutElapsed = Math.min(w.lockoutTotal, (w.lockoutElapsed || 0) + dt);
			}

			if (w.mode === 'idle') {
				const nearest = findClosestEnemy(w.stats.range);
				if (nearest) {
					let chosen = nearest;
					if (Math.random() >= GUN_MULTITARGET_PROBILITY) {
						const p = state.player, r2 = w.stats.range*w.stats.range;
						const pool = [];
						for (const m of state.enemies) {
							if (m.dead) continue;
							const dx=p.x-m.cx, dy=p.y-m.cy, d2=dx*dx+dy*dy;
							if (d2<=r2) pool.push(m);
						}
						if (pool.length) chosen = pool[(Math.random()*pool.length)|0];
					}
					
					//update player-facing angle
					const p = state.player;
					const dx = chosen.cx - p.x, dy = chosen.cy - p.y;
					const L = Math.hypot(dx, dy) || 1;
					w.dirX = dx / L;
					w.dirY = dy / L;
					state.player.aimVX = w.dirX;
					state.player.aimVY = w.dirY;
					
					// --- fire gun ----
					w.mode = 'burst';
					w.burstLeft = w.stats.bulletsPerUse;
					w.timer = 0;
					playGunFire(w.stats.name);
					//cooldown clock-wise
					const burstTime = Math.max(0, (w.stats.bulletsPerUse - 1)) * effectiveTimeBetweenBullets(w);
					w.lockoutTotal = burstTime + effectivePostUseCooldown(w);
					w.lockoutElapsed = 0;
				}
			}
			else if (w.mode === 'burst') 
			{
				//apply traits
				let trait_dmg_up_multiplier = 0;
				let trait_cdr_up_multiplier = 0;
				switch(w.stats.tags){
					case "normal" : 
						trait_dmg_up_multiplier = (state.normal_dmg_increase / 100);
						trait_cdr_up_multiplier = (state.normal_reload_decrease / 100);
						break;
					case "aoe" : 
						trait_dmg_up_multiplier = (state.aoe_dmg_increase / 100);
						trait_cdr_up_multiplier = (state.aoe_reload_decrease / 100);
						break;
					case "pierce" : 
						trait_dmg_up_multiplier = (state.pierce_dmg_increase / 100);
						trait_cdr_up_multiplier = (state.pierce_reload_decrease / 100);
						break;
				}
				
				//onMobHit, deals damage
				while (w.burstLeft > 0 && w.timer <= 0) {
					if (w.dirX == null || w.dirY == null) break;

					//submachine gun tier 3 skill
					let forceCrit = false;
					if (w.stats.name === "submachinegun" && w.tier === 3 && w.stats.ability === "submachinegun_T3_GuaranteedCritAfter5") {
						w.shotsSinceAbility = (w.shotsSinceAbility || 0) + 1;
						if (w.shotsSinceAbility >= 5) { forceCrit = true; w.shotsSinceAbility = 0; }
					}
					
					//damage calculator
					const isCrit = forceCrit || (Math.random() < CRIT_RATE);
					let dmg = w.stats.damage * (isCrit ? CRIT_MULT : 1); dmg += dmg * trait_dmg_up_multiplier;
					
					const p = state.player;
					state.bullets.push(new Bullet(
						p.x, p.y - p.size*0.6,
						w.dirX, w.dirY,
						w.stats.bulletSpeed, dmg, isCrit
					));
					w.burstLeft--;
					w.timer += w.stats.timeBetweenBullets;
				}
				//goes off cooldown
				if (w.burstLeft === 0 && w.timer <= 0) {
					w.mode = 'cooldown';
					w.timer = effectivePostUseCooldown(w);
				}
			}
			else if (w.mode === 'cooldown') {
				if (w.timer <= 0) {
					w.mode = 'idle';
					w.lockoutElapsed = 0;
					w.lockoutTotal = 0;
				}
			}
		}
	}
	function findClosestInRange() {
		const ranges = (state.weapons && state.weapons.length)
		? state.weapons.map(w => w.stats.range)
		: [Infinity];
		const maxRange = Math.max(...ranges);
		return findClosestEnemy(maxRange);
	}
	
	//Mob
	function onMobKilled(m) {
		//add coin, score, kill count, exp
		state.coins += m.type.coin + Math.round((m.type.coin * (state.goldGainBonus / 100))); // gold gain trait
		state.score += m.type.score || 0;
		state.kills++;
		state.player.exp += m.type.exp + Math.round((m.type.exp * (state.expGainBonus / 100))); // exp gain trait
		
		//level up
		while (state.player.exp >= state.player.expToNext) {
			state.player.exp -= state.player.expToNext;
			state.player.level += 1;
			state.player.expToNext = Math.ceil(state.player.expToNext * 1.3);
			enqueueTraitChoice(1);
		}
		
		//update scoreboard
		const fmt = n => Number(n).toLocaleString('en-US'); //add comma to digits
		coinNumEl.textContent  = String(fmt(state.coins));
		scoreNumEl.textContent = String(fmt(state.score));
		levelNumEl.textContent = String(state.player.level);
		
		//update exp bar
		const pct = Math.round((state.player.exp / state.player.expToNext) * 100);
		expFill.style.width = pct + '%';
	}
	function computeMobIntervalForWave(wave) {
		const t = Math.pow(MOB_INTERVAL_DECAY_PER_WAVE, Math.max(0, wave-1));
		return Math.max(MOB_INTERVAL_MIN, Math.min(MOB_INTERVAL_BASE, MOB_INTERVAL_BASE * t));
	}
	
	//Damage Number
	function updateDamageNumbers(dt) {
		if (!state.dmgNums) return;
		for (const d of state.dmgNums) d.update(dt);
		state.dmgNums = state.dmgNums.filter(d => d.age < d.life);
	}
	function drawDamageNumbers(ctx) {
		if (!state.dmgNums) return;
		for (const d of state.dmgNums) d.draw(ctx);
	}
	
	//Pick Traits
	function traitTierWeightsForLevel(level){
		// t is 0..1 (0 at level 1, 1 at level 21+)
		const t = Math.max(0, Math.min(1, (level-1)/20));
		const w1 = 0.70 * (1 - t) + 0.20 * t;   // 0.70 → 0.20
		const w3 = 0.05 * (1 - t) + 0.45 * t;   // 0.05 → 0.45
		const w2 = Math.max(0, 1 - w1 - w3);    // the rest
		return [w1, w2, w3];
	}
	function pickTierForLevel(level){
		const [w1, w2, w3] = traitTierWeightsForLevel(level);
		const r = Math.random();
		if (r < w1) return 1;
		if (r < w1 + w2) return 2;
		return 3;
	}
	
	//Barrage
	function drawBarrage(ctx) {
		ctx.save();
		const y = BARRICADE_Y;
		ctx.beginPath(); ctx.moveTo(12,y); ctx.lineTo(W-12,y);
		//ctx.strokeStyle = 'rgba(148,163,184,0.9)'; ctx.lineWidth = 0;
		//ctx.stroke(); //hide barrage
		ctx.restore();
	}
	function applyBarrageDamage(dmg) {
		if (state.gameOver) return;
		const maxHP = BARRICADE_HP_MAX;
		const bar = document.getElementById('hpFill');
		const txt = document.getElementById('hpText');
		state.barricadeHP = (state.barricadeHP ?? maxHP) - dmg;
		state.barricadeHP = Math.max(0, Math.min(maxHP, state.barricadeHP));
		const pct = Math.round((state.barricadeHP / maxHP) * 100);
		bar.style.width = pct + '%'; txt.textContent = pct + '%';
		if (state.barricadeHP <= 0) gameOver();
	}
  
	//Wave
	function startWave(n, totalCount) {
		state.wave = n; waveNumEl.textContent = String(n);
		state.toSpawn = totalCount; state.groupIndex = 0; state.groupMobIndex = 0;
		state.specialsSpawned = false; state.specialsProgress = 0; state.specialsTimer = 0;
		state.groupIntervalTimer = 0; state.mobIntervalWave = computeMobIntervalForWave(n); state.mobIntervalTimer = 0;
		state.groupSizes = splitIntoGroups(totalCount, GROUPS_PER_WAVE);
		state.specialsQueued.mini = (n % 5 === 0);
		state.specialsQueued.boss = (n % 10 === 0);
	}
	function spawnOneNormalMob() {
		const s = MOBS["A"].size;
		const x = Math.max(0, Math.min(W - s, Math.random() * (W - s)));
		const y = -s - (Math.random() * 140 + 20);
		state.enemies.push(new Mob(MOBS["A"], x, y));
	}
	function spawnSpecial(type) {
		const s = type.size;
		const x = Math.max(0, Math.min(W - s, Math.random() * (W - s)));
		const y = -s - (Math.random() * 130 + 30);
		state.enemies.push(new Mob(type, x, y));
	}
	function showBossWarning(text = "BOSS APPROACHING") {
		bossWarn.textContent = text;
		bossWarn.classList.add('show');
		const per = Math.max(0.1, BOSS_WARN_TOTAL_DURATION / Math.max(1, BOSS_WARN_FLASHES));
		bossWarn.style.animation = 'none'; void bossWarn.offsetWidth;
		bossWarn.style.animation = `warnPulse ${per}s ease-in-out ${Math.max(1, BOSS_WARN_FLASHES)}`;
		clearTimeout(bossWarn._hideTO);
		bossWarn._hideTO = setTimeout(()=>{ bossWarn.classList.remove('show'); bossWarn.style.animation='none'; }, Math.max(0, BOSS_WARN_TOTAL_DURATION)*1000 + 50);
	}
	function updateSpawning(dt) {
		if (state.groupIndex >= GROUPS_PER_WAVE) return;

		if (state.groupMobIndex === 0 && state.groupIndex > 0 && state.groupIntervalTimer > 0) {
			state.groupIntervalTimer -= dt; return;
		}
		const isLastGroup = (state.groupIndex === GROUPS_PER_WAVE - 1);
		const groupSize = state.groupSizes[state.groupIndex] || 0;
		if (isLastGroup && (state.specialsQueued.mini || state.specialsQueued.boss) && !state.specialsSpawned) {
			if (state.specialsProgress === 0) {
				if (state.specialsQueued.boss) showBossWarning();
				if (state.specialsQueued.mini) {
					spawnSpecial(MINI_BOSS_A);
					state.specialsProgress = 1;
					if (state.specialsQueued.boss) { state.specialsTimer = BOSS_MINI_TO_BOSS_INTERVAL; return; }
					else { state.specialsSpawned = true; }
				}
				else {
					if (state.specialsQueued.boss) spawnSpecial(BOSS_A);
					state.specialsSpawned = true; state.specialsProgress = 2;
				}
			}
			else if (state.specialsProgress === 1 && state.specialsQueued.boss) {
				state.specialsTimer -= dt;
				if (state.specialsTimer <= 0) { spawnSpecial(BOSS_A); state.specialsSpawned = true; state.specialsProgress = 2; }
				else return;
			}
		}
		if (state.groupMobIndex < groupSize) {
			state.mobIntervalTimer -= dt;
			if (state.mobIntervalTimer <= 0) {
				spawnOneNormalMob();
				state.groupMobIndex += 1; state.toSpawn -= 1; state.mobIntervalTimer = state.mobIntervalWave;
			}
		}
		else {
			if (state.groupIndex < GROUPS_PER_WAVE - 1) {
				state.groupIndex += 1; state.groupMobIndex = 0; state.groupIntervalTimer = GROUP_INTERVAL_BASE; state.mobIntervalTimer = 0;
			} else { state.groupIndex = GROUPS_PER_WAVE; }
		}
	}
	function maybeStartNextWave() {
		if (state.groupIndex < GROUPS_PER_WAVE) return;
		const anyAlive = state.enemies.some(e => !e.dead);
		if (!anyAlive) {
			const nextCount = Math.max(1, Math.ceil(waveCountFor(state.wave + 1)));
			window.openShopOverlay(state.wave + 1, nextCount);
		}
	}
	function startWave(n, totalCount) {
		state.wave = n; waveNumEl.textContent = String(n);
		state.toSpawn = totalCount; state.groupIndex = 0; state.groupMobIndex = 0;
		state.specialsSpawned = false; state.specialsProgress = 0; state.specialsTimer = 0;
		state.groupIntervalTimer = 0; state.mobIntervalWave = computeMobIntervalForWave(n); state.mobIntervalTimer = 0;
		state.groupSizes = splitIntoGroups(totalCount, GROUPS_PER_WAVE);
		state.specialsQueued.mini = (n % 5 === 0);
		state.specialsQueued.boss = (n % 10 === 0);
	}
	function spawnOneNormalMob() {
		const s = MOBS["A"].size;
		const x = Math.max(0, Math.min(W - s, Math.random() * (W - s)));
		const y = -s - (Math.random() * 140 + 20);
		state.enemies.push(new Mob(MOBS["A"], x, y));
	}
	function spawnSpecial(type) {
		const s = type.size;
		const x = Math.max(0, Math.min(W - s, Math.random() * (W - s)));
		const y = -s - (Math.random() * 130 + 30);
		state.enemies.push(new Mob(type, x, y));
	}
	function showBossWarning(text = "BOSS APPROACHING") {
		bossWarn.textContent = text;
		bossWarn.classList.add('show');
		const per = Math.max(0.1, BOSS_WARN_TOTAL_DURATION / Math.max(1, BOSS_WARN_FLASHES));
		bossWarn.style.animation = 'none'; void bossWarn.offsetWidth;
		bossWarn.style.animation = `warnPulse ${per}s ease-in-out ${Math.max(1, BOSS_WARN_FLASHES)}`;
		clearTimeout(bossWarn._hideTO);
		bossWarn._hideTO = setTimeout(()=>{ bossWarn.classList.remove('show'); bossWarn.style.animation='none'; }, Math.max(0, BOSS_WARN_TOTAL_DURATION)*1000 + 50);
	}
	function updateSpawning(dt) {
		if (state.groupIndex >= GROUPS_PER_WAVE) return;
		
		if (state.groupMobIndex === 0 && state.groupIndex > 0 && state.groupIntervalTimer > 0) {
			state.groupIntervalTimer -= dt; return;
		}
		const isLastGroup = (state.groupIndex === GROUPS_PER_WAVE - 1);
		const groupSize = state.groupSizes[state.groupIndex] || 0;
		if (isLastGroup && (state.specialsQueued.mini || state.specialsQueued.boss) && !state.specialsSpawned) {
			if (state.specialsProgress === 0) {
				if (state.specialsQueued.boss) showBossWarning();
				if (state.specialsQueued.mini) {
					spawnSpecial(MINI_BOSS_A);
					state.specialsProgress = 1;
					if (state.specialsQueued.boss) { state.specialsTimer = BOSS_MINI_TO_BOSS_INTERVAL; return; }
					else { state.specialsSpawned = true; }
				}
				else {
					if (state.specialsQueued.boss) spawnSpecial(BOSS_A);
					state.specialsSpawned = true; state.specialsProgress = 2;
				}
			}
			else if (state.specialsProgress === 1 && state.specialsQueued.boss) {
				state.specialsTimer -= dt;
				if (state.specialsTimer <= 0) { spawnSpecial(BOSS_A); state.specialsSpawned = true; state.specialsProgress = 2; }
				else return;
			}
		}
		if (state.groupMobIndex < groupSize) {
			state.mobIntervalTimer -= dt;
			if (state.mobIntervalTimer <= 0) {
				spawnOneNormalMob();
				state.groupMobIndex += 1; state.toSpawn -= 1; state.mobIntervalTimer = state.mobIntervalWave;
			}
		}
		else {
			if (state.groupIndex < GROUPS_PER_WAVE - 1) {
				state.groupIndex += 1; state.groupMobIndex = 0; state.groupIntervalTimer = GROUP_INTERVAL_BASE; state.mobIntervalTimer = 0;
			}else { state.groupIndex = GROUPS_PER_WAVE; }
		}
	}
	
	//Game Over
	function gameOver() {
		if (state.gameOver) return;
		state.gameOver = true;
		state.paused = true;
		setHUDEnabled(false);
		setOverlay(true, "Game Over");
	}

	// ============== UI ============== //
	function setHUDEnabled(enabled){ speedBtn.disabled=!enabled; pauseBtn.disabled=!enabled; }
	
	//Pause / Game Over Overlay
	function setOverlay(show, title="Paused") {
		const resumeVisible = !(state.gameOver && title === "Game Over");
		
		const resumeBtn = document.getElementById('resumeBtn');
		resumeBtn.style.display = resumeVisible ? 'inline-block' : 'none';
		
		if(show) {
			fadeAudio(bgm, 0, 200);
			pauseOverlay.classList.remove('hidden');
		}
		else {
			fadeAudio(bgm, 0.35,200);
			pauseOverlay.classList.add('hidden');
		}
	}
	function pauseToggle() {
		if (state.gameOver) return;
		state.paused = !state.paused;
		if (state.paused) {
			setOverlay(true,"Paused");
		}
		else {
			setOverlay(false); 
		}
	}
	
	//Traits
	function openTraitOverlay() {
		state.traitOverlayOpen = true;
		state.paused = true;
		fadeAudio(bgm, 0, 200);
		
		// How many cards? 3 + maybe 1 extra
		const count = TRAIT_BASE_CARD_COUNT + (Math.random() < TRAIT_EXTRA_CARD_CHANCE ? 1 : 0);
		const offer = [];
		const usedPairs = new Set();
		let guard = 200; // safety to avoid infinite loops if trait pool is too small

		while (offer.length < count && guard-- > 0) {
			const def = TRAITS[(Math.random() * TRAITS.length) | 0];
			const tier = pickTierForLevel(state.player.level);
			const key = def.id + '|' + tier;

			if (usedPairs.has(key)) continue; // skip exact (id,tier) duplicates

			offer.push({ id: def.id, tier });
			usedPairs.add(key);
		}
		
		state.traitSelected = null;
		const cardsWrap   = document.getElementById('traitCards');
		
		// Render cards
		traitCardsBox.innerHTML = "";
		traitCardsBox.classList.add("trait-vertical");
		offer.forEach(o => {
			const def = TRAITS.find(x => x.id === o.id);
			const nameTxt = typeof def.name === 'function' ? def.name(o.tier) : def.name;
			const descTxt = typeof def.desc === 'function' ? def.desc(o.tier) : (def.desc || '');
			const scaleTxt = typeof def.scaling === 'function' ? def.scaling(o.tier) : (def.scaling ?? '');

			const card = document.createElement('div');
			card.className = 'trait-card';
			card.dataset.tier = String(o.tier);
			
			//trait radio button
			const radio = document.createElement('div');
			radio.className = 'trait-radio';
			
			//trait picture
			const icon = document.createElement('div');
			icon.className = 'trait-icon';
			const icon_img = document.createElement('div');
			icon_img.className = 'trait-icon-img';
			icon.appendChild(icon_img);
			
			//text body
			const body = document.createElement('div');
			body.className = 'trait-text';
			const title = document.createElement('div');
			title.className = 'trait-title';
			title.textContent = nameTxt;

			const desc = document.createElement('div');
			desc.className = 'trait-desc';
			desc.innerHTML = descTxt + '<span class="accent">' + scaleTxt + '%' + '</span>';
			
			body.appendChild(title);
			body.appendChild(desc);
			card.appendChild(radio);
			card.appendChild(icon);
			card.appendChild(body);
			
			//Click on Card
			card.addEventListener('click', () => {
				cardsWrap.querySelectorAll('.trait-card.selected').forEach(el => el.classList.remove('selected'));
				card.classList.add('selected');
				state.traitSelected = { id: o.id, tier: o.tier };
				traitStart.classList.toggle('is-disabled', false);
			});
			
			traitCardsBox.appendChild(card);
		});
		traitCardsBox.style.gridTemplateColumns = `repeat(${offer.length}, 1fr)`;
		traitOverlay.classList.remove('hidden');
		
		if (traitStart && !traitStart._wired) {
			traitStart._wired = true;
			traitStart.addEventListener('click', onTraitStartConfirm);
		}
		
		//set trait-layout-top Height based on num of traits produced
		const traitCardHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--trait-card-h').trim());
		const traitCardGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--trait-card-gap').trim());
		document.querySelector('.trait-layout-top').style.setProperty('--trait-layout-top-h', Number(offer.length) * Number(traitCardHeight) + (Number(offer.length) -1) * Number(traitCardGap));
	}
	function closeTraitOverlay() {
		state.traitOverlayOpen = false;
		traitOverlay.classList.add('hidden');
		traitStart.classList.toggle('is-disabled', true);
		
		state.traitQueue = Math.max(0, (state.traitQueue || 0) - 1);
		if (state.traitQueue > 0) {
			openTraitOverlay();
			return;
		}
		maybeResumeGameIfNoOverlays();
	}
	function onTraitStartConfirm() {
		const btn = this; // #traitStartBtn
		if (!state.traitSelected) return;
		
		const { id, tier } = state.traitSelected;
		applyTrait(id, tier);
		
		state.traitSelected = null;
		btn.disabled = true;
		closeTraitOverlay();
	}
	function maybeResumeGameIfNoOverlays() {
		const anyShopOpen = !document.getElementById('shopOverlay')?.classList.contains('hidden');
		const anyTraitOpen = state.traitOverlayOpen === true;
		const traitStillQueued = (state.traitQueue || 0) > 0;

		// If anything is still pending, keep paused and keep bgm low.
		if (anyShopOpen || anyTraitOpen || traitStillQueued) {
			state.paused = true;
			return;
		}
		state.paused = false;
		fadeAudio(bgm, 0.35, 200);
	}
	function enqueueTraitChoice(n = 1) {
		state.traitQueue = (state.traitQueue || 0) + n;
		if (!state.traitOverlayOpen) {
			openTraitOverlay();
		}
	}
	function updateTraitViewer() {
		traitListBox.innerHTML = "";
		
		const groups = new Map(); // id -> tiers[]
		for (const t of (state.traitsOwned || [])) {
			if (!groups.has(t.id)) groups.set(t.id, []);
			groups.get(t.id).push(t.tier);
		}
		if (groups.size === 0) {
			const empty = document.createElement('div');
			empty.className = 'trait-pill';
			empty.textContent = "No traits yet.";
			traitListBox.appendChild(empty);
			return;
		}

		for (const [id, tiers] of groups) {
			const def = TRAITS.find(x => x.id === id);
			if (!def) continue;
			
			const maxTier = Math.max(...tiers);
			const nameTxt = typeof def.name === 'function' ? def.name(maxTier) : def.name;
			const descTxt = typeof def.desc === 'function' ? def.desc(maxTier) : (def.desc || '');
			
			let totalText = '';
			if (def.statKey) {
				const base = def.statBase ?? 0;
				const val = (state[def.statKey] ?? base) - base;
				totalText = def.formatTotal ? def.formatTotal(val) : String(val);
			}
			else if (typeof def.totalFromTiers === 'function') {
				const val = def.totalFromTiers(tiers);
				totalText = def.formatTotal ? def.formatTotal(val) : String(val);
			}
			else {
				totalText = `${tiers.length}×`;
			}
			
			const row = document.createElement('div');
			row.className = 'trait-pill';
			row.innerHTML = '<div>' + descTxt + '<span>' + totalText + '</span></div>';
			traitListBox.appendChild(row);
		}
	}
	function openTraitViewer(){ updateTraitViewer(); traitOverlayViewer.classList.remove('hidden'); }
	function closeTraitViewer(){ traitOverlayViewer.classList.add('hidden'); }
	
  
	//Buttons
	resumeBtn.addEventListener('click', ()=>{ if (state.gameOver) return; state.paused=false; setOverlay(false); });
	restartBtn.addEventListener('click', ()=>{ restart(); });
	pauseBtn.addEventListener('click', pauseToggle);
	speedBtn.addEventListener('click', ()=>{ if (speedBtn.disabled) return; state.speedMult = state.speedMult % 3 + 1; speedBtn.innerHTML = state.speedMult+"x"; try { localStorage.setItem(SPEED_STORAGE_KEY, String(state.speedMult)); } catch (_) {} });
	closeTraitViewerBtn.addEventListener('click', closeTraitViewer);
	document.getElementById('viewTraitsBtn')?.addEventListener('click', ()=>{openTraitViewer();});
	
	
	//Apply Traits
	function applyTrait(id, tier) {
		const def = TRAITS.find(t=>t.id===id);
		if (!def) return;
		if (def.scope === 'global')  def.apply(tier); 
		else for (const w of (state.weapons || [])) def.apply(tier, w);
		state.traitsOwned.push({ id, name: def.name, tier });
		updateTraitViewer();
	}
	
	//Load Inventory Grid
	function renderInventory() {
		const invGrid = document.getElementById('inventoryGrid');
		invGrid.innerHTML = "";

		for (let i = 0; i < 16; i++) {
			const item = state.inventory[i];
			const d = document.createElement('div');
			d.className = "slot" + (item ? " filled" : "");

			if (item) {
				//tier background
				const bg = document.createElement('img');
				bg.className = 'slot-layer slot-bg';
				bg.alt = 'tier background';
				bg.src = `src/img/UI_battlefield_inventory_slot_background_tier_${item.tier ?? 1}.png`;
				bg.draggable = false;
				bg.addEventListener('dragstart', e => e.preventDefault());
				d.appendChild(bg);
				
				//gun image
				const gun = document.createElement('img');
				gun.className = 'slot-layer slot-gun';
				gun.alt = item.name;
				const slug = String(item.name);
				gun.src = `src/img/gun_${slug}.png`;
				gun.draggable = false;
				gun.addEventListener('dragstart', e => e.preventDefault());
				d.appendChild(gun);
				
				//cooldown (clock-wise)
				const cd = document.createElement('div');
				cd.className = 'slot-layer slot-cd';
				cd.dataset.wi = i;
				d.appendChild(cd);
			}
			invGrid.appendChild(d);
		}
	}
	
	function updateInventoryCooldownUI(){
		const grid = document.getElementById('inventoryGrid');
		if (!grid || !state.weapons) return;
		
		const cds = grid.querySelectorAll('.slot-cd');
		cds.forEach(el => {
			const wi = +el.dataset.wi;
			const w = state.weapons[wi];
			if (!w) { el.style.opacity = 0; return; }
			
			const busy = (w.mode === 'burst' || w.mode === 'cooldown');
			if (busy && w.lockoutTotal > 0) {
				const frac = (w.lockoutElapsed || 0) / w.lockoutTotal;  // 0 at fire → 1 when ready
				el.style.opacity = 1;
				el.style.setProperty('--cd', String(Math.max(0, Math.min(1, frac))));
			}
			else {
				el.style.opacity = 0;
				el.style.setProperty('--cd', "0");
			}
		});
	}
	
	
	// ------- Restart/Reset Game ------- //
	function restart() 
	{
		state.paused=false;
		state.gameOver=false;
		
		//reset game properties
		state.enemies.length=0; state.bullets.length=0;
		state.coins=0; state.score=0; state.kills=0;
		state.player.level=1; state.player.exp=0; state.player.expToNext=50; state.player.mode='idle'; state.player.burstLeft=0; state.player.timer=0;
		state.traitsOwned = [];
		state.dmgNums = [];
		state.goldGainBonus = 0;
		state.expGainBonus = 0;
		state.normal_dmg_increase = 0;
		state.aoe_dmg_increase = 0;
		state.pierce_dmg_increase = 0;
		state.normal_reload_decrease = 0;
		state.aoe_reload_decrease = 0;
		state.pierce_reload_decrease = 0;
		state.traitQueue = 0;
		state.traitOverlayOpen = false;
		
		//empty inventory
		state.inventory = new Array(16).fill(null);
		renderInventory();
		
		//get game speed
		const saved = parseInt(localStorage.getItem(SPEED_STORAGE_KEY) || "1", 10);
		state.speedMult = [1,2,3].includes(saved) ? saved : 1;
		speedBtn.innerHTML = state.speedMult+"x";
		
		//reset scoreboard
		coinNumEl.textContent=state.coins;
		scoreNumEl.textContent="0";
		
		//reset EXP
		levelNumEl.textContent="1";
		expFill.style.width='0%';
		
		//reset barrrage HP
		state.barricadeHP = BARRICADE_HP_MAX;
		document.getElementById('hpFill').style.width='100%';
		document.getElementById('hpText').textContent='100%';
		
		//restart game
		const startWaveNum = Math.max(1, Math.floor(CURRENT_WAVE));
		const startCount = waveCountFor(startWaveNum);
		state.pendingWave = { n: startWaveNum, count: startCount };
		window.openShopOverlay(state.pendingWave.n, state.pendingWave.count, true);
		ensureBgmPlaying(true);
		setHUDEnabled(true);
		setOverlay(false);
	}
	
	
	// ------- Frame Game Loop ------- //
	let __dm=1; addEventListener('keydown',e=>{if(e.code==='Space')__dm=10}); addEventListener('keyup',e=>{if(e.code==='Space')__dm=1});
	requestAnimationFrame(function loop(now)
	{
		const rawDt = Math.min((now - (loop.t||now)) / 1000, 0.05); loop.t = now;
		if (!state.paused && !state.gameOver)
		{
			const dt = rawDt * state.speedMult * (__dm||1);
			updateSpawning(dt);
			for (const m of state.enemies) m.update(dt);
			for (const b of state.bullets) b.update(dt);
			state.bullets = state.bullets.filter(b => !b.dead);
			updateDamageNumbers(dt);
			updateSoldier(dt);
			updateInventoryCooldownUI();
			maybeStartNextWave();
			
			// Update soldier GIF based on facing band
			if (typeof computeFacingIndex === 'function' && soldierSpriteEl)
			{
				const fIdx = computeFacingIndex();
				if (fIdx !== _soldierIdx) {
					_soldierIdx = fIdx;
					soldierSpriteEl.src = SOLDIER_ANGLES[_soldierIdx];
				}
			}
		}
		ctx.clearRect(0,0,W,H);
		drawBarrage(ctx);
		for (const m of state.enemies) m.draw(ctx);
		for (const b of state.bullets) b.draw(ctx);
		drawDamageNumbers(ctx);
		drawSoldier(ctx);
		requestAnimationFrame(loop);
	});

	restart();
	
	//Bridge
	try {
		window.GUNS = GUNS;
		window.__gameState = state;
		window.fadeAudio = fadeAudio;
		window.startWave = startWave;
		window.openTraitViewer = openTraitViewer;
		window.renderInventory = renderInventory;
		window.makeWeaponInstance = makeWeaponInstance;
	} catch(_) {}
})();

// ======= Shop (9x9) =======
(function(){
	const shopOverlay = document.getElementById('shopOverlay');
	const shopGridEl  = document.getElementById('shopGrid');
	const shopOfferEl = document.getElementById('shopOffer');
	const shopStartBtn = document.getElementById('shopStartBtn');
	const btnRerollOffer = document.getElementById('btnShop_rerollOffer');
	
	if (!shopOverlay || !shopGridEl || !shopOfferEl) return;
	
	// ----------------------- Configs ----------------------- //
	const GRID_ROWS = 9, GRID_COLS = 9;
	const MINI_CELL = 35;
	const CELL = 49;
	const CELL_GAP = 3;
	const cellStep = CELL + CELL_GAP; //distance between consecutive cols/rows

	const numShopItem = 3;
	const root = document.documentElement;
	root.style.setProperty('--shop-gun-offer-count',  numShopItem);
	
	let shop_rerollPrice = 1000;
	const shop_rerollIncrement = 1000;
	const shop_rerollFreeNum = 3;
	let shop_currRerollFree = shop_rerollFreeNum;
	
	let mergeHighlightSet = new Set();
	
	const TIER_COLORS = {
		1: ['#34d399', '#059669'], // green
		2: ['#60a5fa', '#1d4ed8'], // blue
		3: ['#a78bfa', '#7c3aed'], // purple
		4: ['#facc15', '#eab308'], // yellow-ish/gold
	};
	const SHOP_TIER_CHANCE = {
		1: 50,
		2: 42,
		3: 7.5,
		4: 0.5
	};
	const SHAPES = {
		submachinegun: [[0,0],[0,1],[0,2],[1,0]],
		pistol: [[0,0],[0,1],[1,0]],
		sniperriffle: [[0,0],[1,0],[2,0],[3,0],[3,1]],
		assultriffle: [[0,0],[0,1],[1,1],[0,2],[0,3]],
		grenadelauncher: [[1,0],[1,1],[0,1],[0,2]],
	};
	
	// ------- Drag & Drop -------
	let ghost            = null;
	let dragFrom         = null;   // 'grid' or 'offer'
	let startPos         = null;   // { r, c } where the item started
	let activePointerId  = null;
	let draggingItem     = null;   // the shopState.items entry being dragged
	let draggingSourceEl = null;   // the DOM element we picked up from
	let lastSnap         = null;   // { r, c, ok:true } of the current preview
	let previewWrap      = null;   // .placement-preview layer in the grid
	let grabOffsetX      = 0;
	let grabOffsetY      = 0;

	let ghostAnimId   = null;
	let ghostCurrX    = 0;
	let ghostCurrY    = 0;
	let ghostTargetX  = 0;
	let ghostTargetY  = 0;

	let shopState = {
		items: [],
		dragging: null,
		pending: null
	};
	
	//build shop grid
	shopGridEl.innerHTML = '';
	for (let r = 0; r < GRID_ROWS; r++) {
		for (let c = 0; c < GRID_COLS; c++) {
			const slot = document.createElement('div');
			slot.className = 'cell';
			slot.style.position = 'absolute';
			slot.style.left = (c * (CELL + CELL_GAP)) + 'px';
			slot.style.top = (r * (CELL + CELL_GAP)) + 'px';
			slot.style.width = CELL + 'px';
			slot.style.height = CELL + 'px';
			slot.style.backgroundImage = "url('src/img/UI_shop_slot_background_empty.png')";
			slot.style.backgroundRepeat = 'no-repeat';
			slot.style.backgroundSize = '100% 100%';
			slot.style.backgroundPosition = 'center';
			shopGridEl.appendChild(slot);
		}
	}
	shopGridEl.style.width  = (GRID_COLS * (CELL + CELL_GAP) - CELL_GAP) + 'px';
	shopGridEl.style.height = (GRID_ROWS * (CELL + CELL_GAP) - CELL_GAP) + 'px';
	
	
	
	function shapeCells(item, anchorR, anchorC){
		const shape = SHAPES[item.key] || [];
		return shape.map(([dr,dc]) => [anchorR + dr, anchorC + dc]);
	}
	function inBounds(r,c){
		return r>=0 && r<GRID_ROWS && c>=0 && c<GRID_COLS;
	}
	function occupiedMap(ignoreId=null) {
		const occ = new Set();
		for (const it of shopState.items) {
			if (it.r==null || it.c==null) continue;
			if (ignoreId && it.id===ignoreId) continue;
			for (const [r,c] of shapeCells(it, it.r, it.c)) { occ.add(r+','+c); }
		}
		return occ;
	}
	function inBoundsShape(item, r, c) {
		for (const [rr, cc] of shapeCells(item, r, c)) {
			if (!inBounds(rr, cc)) return false;
		}
		return true;
	}
	function canPlace(item, r, c) {
		const occ = occupiedMap(item.id);
		for (const [rr,cc] of shapeCells(item, r, c)) {
			if (!inBounds(rr,cc) || occ.has(rr+','+cc)) return false;
		}
		return true;
	}
	function displaceConflicts(item, placeR, placeC) {
		const newCells = new Set(
			shapeCells(item, placeR, placeC).map(([rr, cc]) => rr + ',' + cc)
		);
		for (const other of shopState.items) {
			if (other === item) continue;
			if (other.r == null || other.c == null) continue;

			let overlaps = false;
			for (const [rr, cc] of shapeCells(other, other.r, other.c)) {
				if (newCells.has(rr + ',' + cc)) {
					overlaps = true;
					break;
				}
			}
			if (overlaps) {
				// kick this gun to offer
				other.r = null;
				other.c = null;
			}
		}
	}
	function getShapeBounds(key) {
		const shape = SHAPES[key] || [];
		let maxDR = 0;
		let maxDC = 0;
		for (const [dr, dc] of shape) {
			if (dr > maxDR) maxDR = dr;
			if (dc > maxDC) maxDC = dc;
		}
		return {
			cellCols: maxDC + 1, // horizontal span in cells
			cellRows: maxDR + 1  // vertical span in cells
		};
	}
	function renderPlaced() {
		shopGridEl.querySelectorAll('.gun-placed').forEach(n => n.remove());
		
		for (const it of shopState.items) {
			if (it.r == null || it.c == null) continue;
			
			const { cellCols, cellRows } = getShapeBounds(it.key);
			const shapeWidthPx  = (cellCols - 1) * cellStep + CELL;
			const shapeHeightPx = (cellRows - 1) * cellStep + CELL;
			
			const anchorX = it.c * cellStep;
			const anchorY = it.r * cellStep;
			const shapeCoords = SHAPES[it.key];
			let maxDR = 0;
			let maxDC = 0;
			for (const [dr, dc] of shapeCoords) {
				if (dr > maxDR) maxDR = dr;
				if (dc > maxDC) maxDC = dc;
			}
			const wrapW = maxDC * cellStep + CELL;
			const wrapH = maxDR * cellStep + CELL;
			
			const wrap = document.createElement('div');
			wrap.className= 'gun-placed';
			wrap.dataset.id = it.id;
			wrap.style.position = 'absolute';
			wrap.style.left = anchorX + 'px';
			wrap.style.top = anchorY + 'px';
			wrap.style.width = wrapW + 'px';
			wrap.style.height = wrapH + 'px';
			wrap.style.pointerEvents = 'auto'; // so we can drag it
			
			for (const [dr,dc] of SHAPES[it.key]){
				const cell = document.createElement('div');
				cell.className = 'p-cell';
				cell.dataset.dr = dr;
				cell.dataset.dc = dc;
				cell.style.position = 'absolute';
				cell.style.left = (dc * cellStep) + 'px';
				cell.style.top = (dr * cellStep) + 'px';
				cell.style.width = CELL + 'px';
				cell.style.height = CELL + 'px';
				cell.style.backgroundImage = "url('src/img/UI_shop_slot_background_tier_" + it.tier + ".png')";
				cell.style.backgroundSize = '100% 100%';
				cell.style.backgroundRepeat = 'no-repeat';
				cell.style.backgroundPosition = 'center';
				cell.style.borderRadius = '0';
				cell.style.boxShadow = 'none';
				wrap.appendChild(cell);
			}
			
			//gun image
			const sprite = document.createElement('img');
			sprite.className = 'gun-sprite';
			sprite.src = 'src/img/gun_shop_' + it.key + '.png';
			sprite.style.width  = shapeWidthPx  + 'px';
			sprite.style.height = shapeHeightPx + 'px';
			sprite.style.objectFit = 'contain';
			wrap.appendChild(sprite);
			
			appendOutlineBorderFull(wrap, SHAPES[it.key]);
			wrap.addEventListener('pointerdown', e => {
				if(document.getElementById('shopGrid').classList.contains('viewMode')) return; //disables moving in viewmode
				onDragStart(e, it, 'grid', wrap);
			});
			shopGridEl.appendChild(wrap);
		}
		applyMergeHighlights();
	}
	function renderOffer() {
		const shopOfferEl  = document.getElementById('shopOffer');
		if (!shopOfferEl) return;
		shopOfferEl.innerHTML = '';

		for (const it of shopState.items) {
			// skip items that are placed on the grid already
			if (it.r != null && it.c != null) continue;
			
			// gun offer preview
			const chip = document.createElement('div');
			chip.className = 'gun-chip';
			chip.dataset.id = it.id;
			
			//gun image size calculate
			const MINI_STEP = MINI_CELL;
			const { cellCols, cellRows } = getShapeBounds(it.key);
			const miniWidthPx  = (cellCols - 1) * MINI_CELL + MINI_CELL;
			const miniHeightPx = (cellRows - 1) * MINI_CELL + MINI_CELL;
			
			for (const [dr,dc] of SHAPES[it.key]) {
				const d = document.createElement('div');
				d.className = 'mini-cell';
				d.style.position = 'absolute';
				d.dataset.dr = dr;
				d.dataset.dc = dc;
				d.style.left = (15 + dc*MINI_CELL) + 'px';
				d.style.top  = (20 + dr*MINI_CELL) + 'px';
				d.style.width = MINI_CELL + 'px';
				d.style.height = MINI_CELL + 'px';
				d.style.backgroundImage = "url('src/img/UI_shop_slot_background_tier_" + it.tier + ".png')";
				d.style.backgroundSize = '100% 100%';
				d.style.backgroundRepeat = 'no-repeat';
				d.style.backgroundPosition = 'center';
				d.style.borderRadius = '0';
				d.style.boxShadow = 'none';
				chip.appendChild(d);
			}
			
			//gun image
			const spriteMini = document.createElement('img');
			spriteMini.className = 'gun-sprite-mini';
			spriteMini.src = 'src/img/gun_shop_' + it.key + '.png';
			spriteMini.style.position = 'absolute';
			spriteMini.style.left   = '15px';
			spriteMini.style.top    = '20px';
			spriteMini.style.width  = miniWidthPx  + 'px';
			spriteMini.style.height = miniHeightPx + 'px';
			spriteMini.style.objectFit = 'contain';
			spriteMini.style.pointerEvents = 'none';
			chip.appendChild(spriteMini);
			
			appendOutlineBorderMini(chip, SHAPES[it.key]);
			chip.addEventListener('pointerdown', e => onDragStart(e, it, 'offer', chip));
			shopOfferEl.appendChild(chip);
		}
		applyMergeHighlights();
	}
	function resolveDropOnGrid(item, newR, newC) {
		const overlaps = overlappingItemsAt(item, newR, newC);
		let mergeTarget = null;
		for (const o of overlaps) {
			if (canMergeItems(item, o)) {
				mergeTarget = o;
				break;
			}
		}
		if (mergeTarget) {
			mergeIntoTarget(mergeTarget, item);
			return;
		}
		for (const o of overlaps) {
			o.r = null;
			o.c = null;
		}
		item.r = newR;
		item.c = newC;
	}
	function resolveDropInOffer(e, item) {
		const elUnder = document.elementFromPoint(e.clientX, e.clientY);
		const chipEl = elUnder ? elUnder.closest('.gun-chip') : null;

		if (chipEl) {
			const targetId = chipEl.dataset.id;
			const targetItem = shopState.items.find(it => String(it.id) === String(targetId));
			if (targetItem) {
				const isSameObject = (targetItem === item);
				const canMerge = !isSameObject && canMergeItems(item, targetItem);
				if (canMerge) {
					const cameFromGridAndWasLast = (dragFrom === 'grid' && countPlaced() <= 1);
					if (!cameFromGridAndWasLast) {
						mergeIntoTarget(targetItem, item);
						return;
					}
				}
				if (dragFrom === 'grid' && countPlaced() <= 1) {
					item.r = startPos.r;
					item.c = startPos.c;
				}
				else {
					item.r = null;
					item.c = null;
				}
				return;
			}
		}
		if (dragFrom === 'grid' && countPlaced() <= 1) {
			item.r = startPos.r;
			item.c = startPos.c;
		}
		else {
			item.r = null;
			item.c = null;
		}
	}
	function buildOutlineSegments(coords, {
		cellStepX,
		cellStepY,
		cellSize,
		borderPx,
		offX,
		offY,
	}) {
		const occ = new Set(coords.map(([r,c]) => r + "," + c));
		const topEdges = new Map();
		const bottomEdges = new Map();
		const leftEdges = new Map();
		const rightEdges = new Map();

		for (const [dr, dc] of coords) {
			if (!occ.has((dr - 1) + "," + dc)) {
				if (!topEdges.has(dr)) topEdges.set(dr, []);
				topEdges.get(dr).push(dc);
			}
			if (!occ.has((dr + 1) + "," + dc)) {
				if (!bottomEdges.has(dr)) bottomEdges.set(dr, []);
				bottomEdges.get(dr).push(dc);
			}
			if (!occ.has(dr + "," + (dc - 1))) {
				if (!leftEdges.has(dc)) leftEdges.set(dc, []);
				leftEdges.get(dc).push(dr);
			}
			if (!occ.has(dr + "," + (dc + 1))) {
				if (!rightEdges.has(dc)) rightEdges.set(dc, []);
				rightEdges.get(dc).push(dr);
			}
		}

		function makeRuns(sortedList) {
			const runs = [];
			if (!sortedList.length) return runs;
			let start = sortedList[0];
			let prev  = sortedList[0];
			for (let i = 1; i < sortedList.length; i++) {
				const v = sortedList[i];
				if (v === prev + 1) {
					prev = v;
				}
				else {
					runs.push([start, prev]);
					start = v;
					prev = v;
				}
			}
			runs.push([start, prev]);
			return runs;
		}

		const segs = [];
		for (const [row, dcs] of topEdges.entries()) {
			const sorted = dcs.slice().sort((a,b)=>a-b);
			const runs = makeRuns(sorted);
			for (const [dcStart, dcEnd] of runs) {
				const leftPx  = offX + dcStart * cellStepX;
				const rightPx = offX + dcEnd * cellStepX + cellSize;
				const cellTopY = offY + row * cellStepY;
				const yPx = cellTopY - borderPx;
				segs.push({
					x: leftPx,
					y: yPx,
					w: rightPx - leftPx,
					h: borderPx,
				});
			}
		}
		for (const [row, dcs] of bottomEdges.entries()) {
			const sorted = dcs.slice().sort((a,b)=>a-b);
			const runs = makeRuns(sorted);
			for (const [dcStart, dcEnd] of runs) {
				const leftPx  = offX + dcStart * cellStepX;
				const rightPx = offX + dcEnd * cellStepX + cellSize;
				const cellBottomY = offY + row * cellStepY + cellSize;
				const yPx = cellBottomY;
				segs.push({
					x: leftPx,
					y: yPx,
					w: rightPx - leftPx,
					h: borderPx,
				});
			}
		}
		for (const [col, drs] of leftEdges.entries()) {
		const sorted = drs.slice().sort((a,b)=>a-b);
			const runs = makeRuns(sorted);
			for (const [drStart, drEnd] of runs) {
				const topPx    = offY + drStart * cellStepY;
				const bottomPx = offY + drEnd   * cellStepY + cellSize;
				const cellLeftX = offX + col * cellStepX;
				const xPx = cellLeftX - borderPx;
				segs.push({
					x: xPx,
					y: topPx,
					w: borderPx,
					h: bottomPx - topPx,
				});
			}
		}
		for (const [col, drs] of rightEdges.entries()) {
			const sorted = drs.slice().sort((a,b)=>a-b);
			const runs = makeRuns(sorted);
			for (const [drStart, drEnd] of runs) {
				const topPx    = offY + drStart * cellStepY;
				const bottomPx = offY + drEnd   * cellStepY + cellSize;
				const cellRightX = offX + col * cellStepX + cellSize;
				const xPx = cellRightX;
				segs.push({
					x: xPx,
					y: topPx,
					w: borderPx,
					h: bottomPx - topPx,
				});
			}
		}
		
		let minR = Infinity, maxR = -Infinity, minC = Infinity, maxC = -Infinity;
		for (const [dr, dc] of coords) {
			if (dr < minR) minR = dr;
			if (dr > maxR) maxR = dr;
			if (dc < minC) minC = dc;
			if (dc > maxC) maxC = dc;
		}

		for (let r = minR - 1; r <= maxR + 1; r++) {
			for (let c = minC - 1; c <= maxC + 1; c++) {
				const hereKey = r + "," + c;
				if (occ.has(hereKey)) continue;

				const up    = occ.has((r-1) + "," + c);
				const down  = occ.has((r+1) + "," + c);
				const left  = occ.has(r + "," + (c-1));
				const right = occ.has(r + "," + (c+1));

				// Up + Left occupied -> outside patch goes UP-LEFT from that corner
				if (up && left && !down && !right) {
					const cornerX = offX + c * cellStepX - borderPx;
					const cornerY = offY + r * cellStepY - borderPx;
					segs.push({
						x: cornerX,
						y: cornerY,
						w: borderPx,
						h: borderPx,
					});
				}
				// Up + Right occupied -> patch goes UP-RIGHT
				if (up && right && !down && !left) {
					const cornerX = offX + c * cellStepX + cellSize;
					const cornerY = offY + r * cellStepY - borderPx;
					segs.push({
						x: cornerX,
						y: cornerY,
						w: borderPx,
						h: borderPx,
					});
				}
				// Down + Left occupied -> patch goes DOWN-LEFT
				if (down && left && !up && !right) {
					const cornerX = offX + c * cellStepX - borderPx;
					const cornerY = offY + r * cellStepY + cellSize;
					segs.push({
						x: cornerX,
						y: cornerY,
						w: borderPx,
						h: borderPx,
					});
				}
				// Down + Right occupied -> patch goes DOWN-RIGHT
				if (down && right && !up && !left) {
					const cornerX = offX + c * cellStepX + cellSize;
					const cornerY = offY + r * cellStepY + cellSize;
					segs.push({
						x: cornerX,
						y: cornerY,
						w: borderPx,
						h: borderPx,
					});
				}
			}
		}
		return segs;
	}
	function appendOutlineBorderFull(container, shapeCoords) {
		const segs = buildOutlineSegments(shapeCoords, {
			cellStepX: CELL + CELL_GAP,
			cellStepY: CELL + CELL_GAP,
			cellSize: CELL,
			borderPx: 2,
			offX: 0,
			offY: 0,
		});

		for (const seg of segs) {
			const edgeDiv = document.createElement('div');
			edgeDiv.style.position = 'absolute';
			edgeDiv.style.left = seg.x + 'px';
			edgeDiv.style.top = seg.y + 'px';
			edgeDiv.style.width = seg.w + 'px';
			edgeDiv.style.height = seg.h + 'px';
			edgeDiv.style.background = '#E7E2DE';
			edgeDiv.style.pointerEvents = 'none';
			edgeDiv.style.zIndex = '10002';
			container.appendChild(edgeDiv);
		}
	}
	function appendOutlineBorderMini(container, shapeCoords) {
		const MINI_OFFSET_X = 15;
		const MINI_OFFSET_Y = 20;

		const segs = buildOutlineSegments(shapeCoords, {
			cellStepX: MINI_CELL,
			cellStepY: MINI_CELL,
			cellSize: MINI_CELL,
			borderPx: 1,
			offX: MINI_OFFSET_X,
			offY: MINI_OFFSET_Y,
		});

		for (const seg of segs) {
			const edgeDiv = document.createElement('div');
			edgeDiv.style.position = 'absolute';
			edgeDiv.style.left = seg.x + 'px';
			edgeDiv.style.top = seg.y + 'px';
			edgeDiv.style.width = seg.w + 'px';
			edgeDiv.style.height = seg.h + 'px';
			edgeDiv.style.background = '#DBD7D4';
			edgeDiv.style.pointerEvents = 'none';
			edgeDiv.style.zIndex = '10002';
			container.appendChild(edgeDiv);
		}
	}
	
	// -------------------- Drag and Drop ----------------------------- //
	function getShapeExtents(item) {
		const shape = SHAPES[item.key] || [];
		let maxDR = 0;
		let maxDC = 0;
		for (const [dr, dc] of shape) {
			if (dr > maxDR) maxDR = dr;
			if (dc > maxDC) maxDC = dc;
		}
		return { maxDR, maxDC };
	}
	function clampPlacementToGrid(item, baseR, baseC) {
		const { maxDR, maxDC } = getShapeExtents(item);

		const maxRowStart = GRID_ROWS - 1 - maxDR;
		const maxColStart = GRID_COLS - 1 - maxDC;

		let r = baseR;
		let c = baseC;

		if (r < 0) r = 0;
		if (c < 0) c = 0;
		if (r > maxRowStart) r = maxRowStart;
		if (c > maxColStart) c = maxColStart;
		
		return { r, c };
	}
	function getPreviewTopLeftPixels(r, c) {
		const gridRect = shopGridEl.getBoundingClientRect();
		return {
			left: gridRect.left + c * cellStep,
			top: gridRect.top  + r * cellStep
		};
	}
	function positionGhostAtPreview(r, c) {
		if (!ghost) return;
		const { left, top } = getPreviewTopLeftPixels(r, c);
		const OFFSET = 2; // tiny nudge so preview peeks out

		ghostTargetX = left + OFFSET;
		ghostTargetY = top  + OFFSET;
	}
	function positionGhostCenteredOnPointer(pointerX, pointerY) {
		if (!ghost) return;
		ghostTargetX = pointerX - grabOffsetX;
		ghostTargetY = pointerY - grabOffsetY;
	}
	function isInside(el, x, y) {
		const r = el.getBoundingClientRect();
		return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
	}
	function countPlaced(){
		return shopState.items.filter(it => it.r!=null && it.c!=null).length;
	}
	function startGhostAnim() {
		// avoid multiple loops if already running
		if (ghostAnimId != null) return;

		function step() {
			const SMOOTH = 0.25; // smaller = slower, larger = snappier
			ghostCurrX += (ghostTargetX - ghostCurrX) * SMOOTH;
			ghostCurrY += (ghostTargetY - ghostCurrY) * SMOOTH;

			if (ghost) {
				ghost.style.left = ghostCurrX + 'px';
				ghost.style.top  = ghostCurrY + 'px';
			}
			ghostAnimId = requestAnimationFrame(step);
		}
		ghostAnimId = requestAnimationFrame(step);
	}
	function stopGhostAnim() {
		if (ghostAnimId != null) {
			cancelAnimationFrame(ghostAnimId);
			ghostAnimId = null;
		}
	}
	function onDragStart(e, item, from, sourceEl) {
		if (draggingItem) return;
		e.preventDefault();

		activePointerId  = e.pointerId ?? null;
		draggingItem     = item;
		dragFrom         = from;
		draggingSourceEl = sourceEl || null;
		startPos         = { r: item.r, c: item.c };
		
		mergeHighlightSet.clear();
		for (const other of shopState.items) {
			if (other === item) continue;
			if (canMergeItems(item, other)) {
				mergeHighlightSet.add(other.id);
			}
		}
		
		applyMergeHighlights();
		ghost = createGhostFromItem(item);
		ghost.style.transform = 'none';

		if (draggingSourceEl) {
			draggingSourceEl.classList.add('drag-hidden');
		}
		
		const gRect = ghost.getBoundingClientRect();
		grabOffsetX = gRect.width  / 2;
		grabOffsetY = gRect.height / 2;
		
		if (e.target.setPointerCapture && activePointerId != null) {
			try { e.target.setPointerCapture(activePointerId); } catch (_) {}
		}
		
		window.addEventListener('pointermove', onDragMove, { passive: false });
		window.addEventListener('pointerup',   onDragEnd,  { passive: false, once: true });
		
		if (item.r != null && item.c != null) {
			lastSnap = { r: item.r, c: item.c, ok: true };
			showPlacementPreview(item.r, item.c, item, true);
			positionGhostAtPreview(item.r, item.c); // sets ghostTargetX/Y
		}
		else {
			lastSnap = null;
			hidePlacementPreview();
			positionGhostCenteredOnPointer(e.clientX, e.clientY); // sets ghostTargetX/Y
		}

		ghostCurrX = ghostTargetX;
		ghostCurrY = ghostTargetY;
		startGhostAnim();
	}
	function onDragMove(e) {
		if (activePointerId != null && e.pointerId !== activePointerId) return;
		e.preventDefault();
		if (!draggingItem) return;

		const overGrid = isInside(shopGridEl, e.clientX, e.clientY);

		if (!overGrid) {
			lastSnap = null;
			hidePlacementPreview();
			positionGhostCenteredOnPointer(e.clientX, e.clientY);
			return;
		}
		
		const snap = snapToGrid(e.clientX, e.clientY);
		const { r: clampedR, c: clampedC } = clampPlacementToGrid(draggingItem, snap.r, snap.c);
		lastSnap = { r: clampedR, c: clampedC, ok: true };
		showPlacementPreview(clampedR, clampedC, draggingItem, true);
		
		positionGhostAtPreview(clampedR, clampedC);
	}
	function isInside(el, x, y){
		const r=el.getBoundingClientRect();
		return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
	}
	function snapToGrid(clientX, clientY) {
		const r = shopGridEl.getBoundingClientRect();
		const gx = clientX - r.left;
		const gy = clientY - r.top;
		const c  = Math.floor(gx / cellStep);
		const rr = Math.floor(gy / cellStep);
		return { r: rr, c };
	}
	function onDragEnd(e) {
		if (activePointerId != null && e.pointerId !== activePointerId) return;
		e.preventDefault();
		
		window.removeEventListener('pointermove', onDragMove);
		
		// release pointer capture
		if (e.target.releasePointerCapture && activePointerId != null) {
			try { e.target.releasePointerCapture(activePointerId); } catch (_) {}
		}
		
		activePointerId = null;
		stopGhostAnim();
		
		if (draggingSourceEl) {
			draggingSourceEl.classList.remove('drag-hidden');
		}
		
		if (ghost) {
			ghost.remove();
			ghost = null;
		}
		
		hidePlacementPreview();
		
		const item = draggingItem;
		draggingItem = null;
		shopState.dragging = null;
		
		clearMergeHighlights();

		if (lastSnap && lastSnap.ok) {
			const newR = lastSnap.r;
			const newC = lastSnap.c;
			resolveDropOnGrid(item, newR, newC);
		}
		else {
			resolveDropInOffer(e, item);
		}
		
		lastSnap = null;
		renderPlaced();
		renderOffer();
	}
	function applyTierColor(it) {
		const grad = TIER_COLORS[Math.min(it.tier,4)] || TIER_COLORS[1];
		it.color = grad;
	}
	function getShapeCellsAt(item, baseR, baseC) {
		const shape = SHAPES[item.key] || [];
		const out = [];
		for (const [dr, dc] of shape) {
			out.push([baseR + dr, baseC + dc]);
		}
		return out;
	}
	function getCurrentCells(item) {
		if (item.r == null || item.c == null) return [];
		return getShapeCellsAt(item, item.r, item.c);
	}
	function overlappingItemsAt(item, placeR, placeC) {
		const hits = new Set();
		const newCells = getShapeCellsAt(item, placeR, placeC)
		.map(([rr,cc]) => rr + ',' + cc);
		
		for (const other of shopState.items) {
			if (other === item) continue;
			if (other.r == null || other.c == null) continue; // only placed
			const ocells = getCurrentCells(other);
			for (const [orow, ocol] of ocells) {
				if (newCells.includes(orow + ',' + ocol)) {
					hits.add(other);
					break;
				}
			}
		}
		return [...hits];
	}
	// -------------- Merge -------------- //
	function canMergeItems(a, b) {
		if (!a || !b) return false;
		if (a.key !== b.key) return false;
		if (a.tier !== b.tier) return false;
		if (a.tier >= 4) return false;
		return true;
	}
	function mergeIntoTarget(target, source) {
		target.tier = Math.min(4, target.tier + 1);
		applyTierColor(target);
		
		shopState.items = shopState.items.filter(it => it !== source);
	}
	// -------------- Glow Animation -------------- //
	function applyMergeHighlights() {
		document.querySelectorAll('.merge-glow').forEach(el => {el.classList.remove('merge-glow');});
		
		for (const id of mergeHighlightSet) {
			const placed = shopGridEl.querySelector(`.gun-placed[data-id="${id}"]`);
			if (placed) placed.classList.add('merge-glow');
			const chip = shopOfferEl.querySelector(`.gun-chip[data-id="${id}"]`);
			if (chip) chip.classList.add('merge-glow');
		}
	}
	function clearMergeHighlights() {
		document.querySelectorAll('.merge-glow').forEach(el => {el.classList.remove('merge-glow');});
		mergeHighlightSet.clear();
	}
	function createGhostFromItem(item) {
		const g = document.createElement('div');
		g.className = 'drag-ghost';
		g.style.zIndex = '10001';
		g.style.pointerEvents = 'none';
		g.style.touchAction = 'none';
		g.style.position = 'fixed';
		
		//gun image size calculate
		const MINI_STEP = MINI_CELL;
		const { cellCols, cellRows } = getShapeBounds(item.key);
		const shapeWidthPx  = (cellCols - 1) * cellStep + CELL;
		const shapeHeightPx = (cellRows - 1) * cellStep + CELL;
		
		for (const [dr, dc] of SHAPES[item.key]) {
			const cell = document.createElement('div');
			cell.className = 'p-cell';
			cell.style.position = 'absolute';
			cell.dataset.dr = dr;
			cell.dataset.dc = dc;
			cell.style.left = (dc * MINI_CELL) + 'px';
			cell.style.top  = (dr * MINI_CELL) + 'px';
			cell.style.width  = MINI_CELL + 'px';
			cell.style.height = MINI_CELL + 'px';
			g.appendChild(cell);
		}
		
		//gun image
		const spriteMini = document.createElement('img');
		spriteMini.className = 'gun-sprite-mini';
		spriteMini.src = 'src/img/gun_shop_' + item.key + '.png';
		spriteMini.style.position = 'absolute';
		spriteMini.style.width  = shapeWidthPx  + 'px';
		spriteMini.style.height = shapeHeightPx + 'px';
		spriteMini.style.objectFit = 'contain';
		spriteMini.style.pointerEvents = 'none';
		g.appendChild(spriteMini);
		
		document.body.appendChild(g);
		return g;
	}
	function ensurePreviewWrap() {
		if (!previewWrap) {
			previewWrap = document.createElement('div');
			previewWrap.className = 'placement-preview';
			shopGridEl.appendChild(previewWrap);
		}
	}
	function showPlacementPreview(r, c, item, valid) {
		ensurePreviewWrap();
		previewWrap.innerHTML = '';

		for (const [dr, dc] of SHAPES[item.key]) {
			const cell = document.createElement('div');
			cell.className = 'placement-preview-cell' + (valid ? '' : ' invalid');
			
			const baseLeft = c * (CELL + CELL_GAP);
			const baseTop  = r * (CELL + CELL_GAP);
			cell.style.left = (baseLeft + dc * (CELL + CELL_GAP)) + 'px';
			cell.style.top  = (baseTop  + dr * (CELL + CELL_GAP)) + 'px';
			cell.style.width  = CELL + 'px';
			cell.style.height = CELL + 'px';
			cell.style.position = 'absolute';
			cell.style.backgroundImage = "url('src/img/UI_shop_slot_background_preview.png')";
			cell.style.backgroundRepeat = 'no-repeat';
			cell.style.backgroundSize = '100% 100%';
			cell.style.backgroundPosition = 'center';
			cell.style.opacity = (valid ? '1' : '0.8');
			previewWrap.appendChild(cell);
		}
		previewWrap.style.display = 'block';
	}
	function hidePlacementPreview() {
		if (previewWrap) {
			previewWrap.style.display = 'none';
		}
	}
	
	// --------------------- Shop Offer --------------------- //
	function pickTierForShop() {
		const bag = [];
		for (const tierStr in SHOP_TIER_CHANCE) {
			const tierNum = parseInt(tierStr, 10);
			const w = SHOP_TIER_CHANCE[tierNum] || 0;
			if (w > 0) {
				bag.push({ tier: tierNum, weight: w });
			}
		}
		
		let total = 0;
		for (const entry of bag) {
			total += entry.weight;
		}
		if (total <= 0) return 1;

		// Roll
		let roll = Math.random() * total;
		for (const entry of bag) {
			if (roll < entry.weight) return entry.tier;
			roll -= entry.weight;
		}
		return 1;
	}
	
	
	// -------------------------- Open / Close Shop -------------------------- //
	function shop_offer_rerollItem(state, isButton = false){
		if (isButton) {
			const hasFree = shop_currRerollFree > 0;
			const canPay  = state.coins >= shop_rerollPrice;
			
			if (!hasFree && !canPay) {
				shop_offer_updateRerollUI(state);
				return;
			}
			if (hasFree){
				shop_currRerollFree -= 1;
			}
			else {
				state.coins -= shop_rerollPrice;
				shop_rerollPrice += shop_rerollIncrement;
			}
		}
		shop_offer_addNewOffers(state);
		renderOffer();
		shop_offer_updateRerollUI(state);
	}
	function shop_offer_updateRerollUI(state){
		const fmt = n => Number(n).toLocaleString('en-US');

		if (shop_currRerollFree > 0){
			btnRerollOffer.textContent = `Free ${shop_currRerollFree} / ${shop_rerollFreeNum}`;
			btnRerollOffer.classList.remove('disabled');
		}
		else {
			btnRerollOffer.textContent = `${fmt(state.coins)} / ${fmt(shop_rerollPrice)}`;
			const disabled = state.coins < shop_rerollPrice;
			btnRerollOffer.classList.toggle('disabled', disabled);
		}
	}
	function shop_offer_addNewOffers(state){
		shopState.items = shopState.items.filter(it => it.r != null && it.c != null);
		for (let i = 0; i < numShopItem; i++) {
			shopState.items.push(shop_offer_makeOfferItem());
		}
	}
	function shop_offer_makeOfferItem() {
		const gunKeys = Object.keys(window.GUNS);
		const key = gunKeys[(Math.random()*gunKeys.length)|0];
		const tier = pickTierForShop();
		const colorPair = TIER_COLORS[tier] || TIER_COLORS[1];

		return {
			id: 'itm_' + Math.random().toString(36).slice(2,8),
			key,
			tier,
			color: colorPair,
			r: null,
			c: null,
		};
	}
	
	
	// -------------------------- Open / Close Shop -------------------------- //
	function openShopOverlay(nextWave, nextCount, initial=false, view=false) {
		const state = window.__gameState;
		const currentWave = window.__gameState.wave;
		if (!state) {
			// Queue until game state exists
			window.__pendingShopCalls = window.__pendingShopCalls || [];
			window.__pendingShopCalls.push([nextWave, nextCount, initial]);
			if (!window.__shopWaiter2) {
				window.__shopWaiter2 = true;
				const wait = () => {
					if (window.__gameState && typeof window.openShopOverlay === 'function') {
						const q = window.__pendingShopCalls.splice(0);
						for (const a of q) window.openShopOverlay.apply(null, a);
					}
					else {
						requestAnimationFrame(wait);
					}
				};
				requestAnimationFrame(wait);
			}
			return;
		}
		
		shopState.pending = { n: nextWave, count: nextCount };
		state.paused = true;
		try { fadeAudio(bgm, 0, 200); } catch(_){}
		
		if (initial) {
			shopState.items = [];
			const starter = {
				id: 'itm_starter',
				key: 'submachinegun',
				tier: 1,
				color: TIER_COLORS[1],
				r: 0,
				c: 0
			};
			shopState.items.push(starter);
		}
		
		renderPlaced();
		shopOverlay.classList.remove('hidden');
		
		//View Mode / Shop Mode
		if(!view) shop_offer_rerollItem(state,false);
		document.getElementById('shopTitle').innerHTML = 'Shop';
		document.getElementById('shopGrid').classList.toggle('viewMode',view); //If "Viewing Inventory" or "Shopping"
		document.getElementById('shopLayoutOffer').classList.toggle('viewMode',view);
		document.getElementById('shopStartBtn').classList.toggle('viewMode',view);
		document.getElementById('btnShop_weaponRemoval').classList.toggle('viewMode',view);
		document.getElementById('btnShop_rerollOffer').classList.toggle('viewMode',view);
		document.getElementById('btnShop_close_view').classList.toggle('viewMode',!view);
	}
	function closeShopOverlayAndStart() {
		const state = window.__gameState;
		if (!state) return;

		// Collect guns that are placed on shop grid
		const placed = shopState.items.filter(it => it.r != null && it.c != null);
		if (placed.length < 1) {return;}

		// Convert placed guns into in game
		state.weapons = placed.map(it => {return makeWeaponInstance(it.key, it.tier);});
		state.inventory = new Array(16).fill(null);
		for (let i = 0; i < placed.length && i < 16; i++) {
			state.inventory[i] = {
				name: placed[i].key,
				tier: placed[i].tier
			};
		}
		renderInventory();

		const shopOverlayEl = document.getElementById('shopOverlay');
		if (shopOverlayEl) {shopOverlayEl.classList.add('hidden');}

		const nextWaveNum   = (shopState.pending && shopState.pending.n) || (state.wave + 1);
		const nextWaveCount = (shopState.pending && shopState.pending.count) || 1;
		startWave(nextWaveNum, nextWaveCount);

		//close shop
		const traitsStillPending =(state.traitOverlayOpen === true) || ((state.traitQueue || 0) > 0);
		if (traitsStillPending) {
			state.paused = true;
		}
		else {
			state.paused = false;
			window.fadeAudio(bgm, 0.35, 200);
		}
	}
	function closeViewInventory() {
		document.getElementById('shopOverlay').classList.add('hidden');
	}
	
	
	//Buttons
	shopStartBtn?.addEventListener('click', closeShopOverlayAndStart);
	document.getElementById('btnShop_close_view')?.addEventListener('click', closeViewInventory);
	document.getElementById('btn_viewTraits')?.addEventListener('click', window.openTraitViewer);
	document.getElementById('btn_viewInventory')?.addEventListener('click', ()=>{ openShopOverlay(0,0,false,true); });
	btnRerollOffer?.addEventListener('click', ()=>{ shop_offer_rerollItem(window.__gameState,true); });
	
	
	
	if (Array.isArray(window.__pendingShopCalls)) {
		const q = window.__pendingShopCalls.splice(0);
		for (const a of q) openShopOverlay.apply(null, a);
	}
	
	//Open Shop on start / restart
	let openedOnce = false;
	requestAnimationFrame(()=>{
		if (!openedOnce && window.__gameState && window.__gameState.wave>=1 && ((window.__gameState.weapons||[]).length||0)===1) {
			openedOnce=true;
		}
	});
	
	
	//Bridge
	try {
		window.openShopOverlay = openShopOverlay;
	} catch(_) {}
})();

</script>
</body>
</html>