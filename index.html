<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Rogue-like Gun Mini-Game — v8.4.9</title>

<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Rajdhani:wght@500;600;700&display=swap" rel="stylesheet">
<style>
	* { box-sizing: border-box; }
	html {
		height:100%;
		width:100%;
		overflow:hidden;
		overscroll-behavior:none;
	}
	body {
		height:100%;
		width:100%;
		margin:0;
		padding:0;
		display:flex;
		align-items:center;
		justify-content:center;
		touch-action: manipulation;
		background-image: url('src/img/UI/UI_overlay_background_black.png');
		background-repeat: repeat;
	}
	.hidden { display: none !important; }
	
	:root { --frame-w: 600px; --frame-h: 1080px; --canvas-h: 750px; }
	.fit-wrap {
		transform-origin:center center;
		width:var(--frame-w);
		height:var(--frame-h);
	}
	.game-frame {
		display:inline-block;
		width: var(--frame-w);
		height: var(--frame-h);
		padding: 0;
		overflow: hidden;
		
		/* --- prevents dragging --- */
		user-select: none;
		-webkit-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-webkit-user-drag: none;
		-webkit-touch-callout: none;
		-webkit-tap-highlight-color: transparent;
		
		/* --- default font --- */
		font-size: 20px;
		font-family: 'Rajdhani', sans-serif;
		font-weight: 600;
		font-variant-numeric: lining-nums tabular-nums;
		letter-spacing: .05em;
		color: #F9F6F1;
	}
	.game-shell {
		width:var(--frame-w); max-width:100%;
	}
	.game-overlay { display:none; }
	.game-overlay {
		position: fixed;
		inset: 0;
		z-index: 10000;
		display: grid;
		place-items: center;
		background: rgba(0,0,0,.7);
	}
	
	/* ============================ Repeat use buttons ============================ */
	.default-div-btn,
	.unique-div-btn {
		width: auto;
		height: auto;
		cursor: pointer;
		text-align: center;
		background-size: 100% 100%;
		background-position: center;
	}
	.default-div-btn:active,
	.unique-div-btn:active {
		filter: brightness(0.7);
		transform: translateY(3px);
	}
	
	/* -------- button types -------- */
	.btn-long-default {
		aspect-ratio: 290 / 72;
		height: 55px;
		padding-top: 12px;
		background-image: url('src/img/UI/button/ui_btn_long_default.png');
	}
	.btn-normal-default {
		aspect-ratio: 300 / 90;
		height: 65px;
		padding-top: 17px;
		background-image: url('src/img/UI/button/ui_btn_normal_default.png');
	}
	.btn-normal-blue {
		aspect-ratio: 300 / 90;
		height: 65px;
		padding-top: 17px;
		background-image: url('src/img/UI/button/ui_btn_normal_blue.png');
	}
	.btn-normal-blue.disabled {
		cursor: not-allowed;
		background-image: url('src/img/UI/button/ui_btn_normal_disabled.png');
		color: #C6C6C6;
	}
	.btn-normal-red {
		aspect-ratio: 300 / 90;
		height: 65px;
		padding-top: 17px;
		background-image: url('src/img/UI/button/ui_btn_normal_red.png');
	}
	.btn_alert_red {
		aspect-ratio: 300 / 65;
		height: 70px;
		padding-top: 17px;
		background-image: url('src/img/UI/button/ui_btn_alert_red.png');
		
		font-family: "Segoe UI", Arial, sans-serif;
		font-size: 22px;
		font-weight: 700;
	}
	.btn-square-default {
		aspect-ratio: 83 / 90;
		height: 55px;
		padding-top: 10px;
		background-image: url('src/img/UI/button/ui_btn_square_default.png');
	}
	
	.btn_view_dps {
		aspect-ratio: 10 / 9;
		height: 55px;
		background-image: url('src/img/UI/button/UI_overlay_btn_view_dps.png');
	}
	
	/* ============================ Overlay Backgrounds  ============================ */
	.overlay-background-grey {
		border-radius: 8px;
		background-image: url('src/img/UI/UI_overlay_background_grey.png');
		background-size: 100% 100%;
		background-position: center;
		overflow: hidden;
	}
	.overlay-background-black {
		border: 18px solid transparent;
		box-sizing: border-box;
		border-image-source: url("src/img/UI/UI_overlay_background_darkgrey.png");
		border-image-slice: 18 fill;
		border-image-repeat: stretch;
		overflow: hidden;
	}
	.overlay-background-stripe {
		border: 8px solid #1A1C19;
		border-radius: 14px;
		box-sizing: border-box;
		background-image: url('src/img/UI/UI_overlay_background_stripe.png');
		background-repeat: repeat;
		background-position: 0 0;
		overflow: hidden;
	}

	/* ============================ TOP HUD ============================ */
	.hud {
		position: relative;
		height: 168px;
		width: 100%;
		background-image: url('src/img/UI_battlefield_topHUD.png');
		background-size: 100% 100%;
		background-repeat: no-repeat;
		background-position: center;
		margin: 0 0 -60px 0;
		z-index: 3;
	}
	.hud .num { position:absolute; color:#fff; font-weight:900; text-shadow: 0 1px 2px rgba(0,0,0,.6); -webkit-user-select:none; user-select:none; }
	.hud .num.big { font-size: 28px; line-height: 1; }
	.hud .num.sm  { font-size: 18px; font-weight:800; }
	.hud .right { text-align:right; }
	
	
	/* ------------- Scoreboard ------------- */
	:root {
		--wave-left: 42px; --wave-top: 76px; --wave-w: 80px; --wave-h: 55px; --wave-txt-size: 50px;
		--level-left: 191px; --level-top: 28px; --level-w: 40px; --level-h: 33px; --level-txt-size: 24px;
		--exp-left: 268px; --exp-top: 34px; --exp-w: 188px; --exp-h: 14.5px;
		--coin-left: 185px; --coin-top: 71px; --coin-w: 100px; --coin-txt-size: 17px;
		--score-left: 340px; --score-top: 71px; --score-w: 100px; --score-txt-size: 17px;
	}
	#waveNum {
		left: var(--wave-left);
		top: var(--wave-top);
		width: var(--wave-w);
		height: var(--wave-h);
		text-align:center;
		font-family: 'Bebas Neue', sans-serif;
		font-size: var(--wave-txt-size);
		font-weight: 700;
		letter-spacing: .08em;
		color: #F9FAF5;
		text-shadow: 0 1px 0 #000, 0 -1px 0 #000, 1px 0 0 #000, -1px 0 0 #000;
	}
	#levelNum {
		left: var(--level-left);
		top: var(--level-top);
		width: var(--level-w);
		height: var(--level-h);
		font-size: var(--level-txt-size);
		font-family: 'Rajdhani', sans-serif;
		font-weight: 600;
		font-variant-numeric: lining-nums tabular-nums;
		letter-spacing: .12em;
		-webkit-text-stroke: 1px #282824;
		text-shadow: 0 1px 0 #000, 0 -1px 0 #000, 1px 0 0 #000, -1px 0 0 #000;
		text-align:left;
	}
	.exp-track {
		position:absolute;
		overflow:hidden;
		left: var(--exp-left);
		top: var(--exp-top);
		width: var(--exp-w);
		height: var(--exp-h);
	}
	.exp-frame {
		position:absolute;
		left:0; top:0;
		height:100%; width:100%;
		background-image: url('src/img/UI_battlefield_topHUD_expframe.png');
		background-size: cover;
		background-position:center;
		z-index:2;
	}
	.exp-fill {
		position:absolute;
		left:0; top:0;
		height:100%; width:0%;
		background: linear-gradient(
			to bottom,
			#ffe886 0%,
			#f8c24e 35%,
			#ee9430 70%,
			#d9781c 100%
		);
		transition: width .2s ease;
		border-radius: 4px;
		z-index:1;
	}
	#coinNum {
		left: var(--coin-left);
		top: var(--coin-top);
		width: var(--coin-w);
		text-align: right;
		font-size: var(--coin-txt-size);
		font-family: 'Rajdhani', sans-serif;
		font-weight: 600;
		font-variant-numeric: lining-nums tabular-nums;
		letter-spacing: .12em;
		color: #FACD2B;
	}
	#scoreNum {
		left: var(--score-left);
		top: var(--score-top);
		width: var(--score-w);
		text-align: right;
		font-size: var(--score-txt-size);
		font-family: 'Rajdhani', sans-serif;
		font-weight: 600;
		font-variant-numeric: lining-nums tabular-nums;
		letter-spacing: .12em;
		color: #F7F4EF;
	}
	
	#speedBtn {
		position:absolute;
		left: 474px;
		top: 32px;
		font-size: 25px;
		font-weight: 500;
	}
	#pauseBtn {
		position:absolute;
		left: 534px;
		top: 33px;
		height: 52px;
		aspect-ratio: 1 / 1;
	}


	/* ========================== Middle Section ========================== */
	.stage-wrap {
		display:flex;
		align-items:center;
		justify-content:center;
		padding:0;
		margin:0;
	}
	.stage {
		width: var(--frame-w);
		height: var(--canvas-h);
		position: relative;
		background-image: url('src/img/background_battlefield_1000x1250.png');
		background-size: cover; background-position:center;
		border:none; border-radius:0; box-shadow:none;
	}
	.soldier-sprite{
		position: absolute;
		left: 50%;
		transform: translateX(-50%);
		bottom: 0;
		width: 118px;
		height: 128px;
		pointer-events: none;
	}
	canvas {
		display:block; width:100%; height:100%;
	}
	
	
	/* ============================ HP Bar ============================ */
	.hp-container {
		position: relative;
		height: 46px;
		width: 100%;
		padding: 10px 14px;
		background-color: #242621;
	}
	.hp-frame {
		position: absolute;
		left:0; top:0;
		height:100%; width:100%;
		background-image: url('src/img/UI_battlefield_hp-container_frame.png');
		background-size: cover;
		background-position:center;
		z-index:2;
	}
	.hp-bar {
		position:relative;
		width:100%; height:100%;
		background:transparent;
		overflow:hidden;
		border:none;
		z-index:1;
	}
	.hp-bar .fill {
		position:absolute;
		left:0; top:0;
		height:100%; width:100%;
		background: linear-gradient(
			to bottom,
			#FE6D70 15%,
			#EC2627 40%,
			#C50830 65%,
			#CA1035 100%
		);
		transition: width .2s ease;
		border-radius: inherit;
	}
	.hp-bar .text {
		position:absolute;
		inset:0;
		display:flex;
		align-items:center;
		justify-content:center;
		pointer-events:none;
		color:white;
		font-size: 21px;
		font-family: 'Rajdhani', sans-serif;
		font-weight: 800;
		font-variant-numeric: lining-nums tabular-nums;
		letter-spacing: .12em;
		-webkit-text-stroke: 0.6px #661E1A;
		text-shadow: 0 1px 0 #000, 0 -1px 0 #000, 1px 0 0 #000, -1px 0 0 #000;
	}
	
	
	/* ============================ Pause Overlay ============================ */
	.pause-panel-body {
		width: 100%;
		aspect-ratio: 560 / 709;
	}
	.pause-panel-main {
		display: grid;
		width: 100%;
		height: 100%;
		grid-template-rows: 46px 415px 44px 123px 1fr;
		overflow: hidden;
	}
	.pause-panel-row1,
	.pause-panel-row3 {
		display: grid;
		align-items: center;
		text-align: center;
		font-weight: 800;
	}
	.pause-panel-row2 {
		margin: 0px 2px;
	}
	.pause-panel-row4 {
		margin: 0px 15px;
	}
	
	/* --- trait icon grid --- */
	.pause-traits-grid::-webkit-scrollbar { display: none; }
	.pause-traits-grid {
		display: grid;
		grid-template-columns: repeat(5, minmax(0, 1fr));
		column-gap: 5px;
		row-gap: 5px;
		justify-items: center;
		align-items: start;
		align-content: flex-start;
		height: 100%;
		width: 100%;
		overflow-y: auto;
		scrollbar-width: none;
		-ms-overflow-style: none;
	}
	.pause-trait-slot {
		width: 100%;
		aspect-ratio: 1 / 1;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	
	
	/* ============================ Game Over Overlay ============================ */
	.gameover-panel-body {
		width: 100%;
		aspect-ratio: 560 / 727;
		display: grid;
		grid-template-rows: auto auto auto auto 1fr;
		background-image: url('src/img/UI/UI_overlay_background_gameover.png');
		background-size: 100% 100%;
		background-position: center;
	}
	.gameover-panel-row1 {
		height: 89px;
		width: 100%;
	}
	.gameover-panel-row2 {
		height: 242px;
		width: 100%;
		padding: 10px 20px 10px 35px;
		display: flex;
		flex-direction: column;
		gap: 4px;
	}
	.gameover-panel-row3 {
		height: 160px;
		width: 100%;
		padding: 55px 20px 20px;
	}
	.gameover-panel-row4 {
		height: 155px;
		width: 100%;
		padding: 34px 35px 0px;
	}
	
	.gameover-scoreboard-row {
		height: 40px;
		display: flex;
		justify-content: space-between;
		align-items: center;
		font-size: 25px;
		letter-spacing: .03em;
	}
	.gameover-scoreboard-title {
		width: auto;
		height: 100%;
		padding-right: 10px;
		display: flex;
		align-items: center;
		background-color: #54534F;
	}
	.gameover-scoreboard-score {
		width: auto;
		height: 100%;
		padding-left: 10px;
		display: flex;
		align-items: center;
		background-color: #54534F;
	}
	
	.gameover-total-point {
		height: 100%;
		width: 100%;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 50px;
		font-weight: 700;
		letter-spacing: 0.16em;
		color: #ffffff;
		line-height: 1;
	}
	
	
	
	/* ============================ Trait Overlay ============================ */
	:root {
		--trait-layout-top-h: 659px;
		--trait-card-icon-size: 133px;
	}
	
	.trait-panel-body {
		height: auto;
		width: 100%;
		padding-top: 10px;
		box-sizing: border-box;
		display: flex;
		flex-direction: column;
	}
	.trait-card-list {
		width: 100%;
		padding: 8px 0px 5px;
		background-image: url('src/img/UI/UI_overlay_background_select_trait.png');
		background-repeat: no-repeat;
		background-position: top center;
		background-size: 100% auto;
	}
	.trait-panel-body .overlay-panel-body-action { height: 90px; }
	
	
	/* ------- trait cards ------- */
	.trait-card-list.trait-vertical {
		display: flex;
		gap: 8px;
		flex-direction: column;
		height: 100%;
	}
	.trait-card {
		display: grid;
		grid-template-columns: 46px var(--trait-card-icon-size) 1fr;
		align-items: center;
		cursor: pointer;
	}
	.trait-radio {
		display: grid;
		height: 100%;
		padding: 0px 4px;
		place-items: center;
	}
	.trait-radio-img {
		width: 100%;
		aspect-ratio: 1 / 1;
		background-image: url('src/img/UI_trait_card_radio_unselect.png');
		background-size: 100% 100%;
		background-position: center;
	}
	.trait-card.selected .trait-radio-img { background-image: url('src/img/UI_trait_card_radio_selected.png'); }
	
	.trait-card[data-tier="1"].selected .trait-icon { border: 3px solid #2A94DB; }
	.trait-card[data-tier="2"].selected .trait-icon { border: 3px solid #A250D6; }
	.trait-card[data-tier="3"].selected .trait-icon { border: 3px solid #D79944; }
	
	.trait-icon {
		height: 100%;
		aspect-ratio: 1 / 1;
		display: grid;
		place-items: center;
		
		border: 3px solid #5B605A;
		border-radius: 13px;
		background-size: 100% 100%;
		background-position: center;
		pointer-event: none;
	}
	.trait-icon[data-tier="1"] { background-image: url('src/img/UI/UI_overlay_select_trait_icon_background_tier_1.png'); }
	.trait-icon[data-tier="2"] { background-image: url('src/img/UI/UI_overlay_select_trait_icon_background_tier_2.png'); }
	.trait-icon[data-tier="3"] { background-image: url('src/img/UI/UI_overlay_select_trait_icon_background_tier_3.png'); }
	
	.trait-icon-frame {
		width: 60%;
		aspect-ratio: 1 / 1;
		display: grid;
		place-items: center;
		box-shadow: 3px 3px 0 #1E292B;
		background-size: 100% 100%;
		background-position: center;
		pointer-event: none;
	}
	.trait-icon[data-tier="1"] .trait-icon-frame { background-image: url('src/img/UI/UI_overlay_select_trait_icon_frame_tier_1.png'); }
	.trait-icon[data-tier="2"] .trait-icon-frame { background-image: url('src/img/UI/UI_overlay_select_trait_icon_frame_tier_2.png'); }
	.trait-icon[data-tier="3"] .trait-icon-frame { background-image: url('src/img/UI/UI_overlay_select_trait_icon_frame_tier_3.png'); }
	
	.trait-icon-img {
		width: 90%;
		aspect-ratio: 1 / 1;
		background-size: 100% auto;
		background-position: center;
		pointer-event: none;
	}
	
	.trait-text {
		height: 100%;
		display: flex;
		padding: 0px 15px 0px 20px;
		flex-direction: column;
		justify-content: center;
	}
	.trait-title {
		font: 800 19px/1.0 "Rajdhani", system-ui, sans-serif;
		letter-spacing: .01em;
		color: #e5efff;
		position: relative;
		padding-bottom: 8px;
	}
	.trait-title::after {
		content: "";
		position: absolute;
		left: 0; right: 0; bottom: 0;
		height: 2px;
		background: #45B4BF;
	}
	.trait-desc {
		font: 600 15px/1.35 "Rajdhani", system-ui, sans-serif;
		letter-spacing: .01em;
		color: #b7c3d6;
		padding-top: 4px;
	}
	.trait-desc .accent {
		color: #63b3ff;
		font-weight: 800;
	}
	
	/* ======================== View Trait Overlay ======================== */
	.view-trait-panel-body {
		width: 100%;
		aspect-ratio: 560 / 630;
		padding: 10px 10px 15px;
		box-sizing: border-box;
	}
	.trait-list::-webkit-scrollbar { display: none; }
	.trait-list {
		display: flex;
		height: 100%;
		gap: 12px;
		flex-direction: column;
		overflow-y: auto;
		-ms-overflow-style: none;
		scrollbar-width: none;
	}
	.trait-pill {
		display: inline-block;
		height: auto;
		padding:5px 10px;
		justify-content:space-between;
		align-items:center;
		
		border-style: solid;
		border-width: 12px;
		border-image-source: url('src/img/UI_trait_overlay_view_traitpill_background.png');
		border-image-slice: 12 fill;
		border-image-repeat: repeat;
		
		font: 600 17px/1.0 "Rajdhani", system-ui, sans-serif;
		letter-spacing: .01em;
		text-align:center;
	}
	.trait-pill span { color:#4799BC; }
	
	
	/* ============================ Overlays ============================ */
	.overlay-panel {
		display: grid;
		width: 560px;
		height: auto;
		grid-template-rows: auto auto 1fr;
		overflow: hidden;
	}
	.overlay-panel > * { min-width: 0; }
	.overlay-panel-header-long,
	.overlay-panel-header-short {
		position: relative;
		display: flex;
		justify-content: center;
		align-items: center;
		overflow: hidden;
		height: 74px;
		background-size: cover;
		background-position: center;
	}
	.overlay-panel-header-long {background-image: url('src/img/UI/UI_overlay_title_long.png');}
	.overlay-panel-header-short {background-image: url('src/img/UI/UI_overlay_title_short.png');}
	
	.overlay-title {
		height: 100%;
		aspect-ratio: 16 / 3;
		padding-top: 10px;
		font-weight: 800;
		font-size: 38px;
		line-height: 1.1;
		letter-spacing: .08em;
		text-align: center;
		text-shadow: 0 1px 0 #3E3E3C;
	}
	.btn-overlay-close {
		position: absolute;
		top: 0;
		right: 0;
		margin-right: 10px;
		transform: none;
		height: 74px;
		aspect-ratio: 118 / 145;
		background-image: url('src/img/UI/UI_overlay_title_btn_close.png');
		background-size: cover;
		background-position: center;
	}
	.overlay-panel-body-action {
		display: flex;
		justify-content: center;
		align-items: center;
		gap: 9px;
		padding-bottom: 8px;
		flex: 0 0 auto;
	}
	.overlay-actions {
		display:flex;
		margin-top: 8px;
		gap:10px;
		justify-content:center;
		align-items: center;
		overflow: hidden;
	}
	
	
	/* ============================ DPS / Stats Overlay ============================ */
	.dps-panel-body {
		width: 100%;
		aspect-ratio: 1 / 1;
		background-image: url('src/img/UI/UI_overlay_background_view_dps.png');
		background-size: cover;
		background-position: center;
	}
	.dps-list {
		display: flex;
		flex-direction: column;
		gap: 11px;
		margin: 28px 13px 30px 16px;
		overflow-y: auto;
	}
	.dps-card {
		display: flex;
		align-items: center;
	}
	.dps-card-icon {
		display: flex;
		justify-content: center;
		align-items: center;
		aspect-ratio: 1/1;
		height: 88px;
	}
	.dps-card-icon img {
		width: 100%;
		height: 100%;
		object-fit: contain;
		object-position: center;
		display: block;
		pointer-events: none;
	}
	.dps-card-detail {
		flex: 1;
		display: flex;
		flex-direction: column;
		gap: 5px;
		padding-left: 8px;
	}
	.dps-card-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
	}
	.dps-name {
		position: relative;
		font-size: 22px;
		font-weight: 600;
		padding-left: 10px;
	}
	.dps-name::before {
		content: "";
		position: absolute;
		left: 0;
		top: 50%;
		transform: translateY(-50%);
		width: 5px;
		height: 80%;
		background-color: #363531;
	}
	.dps-damage {
		position: relative;
		display: inline-block;
		font-size: 20px;
		font-weight: 500;
		letter-spacing: 0.04em;
		color: #FEFEFE;
		text-shadow:
			-1px 0 #171614,
			1px 0 #171614,
			0 -1px #171614,
			0 1px #171614,
			-1px -1px #171614,
			1px -1px #171614,
			-1px 1px #171614,
			1px 1px #171614;
		padding-left: 22px;
	}
	.dps-damage::before {
		content: "";
		position: absolute;
		left: 0;
		top: 50%;
		transform: translateY(-50%);
		width: 16px;
		height: 16px;
		background-image: url("src/img/UI/UI_overlay_background_icon_dps_bullet.png");
		background-size: contain;
		background-repeat: no-repeat;
		background-position: center;
	}
	.dps-bar {
		position: relative;
		width: 100%;
		height: 22px;
		border-radius: 5px;
		border: 2px solid #161511;
		background: #2D2C2A;
		overflow: hidden;
	}
	.dps-bar-fill {
		position: absolute;
		left: 0;
		top: 0;
		height: 100%;
		width: 0%;
		background: linear-gradient(
			to bottom,
			#FE6D70 15%,
			#EC2627 40%,
			#C50830 65%,
			#CA1035 100%
		);
	}
	
	
	/* ============ Weapon Removal Overlay ============ */
	.removal-panel-header {
		height: 200px;
		width: 100%;
	}
	.removal-panel-body {
		width: 100%;
		display: grid;
		grid-template-rows: auto auto;
		row-gap: 3px;
	}
	.removal-panel-row1 {
		height: 250px;
		width: 100%;
		display: grid;
		grid-template-rows: 50px 1fr;
	}
	.removal-panel-row2 {
		height: 360px;
		width: 100%;
		display: grid;
		grid-template-rows: 260px 1fr;
		row-gap: 8px;
	}
	
	.removal-panel-row1-header {
		display: grid;
		align-items: center;
		text-align: center;
		font-weight: 800;
	}
	.weapon-removal-removed-area {
		border-radius: 6px;
		margin: 0px 12px 15px;
		display: flex;
		flex-direction: column;
		row-gap: 4px;
	}
	
	
	.weapon-removal-offer-area {
		border-radius: 6px;
		margin: 17px 12px 0px;
		display: flex;
		justify-content: center;
		overflow: hidden;
		touch-action: none;
	}
	.gun-chip.weapon-removal-selected::after {
		content: "";
		position: absolute;
		height: 100%; width: 100%;
		border: 2px solid #3AF769;
		pointer-events: none;
	}
	
	.weapon-removal-removed-list {
		display: flex;
		justify-content: center;
		align-items: center;
		gap: 8px;
		flex-wrap: nowrap;
		height: 100%;
		width: 100%;
		overflow: hidden;
	}
	.weapon-removal-removed-item {
		position: relative;
		width: 105px;
		height: 105px;
		transform-origin: center center;
	}

	.weapon-removal-removed-item .mini-cell {
		position: absolute;
	}
	.weapon-removal-removed-item .gun-sprite-mini {
		position: absolute;
	}

	

	/* ============================ Inventory ============================ */
	.inventory-wrap{
		position: relative;
		height: 160px;
		width: 100%;
		background-image: url('src/img/background_grey.png');
		background-size: cover;
		background-position: center;
	}
	.inventory-frame {
		position: absolute;
		left:0; top:0;
		inset: 0;
		height:100%; width:100%;
		background-image: url('src/img/UI_battlefield_inventory_frame.png');
		background-size: cover;
		background-position:center;
		z-index:1;
	}
	.inventory-grid {
		position: absolute;
		top: 4px;
		left: 20px;
		display: grid;
		grid-template-columns: repeat(8, 67px);
		grid-auto-rows: 67px;
		column-gap: 3.4px;
		row-gap: 3.5px;
		z-index: 2;
	}
	.slot{
		position: relative;
		width: 100%;
		height: 100%;
		box-sizing: border-box;
		padding: 0;
		display: block;
		overflow: hidden;
	}
	.slot-layer{
		position: absolute;
		inset: 0;
		width: 100%;
		height: 100%;
		display: block;
		pointer-events: none;
		-webkit-user-drag: none;
		-webkit-touch-callout: none;
		-webkit-tap-highlight-color: transparent;
		border: 2.5px solid #252620;
		border-radius: 5px;
	}
	.slot-bg {
		object-fit: fill;
		z-index: 1;
	}
	.slot-gun {
		object-fit: contain;
		object-position: center;
		z-index: 2;
	}
	.slot-cd {
		position:absolute;
		inset:0;
		pointer-events:none;
		opacity:0;
		--cd: 0;
		background: 
			conic-gradient(
				from 0deg,
				transparent 0deg,
				transparent calc(var(--cd) * 360deg),
				rgba(0,0,0,.55) calc(var(--cd) * 360deg),
				rgba(0,0,0,.55) 360deg
		);
		z-index: 3;
	}

	/* ============================ Boss warning banner ============================ */
	.warn-banner {
		position: absolute;
		top: 8px; left: 50%; transform: translateX(-50%);
		padding: 6px 12px;
		background: rgba(220,38,38,0.6); color:#fff;
		border: 1px solid rgba(220,38,38,0.85);
		border-radius: 10px; font-weight: 900; letter-spacing: 1px;
		text-transform: uppercase; pointer-events: none; backdrop-filter: blur(2px);
		z-index: 3; opacity: 0; text-shadow: 0 1px 2px rgba(0,0,0,0.45);
	}
	.warn-banner.show { opacity:1; }
	@keyframes warnPulse { 0% {opacity:0;} 30% {opacity:1;} 70% {opacity:1;} 100% {opacity:0;} }


	/* ============================ Shop Overlay ============================ */
	:root {
		--shop-panel-w: 560px;
		--shop-layout-top-h: 620px;
		--shop-layout-bot-h: 330px;
		/* shop-layout-bot-h */ --shop-layout-bot-offer-h: 230px;
		/* shop-layout-bot-h */ --shop-layout-bot-btn: 100px;
		--shop-start-button-w: 413;
		--shop-start-button-h: 90;
		--shop-start-button-w-ratio: 55%;
		--shop-gun-offer-count: 3;
		--shop-gun-offer-scale: 1;
	}

	.shop-panel-body {
		width: 100%;
		display: grid;
		aspect-ratio: 560 / 876;
		grid-template-rows: auto auto 1fr;
		padding-top: 15px;
		box-sizing: border-box;
	}
	.shop-panel-body.viewMode {
		aspect-ratio: 560 / 649;
		grid-template-rows: auto 1fr;
	}
	
	.shop-panel-row1 {
		height: 534px;
		width: 100%;
		padding-top: 30px;
		position: relative;
		display: grid;
		place-items: center;
	}
	.shop-panel-row2.viewMode { display: none; }
	.shop-panel-row2 {
		height: 225px;
		width: 95%;
		margin: 8px 10px 0px;
		display: flex;
		justify-content: center;
		overflow: hidden;
		touch-action: none;
	}
	.shop-panel-body .overlay-panel-body-action {
		padding-bottom: 8px;
	}
	
	.shop-row1-title {
		position: absolute;
		top: 0;
		left: 50%;
		transform: translateX(-50%);
		height: 15px;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		font-size: 18px;
		font-weight: 600;
		pointer-events: none;
	}
	.shop-row1-title::before {
		content: "Inventory Expansion Points: ";
		margin-right: 4px;
	}
	.shop-grid {
		position: relative;
		touch-action: none;
	}
	.shop-offer {
		display: grid;
		position: relative;
		height: auto;
		width: 100%;
		column-gap: 10px;
		row-gap: 10px;
		padding: 20px;
		grid-template-columns: repeat(var(--shop-gun-offer-count), 1fr);
		align-items: start;
		align-content: flex-start;
		transform: scale(var(--shop-gun-offer-scale, 1));
		transform-origin: top left;
	}
	
	
	/* ------- Shop Gun ------- */
	.gun-chip {
		position: relative;
		user-select: none;
		cursor: grab;
	}
	.gun-chip:active {
		cursor: grabbing;
	}
	.gun-placed {
		position: absolute;
		width: calc(48px * 4);
		height: calc(48px * 2);
		pointer-events: auto;
		cursor: grab;
	}
	.gun-sprite,
	.gun-sprite-mini {
		position: absolute;
		left: 0;
		top: 0;
		pointer-events: none;
		image-rendering: pixelated;
		image-rendering: crisp-edges;
	}
	.drag-ghost {
		position: fixed;
		z-index: 10001;
		pointer-events: none;
		touch-action: none;
		opacity: .9;
	}
	.drag-hidden {
		opacity: 0;
		visibility: hidden;
	}
	.placement-preview {
		position: absolute;
		left: 0;
		top: 0;
		pointer-events: none;
		z-index: 5000; /* under ghost (10001) but above grid cells */
	}
	@keyframes mergeShinePulse {
		0% {
			filter: brightness(1) saturate(1);
			box-shadow:
				0 0 4px rgba(255,255,200,0.4),
				0 0 8px rgba(255,255,150,0.25);
		}
		50% {
			filter: brightness(1.9) saturate(1.4);
			box-shadow:
				0 0 6px rgba(255,255,255,0.9),
				0 0 14px rgba(255,255,160,0.6),
				0 0 22px rgba(255,255,120,0.35);
		}
		100% {
			filter: brightness(1) saturate(1);
			box-shadow:
				0 0 4px rgba(255,255,200,0.4),
				0 0 8px rgba(255,255,150,0.25);
		}
	}
	.merge-glow .p-cell,
	.merge-glow .mini-cell {
		animation: mergeShinePulse 1.7s ease-in-out infinite;
	}
	
	/* ------- Action Buttons ------- */
	.btn-shop-weapon-removal, 
	#btn_shop_reroll {
		width: 263px;
		aspect-ratio: 530 / 141;
		display: inline-flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		user-select: none;
		text-align: center;
	}
	.btn-shop-weapon-removal {
		background-image: url('src/img/UI_shop_offer_removal_button.png');
		padding: 6px 12px;
	}
	#btn_shop_reroll {
		background-image: url('src/img/UI_shop_offer_button_reroll_enabled.png');
		/* padding: 12px 0px; */
	}
	.btn-shop-weapon-removal .btn-title,
	#btn_shop_reroll .btn-title	{
		font-family: "Segoe UI", Arial, sans-serif;
		font-size: 19px;
		font-weight: 600;
		line-height: 1.1;
		letter-spacing: 0.04em;
		color: #FFFBF5;
	}
	.btn-shop-weapon-removal .btn-subtitle,
	#btn_shop_reroll .btn-subtitle {
		display: inline-flex;
		margin-top: 5px;
		font-family: "Segoe UI", Arial, sans-serif;
		font-size: 14px;
		font-weight: 500;
		letter-spacing: 0.02em;
		color: #C4BEB2;
	}
	.btn-shop-weapon-removal .btn-subtitle .subtitle-value,
	#btn_shop_reroll .btn-subtitle .subtitle-value { margin-left: 4px; }
	
	#btn_shop_reroll.disabled { background-image: url('src/img/UI_shop_offer_button_reroll_disabled.png'); }
	#btn_shop_reroll.disabled #subtitle_btn_shop_reroll { color: #F31307; }
	
	/* ------- Reroll Coin Icon ------- */
	#btn_shop_reroll .subtitle-label.is-coin {
		height: 18px;
		aspect-ratio: 1 / 1;
		font-size: 0;
		background-repeat: no-repeat;
		background-position: center;
		background-size: contain;
		background-image: url("src/img/icon_coin.png");
	}
	#btn_shop_reroll.disabled .subtitle-label.is-coin {
		background-image: url("src/img/icon_coin_disabled.png");
	}
	
	/* ------- View Inventory ------- */
	.btn-shop-weapon-removal.viewMode, 
	#btn_shop_reroll.viewMode,
	#btn_shop_close.viewMode,
	#btnShop_close_view.viewMode { display: none; }
</style>

<!-- ---- Imports ---- -->
<script src="src/js/error-log.js"></script>

</head>
<body>
<div id="fitWrap" class="fit-wrap">
<div class="game-frame">
<div class="game-shell">

	<!-- =============== Top HUD =============== -->
	<div class="hud" id="topHUD">
		<div id="waveNum"  class="num big">1</div>
			<div id="levelNum" class="num">1</div>
			<div class="exp-track">
				<div class="exp-fill" id="expFill"></div>
				<div class="exp-frame"></div>
			</div>
		<div id="coinNum"  class="num sm right">0</div>
		<div id="scoreNum" class="num sm right">0</div>
		<div id="speedBtn" class="default-div-btn btn-square-default">1x</div>
		<div id="pauseBtn" class="unique-div-btn"></div>
	</div>

	<!-- =============== Battlefield =============== -->
	<div class="stage-wrap">
	<div class="stage">
		<canvas id="game"></canvas>
		<img id="soldierSprite" src="src/img/character_model_1_angle_3.gif" class="soldier-sprite" alt="soldier">
		<div id="bossWarn" class="warn-banner">BOSS APPROACHING</div>
		
		
		<!-- ----- Pause Overlay ----- -->
		<div id="pauseOverlay" class="game-overlay hidden">
		<div class="overlay-panel">
			<div class="overlay-panel-header-long">
				<div class="overlay-title">Paused</div>
			</div>
			<div class="pause-panel-body overlay-background-grey">
				<div class="pause-panel-main">
					<div class="pause-panel-row1">Option in effect</div>
					<div class="pause-panel-row2 overlay-background-black">
						<div class="pause-traits-grid" id="pauseTraitsGrid"></div>
					</div>
					<div class="pause-panel-row3">Removed Weapons</div>
					<div class="pause-panel-row4 overlay-background-stripe">
						<div id="overlay_pause_removal_list" class="weapon-removal-removed-list"></div>
					</div>
					<div class="overlay-panel-body-action">
						<div class="default-div-btn btn_view_dps"></div>
						<div class="default-div-btn btn-long-default btn_viewInventory">Inventory</div>
						<div class="default-div-btn btn-long-default btn_viewTraits">Traits Obtained</div>
					</div>
				</div>
			</div>
			<div class="overlay-actions">
				<div id="btn_resume" class="default-div-btn btn-normal-default">Continue</div>
				<div id="btn_quickend" class="default-div-btn btn-normal-red">Quick End</div>
			</div>
		</div>
		</div>
		
		
		
		<!-- ----- Game Over Overlay ----- -->
		<div id="gameoverOverlay" class="game-overlay hidden">
		<div class="overlay-panel">
			<div class="gameover-panel-body">
				<div class="gameover-panel-row1"></div>
				<div class="gameover-panel-row2" id="gameover_scoreboard_list"></div>
				<div class="gameover-panel-row3">
					<div class="gameover-total-point" id="gameover_total_point"></div>
				</div>
				<div class="gameover-panel-row4"></div>
				<div class="overlay-panel-body-action">
					<div class="default-div-btn btn_view_dps"></div>
					<div class="default-div-btn btn-normal-blue" id="btn_restart">Restart</div>
				</div>
			</div>
		</div>
		</div>
		
		
			
		<!--  ----- Trait overlay ----- -->
		<div id="traitOverlay" class="game-overlay hidden">
		<div class="overlay-panel">
			<div class="overlay-panel-header-long">
				<div class="overlay-title">Select Trait</div>
			</div>
			<div class="trait-panel-body overlay-background-grey">
				<div id="traitCards" class="trait-card-list"></div>
				
				<div class="overlay-panel-body-action">
					<div class="default-div-btn btn-long-default btn_viewInventory">Inventory</div>
					<div class="default-div-btn btn-long-default btn_viewTraits">Traits Obtained</div>
				</div>
			</div>
			<div class="overlay-actions">
				<div id="traitStartBtn" class="default-div-btn btn-normal-blue disabled">Select</div>
			</div>
		</div>
		</div>
		
		
		
		<!--  ----- View Trait overlay ----- -->
		<div id="traitOverlayViewer" class="game-overlay hidden">
		<div class="overlay-panel">
			<div class="overlay-panel-header-short">
				<div class="overlay-title">Traits</div>
				<div class="default-div-btn btn-overlay-close" id="closeTraitViewerBtn"></div>
			</div>
			<div class="view-trait-panel-body overlay-background-grey">
				<div id="traitList" class="trait-list overlay-background-black"></div>
			</div>
		</div>
		</div>
		
		
		<!--  ----- DPS / Stats overlay ----- -->
		<div id="dpsOverlay" class="game-overlay hidden">
		<div class="overlay-panel">
			<div class="overlay-panel-header-short">
				<div class="overlay-title">Stats</div>
				<div class="default-div-btn btn-overlay-close" id="btnDPS_close_view"></div>
			</div>
			<div class="dps-panel-body">
				<div id="dpsList" class="dps-list"></div>
			</div>
		</div>
		</div>
		
		
		<!-- ----- Shop overlay ----- -->
		<div id="shopOverlay" class="game-overlay hidden">
		<div class="overlay-panel">
			<div class="overlay-panel-header-long">
				<div class="overlay-title">Shop</div>
			</div>
			<div class="shop-panel-body overlay-background-grey">
				<div class="shop-panel-row1 overlay-background-black">
					<div class="shop-row1-title hidden"><div id="shop_expand_count">69</div></div>
					<div class="shop-grid" id="shopGrid"></div>
				</div>
				<div class="shop-panel-row2 overlay-background-stripe" id="shopLayoutOffer">
					<div id="shopOffer" class="shop-offer"></div>
				</div>
				<div class="overlay-panel-body-action">
					<div class="default-div-btn btn-shop-weapon-removal" id="btnShop_weaponRemoval">
						<div class="btn-title">Weapon Removal</div>
						<div class="btn-subtitle">
							<div class="subtitle-label">Remaining attempt(s):</div>
							<div class="subtitle-value btn_subtitle_removal">5</div>
						</div>
					</div>
					<div class="unique-div-btn" id="btn_shop_reroll">
						<div class="btn-title">Refresh</div>
						<div class="btn-subtitle">
							<div class="subtitle-label">Remaining attempt(s):</div>
							<div class="subtitle-value" id="subtitle_btn_shop_reroll">10</div>
						</div>
					</div>
					<div class="default-div-btn btn-normal-default" id="btnShop_close_view">Return</div>
				</div>
			</div>
			<div class="overlay-actions" id="shopActionRow2">
				<div class="unique-div-btn btn_alert_red" id="btn_shop_close">Start Battle</div>
			</div>
		</div>
		</div>
		
		
		
		<!--  ----- Weapon Removal overlay ----- -->
		<div id="weaponRemovalOverlay" class="game-overlay hidden">
		<div class="overlay-panel">
			
			<div class="removal-panel-header">
				<!-- gap -->
			</div>
			
			<div class="removal-panel-body">
				<div class="removal-panel-row1 overlay-background-grey">
					<div class="removal-panel-row1-header">Remove Weapon Type</div>
					<div class="weapon-removal-removed-area overlay-background-stripe">
						<div id="weaponRemovalRemovedList" class="weapon-removal-removed-list"></div>
					</div>
				</div>
				
				<div class="removal-panel-row2 overlay-background-grey">
					<div class="weapon-removal-offer-area overlay-background-stripe">
						<div id="weaponRemovalOffer" class="shop-offer">
							<!-- Filled by JS -->
						</div>
					</div>

					<div class="overlay-panel-body-action">
						<div class="default-div-btn btn-shop-weapon-removal" id="weaponRemovalConfirmBtn">
							<div class="btn-title">Weapon Removal</div>
							<div class="btn-subtitle">
								<div class="subtitle-label">Remaining attempt(s):</div>
								<div class="subtitle-value btn_subtitle_removal">5</div>
							</div>
						</div>
					</div>
					
				</div>
			</div>
			<div class="overlay-actions">
				<div id="weaponRemovalCancelBtn" class="default-div-btn btn-normal-red">Cancel</div>
			</div>
				
		</div>
		</div>
		

	</div>
	</div>
	
	<!-- =============== Bottom Section =============== -->
	<!-- Barricade HP -->
	<div class="hp-container">
		<div class="hp-bar" id="hpBar">
			<div class="fill" id="hpFill"></div>
			<div class="text" id="hpText">100%</div>
		</div>
		<div class="hp-frame"></div>
	</div>
	
	<!-- Inventory -->
	<div class="inventory-wrap">
		<div class="inventory-frame"></div>
		<div class="inventory-grid" id="inventoryGrid"></div>
	</div>
		
</div>
</div>
</div>

<script>
(function(){
	if (typeof window!=='undefined' && typeof window.openShopOverlay!=='function') {
		window.__pendingShopCalls = [];
		window.openShopOverlay = function(){ window.__pendingShopCalls.push([].slice.call(arguments)); };
	}
})();

(() => {
	// ==================== Config ==================== //
	
	//game frame
	const FRAME_W  = 600, FRAME_H  = 1065;
	const CANVAS_W = FRAME_W, CANVAS_H = 750;
	
	//game canvas
	const W = CANVAS_W, H = CANVAS_H;
	const BARRICADE_Y = H - 155;
	const BARRICADE_HP_MAX = 500;
	
	//Game Speed
	const SPEED_STORAGE_KEY = 'rlg_speed_v1';
	
	//Wave-based
	const CURRENT_WAVE = 10;
	const WAVE_1_COUNT = 8;
	const WAVE_INCREASE = 1.01;
	const GROUPS_PER_WAVE = 5;
	const GROUP_INTERVAL_BASE = 20.0;
	const MOB_INTERVAL_BASE = 0.50;
	const MOB_INTERVAL_MIN  = 0.30;
	const MOB_INTERVAL_DECAY_PER_WAVE = 0.3;
	const CONTACT_DAMAGE_INTERVAL = 3.0;
	const MOB_HP_PER_WAVE = 0.04;
	
	// Banner + spacing config
	const BOSS_WARN_FLASHES = 2;
	const BOSS_WARN_TOTAL_DURATION = 2;
	const BOSS_MINI_TO_BOSS_INTERVAL = 0.2;
	
	//DPS number
	const DMG_NUM_LIFETIME = 2.0;   // seconds total (auto-remove after this)
	const DMG_NUM_VY0      = -3;  // initial upward jump (px/s)
	const DMG_NUM_GRAVITY  = 2.5;   // pulls the number back down (px/s^2)
	const DMG_NUM_POP_TIME = 1.0;  // quick pop scale duration on spawn (s)
	
	//Mobs
	const MOBS = {
		"A": {name:"Mob A", hp: 80, exp: 10, speed: 20, dps: 20, size: 45, coin: 130, score: 140 },
		"B": {name:"Mob B", hp: 80, exp: 10, speed: 20, dps: 20, size: 45, coin: 130, score: 140 }
	};
	const MINI_BOSS_A = { name: "Mini-boss Type A", hp: 1000, exp: 100, speed: 15, dps: 30, size: 70, coin: 500, score: 500, tier: "mini" };
	const BOSS_A = { name: "Boss Type A", hp: 2000, exp: 1000, speed: 10, dps: 50, size: 100, coin: 1000, score: 1000, tier: "boss" };
	
	//Weapons
	const CRIT_RATE = 0.15;
	const CRIT_MULT = 1.5;
	const BULLET_RADIUS_SIZE = 8;
	const BULLET_SPEED = 350;
	const GUN_MULTITARGET_PROBILITY = 0.6; //chance of focusing on nearest, ++ to allow more multi-targetting
	
	const GUN_CONFIG = {
		submachinegun: {
			name: "Submachine Gun",
			type: "normal",
			range: 460,
			shape: [[0,0],[0,1],[0,2],[1,0]],
			tiers: {
				1: { bulletsPerUse: 4, timeBetweenBullets: 0.20, damage: 30, postUseCooldown: 1, ability: "" },
				2: { bulletsPerUse: 4, timeBetweenBullets: 0.18, damage: 40, postUseCooldown: 2, ability: "" },
				3: { bulletsPerUse: 6, timeBetweenBullets: 0.18, damage: 60, postUseCooldown: 2, ability: "submachinegun_T3_GuaranteedCritAfter5" },
				4: { bulletsPerUse: 6, timeBetweenBullets: 0.16, damage: 80, postUseCooldown: 2, ability: "submachinegun_T3_GuaranteedCritAfter5" }
			}
		},
		pistol: {
			name: "Pistol",
			type: "normal",
			range: 400,
			shape: [[0,0],[0,1],[1,0]],
			tiers: {
				1: { bulletsPerUse: 2, timeBetweenBullets: 0.20, damage: 30, postUseCooldown: 3, ability: "" },
				2: { bulletsPerUse: 2, timeBetweenBullets: 0.20, damage: 40, postUseCooldown: 3, ability: "" },
				3: { bulletsPerUse: 2, timeBetweenBullets: 0.20, damage: 60, postUseCooldown: 3, ability: "" },
				4: { bulletsPerUse: 2, timeBetweenBullets: 0.20, damage: 80, postUseCooldown: 3, ability: "" },
			}
		},
		sniperriffle: {
			name: "Sniper Riffle",
			type: "pierce",
			range: 650,
			shape: [[0,0],[1,0],[2,0],[3,0],[3,1]],
			tiers: {
				1: { bulletsPerUse: 1, timeBetweenBullets: 0, damage: 130, postUseCooldown: 3, ability: "" },
				2: { bulletsPerUse: 1, timeBetweenBullets: 0, damage: 140, postUseCooldown: 9, ability: "" },
				3: { bulletsPerUse: 1, timeBetweenBullets: 0, damage: 160, postUseCooldown: 9, ability: "" },
				4: { bulletsPerUse: 1, timeBetweenBullets: 0, damage: 180, postUseCooldown: 9, ability: "" },
			}
		},
		assaultriffle: {
			name: "Assault Riffle",
			type: "normal",
			range: 460,
			shape: [[0,0],[0,1],[1,1],[0,2],[0,3]],
			tiers: {
				1: { bulletsPerUse: 4, timeBetweenBullets: 0.20, damage: 30, postUseCooldown: 1, ability: "" },
				2: { bulletsPerUse: 4, timeBetweenBullets: 0.18, damage: 40, postUseCooldown: 2, ability: "" },
				3: { bulletsPerUse: 6, timeBetweenBullets: 0.18, damage: 60, postUseCooldown: 2, ability: "" },
				4: { bulletsPerUse: 6, timeBetweenBullets: 0.16, damage: 80, postUseCooldown: 2, ability: "" },
			}
		},
		grenadelauncher: {
			name: "Granade Launcher",
			type: "aoe",
			range: 460,
			shape: [[1,0],[1,1],[0,1],[0,2]],
			tiers: {
				1: { bulletsPerUse: 4, timeBetweenBullets: 0.20, damage: 30, postUseCooldown: 1, ability: "" },
				2: { bulletsPerUse: 4, timeBetweenBullets: 0.18, damage: 40, postUseCooldown: 2, ability: "" },
				3: { bulletsPerUse: 6, timeBetweenBullets: 0.18, damage: 60, postUseCooldown: 2, ability: "" },
				4: { bulletsPerUse: 6, timeBetweenBullets: 0.16, damage: 80, postUseCooldown: 2, ability: "" },
			}
		}
	};

	
	//Traits
	const TRAIT_DMG_UP = [5,7,10];
	const TRAIT_RELOAD_DOWN = [3,5,7];
	const TRAIT_POINT_UP = [5,10,15];
	
	const ROMAN = ['I','II','III'];
	const TRAIT_BASE_CARD_COUNT = 3;
	const TRAIT_EXTRA_CARD_CHANCE = 0.40;
	const TRAITS = [
		{
			id: 'dmg_up_normal',
			buff_type: 'dmg_up',
			gun_type: 'normal',
			name: (tier) => 'Normal Attack Damage Increase ' + ROMAN[tier-1],
			desc: (tier) => 'Increases normal attack damage by ',
			scaling: (tier) => TRAIT_DMG_UP[tier-1],
			apply: (tier)=>{
				GAME_STATE.buffs["normal"].dmg_up += TRAIT_DMG_UP[tier-1];
			}
		},
		{
			id: 'dmg_up_aoe',
			buff_type: 'dmg_up',
			gun_type: 'aoe',
			name: (tier) => 'AoE Attack Damage Increase ' + ROMAN[tier-1],
			desc: (tier) => 'Increases AoE attack damage by ',
			scaling: (tier) => TRAIT_DMG_UP[tier-1],
			apply: (tier)=>{
				GAME_STATE.buffs["aoe"].dmg_up += TRAIT_DMG_UP[tier-1];
			}
		},
		{
			id: 'cdr_up_normal',
			buff_type: 'cdr_up',
			gun_type: 'normal',
			name: (tier) => 'Normal Attack Reload Time Decrease ' + ROMAN[tier-1],
			desc: (tier) => 'Decrease Normal Attack Reload Time by ',
			scaling: (tier) => TRAIT_RELOAD_DOWN[tier-1],
			apply: (tier)=>{
				GAME_STATE.buffs["normal"].cdr_up += TRAIT_RELOAD_DOWN[tier-1];
			}
		},
		{
			id: 'cdr_up_aoe',
			buff_type: 'cdr_up',
			gun_type: 'aoe',
			name: (tier) => 'AoE Attack Reload Time Decrease ' + ROMAN[tier-1],
			desc: (tier) => 'Decrease AoE Attack Reload Time by ',
			scaling: (tier) => TRAIT_RELOAD_DOWN[tier-1],
			apply: (tier)=>{
				GAME_STATE.buffs["aoe"].cdr_up += TRAIT_RELOAD_DOWN[tier-1];
			}
		},
		{
			id: 'gold_up',
			buff_type: 'unique',
			gun_type: '',
			name: (tier) => 'Gold Gain Increase ' + ROMAN[tier-1],
			desc: (tier) => 'Increases Goin gained from killing monsters by ',
			scaling: (tier) => TRAIT_POINT_UP[tier-1],
			apply: (tier)=>{
				GAME_STATE.buffs.gold_up += TRAIT_POINT_UP[tier-1];
			}
		},
		{
			id: 'exp_up',
			buff_type: 'unique',
			gun_type: '',
			name: (tier) => 'EXP Gain Increase ' + ROMAN[tier-1],
			desc: (tier) => 'Increases EXP gained from killing monsters by ',
			scaling: (tier) => TRAIT_POINT_UP[tier-1],
			apply: (tier)=>{
				GAME_STATE.buffs.exp_up += TRAIT_POINT_UP[tier-1];
			}
		}
	];
	
	
	// ============= Display ============= //
	//Bind constants to DOM/CSS
	const root = document.documentElement;
	root.style.setProperty('--frame-w',  FRAME_W  + 'px');
	root.style.setProperty('--frame-h',  FRAME_H  + 'px');
	root.style.setProperty('--canvas-h', CANVAS_H + 'px');
	
	const canvas = document.getElementById('game');
	canvas.width = CANVAS_W;
	canvas.height = CANVAS_H;
	
	const fitWrap = document.getElementById('fitWrap');
	function fitToViewport() {
		const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
		const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
		const scaleW = vw / FRAME_W;
		const scaleH = vh / FRAME_H;
		const s = Math.min(scaleW, scaleH, 1);
		fitWrap.style.transform = `scale(${s})`;
	}
	window.addEventListener('resize', fitToViewport);
	window.addEventListener('orientationchange', fitToViewport);
	fitToViewport();
	
	// ===== Soldier Facing Angle GIF ===== //
	const soldierSpriteEl = document.getElementById('soldierSprite');
	const SOLDIER_ANGLES = [
		'src/img/character_model_1_angle_1.gif', // far-left
		'src/img/character_model_1_angle_2.gif', // left
		'src/img/character_model_1_angle_3.gif', // up (default)
		'src/img/character_model_1_angle_4.gif', // right
		'src/img/character_model_1_angle_5.gif'  // far-right
	];
	const _soldierImgs = SOLDIER_ANGLES.map(src => { const i=new Image(); i.src=src; return i; });
	let _soldierIdx = 2;
	if (soldierSpriteEl) soldierSpriteEl.src = SOLDIER_ANGLES[_soldierIdx];
	
	
	// ======================== GAME_STATE ======================== //here
	const INITIAL_GAME_STATE = {
		paused: false, 
		coins: 0, score: 0, kills: 0,
		speedMult: 1, 
		player: { x: W/2, y: H - 40, size: 16, level: 1, exp: 0, expToNext: 50 },
		barricadeHP: BARRICADE_HP_MAX,
		buffs: {}, enemies: [], bullets: [], traitsOwned: [], damageByGun: {},
		inventory: new Array(16).fill(null),
		wave: 1,　toSpawn: 0, 
		groupIndex: 0, groupSizes: [], groupMobIndex: 0, groupIntervalTimer: 0, mobIntervalTimer: 0, mobIntervalWave: 0,
		specialsQueued: { mini: false, boss: false }, specialsSpawned: false,　specialsProgress: 0, specialsTimer: 0,
		shop: { reroll_count: 10, reroll_price: 1000, removal_count: 5, removal_set: new Set() },
		damageByGun: {}, combatTime: 0
	};
	
	function INITIATE_GAME_STATE_BUFFS(state) {
		state.buffs = {
			gold_up: 0,
			exp_up: 0,
		};
		
		const types = new Set(Object.values(GUN_CONFIG).map(gun => gun.type));
		for (const type of types) {
			state.buffs[type] = {
				dmg_up: 0,
				cdr_up: 0,
			};
		}
	}
	
	function makeWeaponInstance(key, tier) {
		const gun_stats = GUN_CONFIG[key];
		
		if (!gun_stats) throw new Error("Unknown weapon/tier: " + key + " T" + tier);

		return {
			key, 
			tier,
			stats: { 
				...gun_stats.tiers[tier],
				range: gun_stats.range,
				type: gun_stats.type,
			},			
			mode: 'idle',
			timer: 0,
			burstLeft: 0,
			shotsSinceAbility: 0
		};
	}
	
	let GAME_STATE = structuredClone(INITIAL_GAME_STATE);
	INITIATE_GAME_STATE_BUFFS(GAME_STATE);
	
	
	// ============== Delare Element ID ============== //
	const ctx = canvas.getContext('2d');
	const pauseOverlay = document.getElementById('pauseOverlay');
	const gameoverOverlay = document.getElementById('gameoverOverlay');
	const traitOverlay = document.getElementById('traitOverlay');
	const dpsOverlay = document.getElementById('dpsOverlay');
	
	const btn_resume = document.getElementById('btn_resume');
	const btn_quickend = document.getElementById('btn_quickend');
	const btn_restart = document.getElementById('btn_restart')
	const pauseBtn = document.getElementById('pauseBtn');
	const speedBtn = document.getElementById('speedBtn');
	const bossWarn = document.getElementById('bossWarn');
	const waveNumEl = document.getElementById('waveNum');
	const levelNumEl = document.getElementById('levelNum');
	const expFill = document.getElementById('expFill');
	const coinNumEl = document.getElementById('coinNum');
	const scoreNumEl = document.getElementById('scoreNum');
	const traitCardsBox = document.getElementById('traitCards');
	const traitOverlayViewer = document.getElementById('traitOverlayViewer');
	const traitListBox = document.getElementById('traitList');
	const closeTraitViewerBtn = document.getElementById('closeTraitViewerBtn');
	const traitStart  = document.getElementById('traitStartBtn');
	const dpsList = document.getElementById('dpsList');
	const btnDPS_close_view = document.getElementById('btnDPS_close_view');
	const overlay_pause_removal_list = document.getElementById('overlay_pause_removal_list');
	
	
  
  function findClosestEnemy(range=Infinity){
    const p = GAME_STATE.player; const r2 = range===Infinity ? Infinity : range*range;
    let best=null, bestD2=Infinity;
    for (const m of GAME_STATE.enemies){
      if (m.dead) continue;
      const dx = p.x - m.cx, dy = p.y - m.cy, d2 = dx*dx + dy*dy;
      if (d2 < bestD2 && d2 <= r2){ bestD2=d2; best=m; }
    }
    return best;
  }
  
	// ================= Sound Effects ================= //
	const bgm = new Audio('src/sfx/bgm_battlefield_loop.mp3');
	bgm.loop = true;
	bgm.preload = 'auto';
	bgm.volume = 0.4;
	
	window.addEventListener('pointerdown', function unlock(){
		bgm.play().catch(()=>{});
		window.removeEventListener('pointerdown', unlock);
	}, { once:true });
	function ensureBgmPlaying(reset=false){
		if (reset) bgm.currentTime = 0;
		if (bgm.paused) bgm.play().catch(()=>{});
	}
	document.addEventListener('pointerdown', function unlock() { //unlock audio once (iOS/Safari)
		const a = new Audio();
		a.play().catch(()=>{}).finally(()=>a.pause());
		document.removeEventListener('pointerdown', unlock);
	}, { once: true });
	
	//play audio (stackable)
	function makeSfx(path, { volume = 0.6, pool = 4 } = {}) {
		const poolArr = Array.from({ length: pool }, () => {
			const a = new Audio(path);
			a.preload = 'auto';
			a.volume = volume;
			return a;
		});
		let i = 0;
		return () => {
			const a = poolArr[i];
			i = (i + 1) % poolArr.length;
			a.currentTime = 0;
			a.play().catch(() => {}); // ignore autoplay guards
		};
	}
	//play audio (non-stackable same audio)
	function makeSfxNoOverlapWithin(path, { volume = 0.6, pool = 4, minGapMs = 1000 } = {}) {
		const poolArr = Array.from({ length: pool }, () => {
			const a = new Audio(path);
			a.preload = 'auto';
			a.volume = volume;
			return a;
		});
		let i = 0;
		let lastPlay = 0;

		const unlockOnce = () => {
			poolArr[0].play().then(() => poolArr[0].pause()).catch(() => {});
			window.removeEventListener('pointerdown', unlockOnce);
		};
		window.addEventListener('pointerdown', unlockOnce, { once: true });

		return function play() {
			const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
			if (now - lastPlay < minGapMs) return;
			lastPlay = now;

			const a = poolArr[i];
			i = (i + 1) % poolArr.length;
			try { a.currentTime = 0; } catch (_) {}
			a.play().catch(() => {});
		};
	}
	//Pause Audio
	function fadeAudio(a, to, ms = 200) {
		const from=a.volume, steps=Math.max(1,Math.floor(ms/16)); let i=0;
		if (to>0 && a.paused) a.play().catch(()=>{});
		const id=setInterval(()=>{ i++; a.volume = from + (to-from)*(i/steps);
		if(i>=steps){ clearInterval(id); if(to===0) a.pause(); }},16);
	}
	
	
	
	// ---------- SFX Config ----------
	const SFX_ERROR = makeSfx('src/sfx/sfx_error.mp3',{});
	
	const SFX_BTN_DEFAULT = makeSfx('src/sfx/buttons/sfx_btn_default.mp3', {});
	const SFX_BTN_PAUSE = makeSfx('src/sfx/buttons/sfx_btn_pause.mp3',{});
	const SFX_BTN_TRAIT_CARD = makeSfx('src/sfx/buttons/trait_overlay_btn_select.mp3',{});
	const SFX_BTN_SHOP_REROLL = makeSfx('src/sfx/buttons/shop_btn_reroll.mp3',{});
	const SFX_BTN_SHOP_CLOSE = makeSfx('src/sfx/overlay_close_shop_overlay.mp3',{});
	
	const SFX_OVERLAY_APPEAR_SHOP = makeSfx('src/sfx/overlay_appear_shop_overlay.mp3',{});
	const SFX_OVERLAY_APPEAR_TRAIT = makeSfx('src/sfx/overlay_appear_trait.mp3',{});
	const SFX_MOB_DEATH = makeSfx('src/sfx/sfx_mob_death.mp3',{});
	const SFX_GAMEOVER = makeSfx('src/sfx/sfx_gameover.mp3',{});
	
	const SFX_PLAY_BGM = () => fadeAudio(bgm, 0.4, 200);
	const SFX_PAUSE_BGM = () => fadeAudio(bgm, 0, 200);
	
	// ---------- Attach SFX to buttons ----------
	document.querySelectorAll('.default-div-btn').forEach(el => {
		if (el.dataset && el.dataset.sfx) return;
		el.addEventListener('click', SFX_BTN_DEFAULT);
	});
	
	
	// ---------- Gun fire SFX ----------
	const SFX_GUN_FIRE_CACHE = new Map();
	function playGunFire(name){
		const slug = String(name);
		if (!SFX_GUN_FIRE_CACHE.has(slug)) {
			SFX_GUN_FIRE_CACHE.set(slug, makeSfxNoOverlapWithin(`src/sfx/gun_shot/fire_gun_${slug}.mp3`, { volume: 0.8, pool: 6, minGapMs: 500 }));
		}
		try { SFX_GUN_FIRE_CACHE.get(slug)(); } catch (e) {}
	}


	// =============== Utilities Functions =============== //
	const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

	function roundRect(ctx,x,y,w,h,r) { 
		const m=Math.min(w,h)/2; r=Math.min(r,m);
		ctx.beginPath(); ctx.moveTo(x+r,y);
		ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
		ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
	}
	
	// --- Waves ---
	function waveCountFor(n) {
		let c = WAVE_1_COUNT;
		for (let i = 1; i < n; i++) c = Math.max(1, Math.ceil(c * WAVE_INCREASE));
		return c;
	}
	function scaleHP(baseHp, wave) {
		if (!wave || wave <= 1) return baseHp;
		return Math.round(baseHp * (1 + (wave - 1) * MOB_HP_PER_WAVE)); //x0.1 per wave (linear)
		//return Math.round(baseHp * Math.pow(MOB_HP_PER_WAVE, (wave - 1))); //x1.07^waves (exponential)
	}
	function splitIntoGroups(total, groups) {
		const sizes = new Array(groups).fill(0);
		if (total <= 0) return sizes;
		const base = Math.floor(total / groups);
		let rem = total - base * groups;
		for (let i = 0; i < groups; i++) sizes[i] = base;
		while (rem-- > 0) sizes[Math.floor(Math.random()*groups)]++;
		for (let i = 0; i < groups; i++) if (sizes[i] === 0 && total >= groups) sizes[i] = 1;
		let sum = sizes.reduce((a,b)=>a+b,0);
		while (sum > total) { const i = sizes.findIndex(s=>s>1); sizes[i]--; sum--; }
		return sizes;
	}
	function computeFacingIndex() {
		if (GAME_STATE.player.aimVX != null && GAME_STATE.player.aimVY != null) {
			const vx = GAME_STATE.player.aimVX, vy = GAME_STATE.player.aimVY;
			const deg = Math.atan2(vx, -vy) * 180 / Math.PI; // −180..+180
			const clamped = Math.max(-90, Math.min(90, deg));
			return Math.min(4, Math.max(0, Math.floor((clamped + 90) / 36)));
		}
		const t = findClosestEnemy();
		if (!t) return 2;
		const dx = t.cx - GAME_STATE.player.x, dy = t.cy - GAME_STATE.player.y;
		const deg = Math.atan2(dx, -dy) * 180 / Math.PI;
		const clamped = Math.max(-90, Math.min(90, deg));
		return Math.min(4, Math.max(0, Math.floor((clamped + 90) / 36)));
	}
	function effectiveTimeBetweenBullets(w){
		const cdr = GAME_STATE.normalAttackReloadDec || 0;
		return w.stats.timeBetweenBullets * (1 - cdr);
	}
	function effectivePostUseCooldown(w){
		let cdrPct = GAME_STATE.buffs?.[w.stats.type]?.cdr_up || 0;
		
		return w.stats.postUseCooldown * (1 - cdrPct/100);
	}
	
	
	function addGunDamage(gunKey, dmg) {
        if (!gunKey || !dmg) return;
        if (!GAME_STATE.damageByGun) GAME_STATE.damageByGun = {};
        GAME_STATE.damageByGun[gunKey] = (GAME_STATE.damageByGun[gunKey] || 0) + dmg;
    }



  // ============ Class ============ //
	class Mob
	{
		constructor(type, x, yStart) {
			this.type = type; this.x = x; this.y = yStart;
			this.w = type.size; this.h = type.size; 
			const __baseHp = type.hp;
			const __wave   = (GAME_STATE && GAME_STATE.wave) ? GAME_STATE.wave : 1;
			const __scaled = scaleHP(__baseHp, __wave);
			this.hpMax = __scaled;
			this.hp = __scaled;
			this.contact = false; this.contactTimer = 0; this.dead = false; this.tookDamage = false;
		}
		get cx() { return this.x + this.w/2; }
		get cy() { return this.y + this.h/2; }
		
		update(dt) {
			if (this.dead) return;
			if (!this.contact) {
				this.y += this.type.speed * dt;
				if (this.y + this.h >= BARRICADE_Y) { this.y = BARRICADE_Y - this.h; this.contact = true; this.contactTimer = 0; }
			}
			else {
				this.contactTimer += dt;
				while (this.contactTimer >= CONTACT_DAMAGE_INTERVAL) { this.contactTimer -= CONTACT_DAMAGE_INTERVAL; applyBarrageDamage(this.type.dps); }
			}
		}
		hit(dmg) {
			if (this.dead) return;
			this.hp -= dmg;
			if (this.type.tier) this.tookDamage = true;
			if (this.hp <= 0) { this.dead = true; SFX_MOB_DEATH(); onMobKilled(this); }
		}
		draw(ctx) {
			if (this.dead) return;
			ctx.save();
			if (this.type.tier === "boss") { ctx.fillStyle = '#ef4444'; ctx.strokeStyle = '#b91c1c'; }
			else if (this.type.tier === "mini") { ctx.fillStyle = '#f59e0b'; ctx.strokeStyle = '#b45309'; }
			else { ctx.fillStyle = '#22d3ee'; ctx.strokeStyle = '#0ea5b7'; }
			ctx.lineWidth = 1.5;
			roundRect(ctx, this.x, this.y, this.w, this.h, 6);
			ctx.fill(); ctx.stroke();

			if (this.type.tier && this.tookDamage) {
				const ratio = clamp(this.hp / this.hpMax, 0, 1);
				const barW = this.w, barH = 4;
				ctx.fillStyle = '#0f172a';
				ctx.fillRect(this.x, this.y - 6, barW, barH);
				ctx.fillStyle = '#fca5a5';
				ctx.fillRect(this.x, this.y - 6, barW * ratio, barH);
			}
			ctx.restore();
		}
	}
	class Bullet
	{
		constructor(x,y,dx,dy,speed,dmg,crit=false, gunKey=null) {
			const len = Math.hypot(dx,dy) || 1;
			this.vx = dx/len * speed;
			this.vy = dy/len * speed;
			this.x = x;
			this.y = y;
			this.r = BULLET_RADIUS_SIZE;
			this.dmg = dmg;
			this.crit = crit;
			this.dead = false;
			this.gunKey = gunKey;
		}
		update(dt) {
			if (this.dead) return;
			this.x += this.vx * dt; this.y += this.vy * dt;
			if (this.x < -12 || this.x > W + 12 || this.y < -12 || this.y > H + 12) { this.dead = true; return; }
			for (const m of GAME_STATE.enemies) {
				if (m.dead) continue;
				const cx = Math.max(m.x, Math.min(this.x, m.x + m.w));
				const cy = Math.max(m.y, Math.min(this.y, m.y + m.h));
				const dx = this.x - cx, dy = this.y - cy;
				
				if (dx*dx + dy*dy <= this.r*this.r) {
					
					// apply dmg
					const hpBefore = m.hp;
					const dealt = Math.min(this.dmg, hpBefore);
					m.hit(dealt);
					
					// record dps
					addGunDamage(this.gunKey, dealt);

					// show the effective damage as the popup number
					const showX = cx;
					const showY = m.y - 6;
					(GAME_STATE.dmgNums || (GAME_STATE.dmgNums = [])).push(new DmgNum(showX, showY, dealt, this.crit));
					
					this.dead = true;
					break;
				}
			}
		}
		draw(ctx) {
			if (this.dead) return;
			ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
			ctx.fillStyle = this.crit ? '#fb7185' : '#fbbf24'; ctx.fill();
			ctx.shadowColor = this.crit ? '#fecdd3' : '#fde68a'; ctx.shadowBlur = 10; ctx.restore();
		}
	}
	class DmgNum
	{
		constructor(x, y, val, crit=false) {
			this.x = x + (Math.random()*8 - 4);
			this.y = y;
			this.val  = Math.round(val);
			this.crit = crit;
			
			this.age  = 0;
			this.life = DMG_NUM_LIFETIME;
			
			// jump physics
			this.vx = (Math.random() * 20 - 10);
			this.vy = DMG_NUM_VY0;
		}
		update(dt) {
			this.age += dt;
			this.vy  += DMG_NUM_GRAVITY * dt;
			this.x   += this.vx * dt;
			this.y   += this.vy * dt;
		}
		draw(ctx) {
			const a = Math.max(0, 1 - this.age / this.life);
			let s = 1;
			if (this.age < DMG_NUM_POP_TIME) {
				const t = 1 - (this.age / DMG_NUM_POP_TIME); //dmg poptime
				s = 1 + 0.25 * t;
			}
			ctx.save();
			ctx.globalAlpha = a;
			ctx.translate(this.x, this.y);
			ctx.scale(s, s);
			ctx.font = this.crit ? '600 25px "Rajdhani", sans-serif' : '600 22px "Rajdhani", sans-serif';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			ctx.lineWidth = 3;
			ctx.strokeStyle = 'rgba(0,0,0,0.6)';
			ctx.fillStyle   = this.crit ? '#f59e0b' : '#FFFFFA'; // orange crit, white normal
			ctx.strokeText(this.val, 0, 0);
			ctx.fillText(this.val, 0, 0);
			ctx.restore();
		}
	}
	
	
	// =============== Core Game Functions =============== //
	// Player
	function drawSoldier(ctx) {
		const p = GAME_STATE.player;
		ctx.save(); ctx.translate(p.x, p.y);
		ctx.fillStyle = '#a78bfa'; ctx.strokeStyle = '#7c3aed'; ctx.lineWidth = 1;
		ctx.beginPath(); ctx.moveTo(0,-p.size); ctx.lineTo(p.size*.9,p.size); ctx.lineTo(-p.size*.9,p.size); ctx.closePath();
		ctx.fill(); ctx.stroke();
		const t = findClosestInRange();
		if (t) {
			const dx = t.cx - p.x, dy = t.cy - p.y;
			const len = Math.hypot(dx, dy) || 1; const ux = dx/len, uy = dy/len;
			ctx.beginPath(); ctx.moveTo(0, -p.size*0.5); ctx.lineTo(ux*18, uy*18 - p.size*0.5);
			ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 3; ctx.stroke();
		}
		ctx.restore();
	}
	function updateSoldier(dt) {
		if (!GAME_STATE.weapons || GAME_STATE.weapons.length === 0) return;
		for (const w of GAME_STATE.weapons) {
			w.timer -= dt;
			
			if (w.lockoutTotal > 0 && (w.mode === 'burst' || w.mode === 'cooldown')) {
				w.lockoutElapsed = Math.min(w.lockoutTotal, (w.lockoutElapsed || 0) + dt);
			}

			if (w.mode === 'idle') {
				const nearest = findClosestEnemy(w.stats.range);
				if (nearest) {
					let chosen = nearest;
					if (Math.random() >= GUN_MULTITARGET_PROBILITY) {
						const p = GAME_STATE.player, r2 = w.stats.range*w.stats.range;
						const pool = [];
						for (const m of GAME_STATE.enemies) {
							if (m.dead) continue;
							const dx=p.x-m.cx, dy=p.y-m.cy, d2=dx*dx+dy*dy;
							if (d2<=r2) pool.push(m);
						}
						if (pool.length) chosen = pool[(Math.random()*pool.length)|0];
					}
					
					//update player-facing angle
					const p = GAME_STATE.player;
					const dx = chosen.cx - p.x, dy = chosen.cy - p.y;
					const L = Math.hypot(dx, dy) || 1;
					w.dirX = dx / L;
					w.dirY = dy / L;
					GAME_STATE.player.aimVX = w.dirX;
					GAME_STATE.player.aimVY = w.dirY;
					
					// --- fire gun ----
					w.mode = 'burst';
					w.burstLeft = w.stats.bulletsPerUse;
					w.timer = 0;
					playGunFire(w.key);
					//cooldown clock-wise
					const burstTime = Math.max(0, (w.stats.bulletsPerUse - 1)) * effectiveTimeBetweenBullets(w);
					w.lockoutTotal = burstTime + effectivePostUseCooldown(w);
					w.lockoutElapsed = 0;
				}
			}
			else if (w.mode === 'burst') 
			{
				while (w.burstLeft > 0 && w.timer <= 0) {
					if (w.dirX == null || w.dirY == null) break;

					//submachine gun tier 3 skill
					let forceCrit = false;
					//if (w.key === "submachinegun" && w.tier === 3 && w.stats.ability === "submachinegun_T3_GuaranteedCritAfter5") {
					//	w.shotsSinceAbility = (w.shotsSinceAbility || 0) + 1;
					//	if (w.shotsSinceAbility >= 5) { forceCrit = true; w.shotsSinceAbility = 0; }
					//}
					
					//damage calculator
					const isCrit = forceCrit || (Math.random() < CRIT_RATE);
					let dmg = w.stats.damage * (isCrit ? CRIT_MULT : 1); 
					dmg += dmg * ((GAME_STATE.buffs?.[w.stats.type]?.dmg_up || 0) / 100);
					
					const p = GAME_STATE.player;
					GAME_STATE.bullets.push(new Bullet(
						p.x, p.y - p.size * 0.6,
						w.dirX, w.dirY,
						BULLET_SPEED, dmg, isCrit,
						w.key
					));
					w.burstLeft--;
					w.timer += w.stats.timeBetweenBullets;
				}
				//goes off cooldown
				if (w.burstLeft === 0 && w.timer <= 0) {
					w.mode = 'cooldown';
					w.timer = effectivePostUseCooldown(w);
				}
			}
			else if (w.mode === 'cooldown') {
				if (w.timer <= 0) {
					w.mode = 'idle';
					w.lockoutElapsed = 0;
					w.lockoutTotal = 0;
				}
			}
		}
	}
	function findClosestInRange() {
		const ranges = (GAME_STATE.weapons && GAME_STATE.weapons.length)
		? GAME_STATE.weapons.map(w => w.stats.range)
		: [Infinity];
		const maxRange = Math.max(...ranges);
		return findClosestEnemy(maxRange);
	}
	
	//Mob
	function onMobKilled(m) {
		//add exp, coin, score, kill count
		GAME_STATE.player.exp += m.type.exp + Math.round((m.type.exp * ((GAME_STATE.buffs?.["unique"]?.exp_up || 0) / 100))); // exp gain trait
		GAME_STATE.coins += m.type.coin + Math.round((m.type.coin * ((GAME_STATE.buffs?.["unique"]?.gold_up || 0) / 100))); // gold gain trait
		GAME_STATE.score += m.type.score || 0;
		GAME_STATE.kills++;
		
		
		//level up
		while (GAME_STATE.player.exp >= GAME_STATE.player.expToNext) {
			GAME_STATE.player.exp -= GAME_STATE.player.expToNext;
			GAME_STATE.player.level += 1;
			GAME_STATE.player.expToNext = Math.ceil(GAME_STATE.player.expToNext * 1.3);
			enqueueTraitChoice(1);
		}
		
		//update scoreboard
		const fmt = n => Number(n).toLocaleString('en-US'); //add comma to digits
		coinNumEl.textContent  = String(fmt(GAME_STATE.coins));
		scoreNumEl.textContent = String(fmt(GAME_STATE.score));
		levelNumEl.textContent = String(GAME_STATE.player.level);
		
		//update exp bar
		const pct = Math.round((GAME_STATE.player.exp / GAME_STATE.player.expToNext) * 100);
		expFill.style.width = pct + '%';
	}
	function computeMobIntervalForWave(wave) {
		const t = Math.pow(MOB_INTERVAL_DECAY_PER_WAVE, Math.max(0, wave-1));
		return Math.max(MOB_INTERVAL_MIN, Math.min(MOB_INTERVAL_BASE, MOB_INTERVAL_BASE * t));
	}
	
	//Damage Number
	function updateDamageNumbers(dt) {
		if (!GAME_STATE.dmgNums) return;
		for (const d of GAME_STATE.dmgNums) d.update(dt);
		GAME_STATE.dmgNums = GAME_STATE.dmgNums.filter(d => d.age < d.life);
	}
	function drawDamageNumbers(ctx) {
		if (!GAME_STATE.dmgNums) return;
		for (const d of GAME_STATE.dmgNums) d.draw(ctx);
	}
	
	//Pick Traits
	function traitTierWeightsForLevel(level){
		// t is 0..1 (0 at level 1, 1 at level 21+)
		const t = Math.max(0, Math.min(1, (level-1)/20));
		const w1 = 0.70 * (1 - t) + 0.20 * t;   // 0.70 → 0.20
		const w3 = 0.05 * (1 - t) + 0.45 * t;   // 0.05 → 0.45
		const w2 = Math.max(0, 1 - w1 - w3);    // the rest
		return [w1, w2, w3];
	}
	function pickTierForLevel(level){
		const [w1, w2, w3] = traitTierWeightsForLevel(level);
		const r = Math.random();
		if (r < w1) return 1;
		if (r < w1 + w2) return 2;
		return 3;
	}
	
	//Barrage
	function drawBarrage(ctx) {
		ctx.save();
		const y = BARRICADE_Y;
		ctx.beginPath(); ctx.moveTo(12,y); ctx.lineTo(W-12,y);
		//ctx.strokeStyle = 'rgba(148,163,184,0.9)'; ctx.lineWidth = 0;
		//ctx.stroke(); //hide barrage
		ctx.restore();
	}
	function applyBarrageDamage(dmg) {
		const maxHP = BARRICADE_HP_MAX;
		const bar = document.getElementById('hpFill');
		const txt = document.getElementById('hpText');
		GAME_STATE.barricadeHP = (GAME_STATE.barricadeHP ?? maxHP) - dmg;
		GAME_STATE.barricadeHP = Math.max(0, Math.min(maxHP, GAME_STATE.barricadeHP));
		const pct = Math.round((GAME_STATE.barricadeHP / maxHP) * 100);
		bar.style.width = pct + '%'; txt.textContent = pct + '%';
		
		if (GAME_STATE.barricadeHP <= 0) show_gameoverOverlay();
	}
  
	//Wave
	function startWave(n, totalCount) {
		GAME_STATE.wave = n; waveNumEl.textContent = String(n);
		GAME_STATE.toSpawn = totalCount; GAME_STATE.groupIndex = 0; GAME_STATE.groupMobIndex = 0;
		GAME_STATE.specialsSpawned = false; GAME_STATE.specialsProgress = 0; GAME_STATE.specialsTimer = 0;
		GAME_STATE.groupIntervalTimer = 0; GAME_STATE.mobIntervalWave = computeMobIntervalForWave(n); GAME_STATE.mobIntervalTimer = 0;
		GAME_STATE.groupSizes = splitIntoGroups(totalCount, GROUPS_PER_WAVE);
		GAME_STATE.specialsQueued.mini = (n % 5 === 0);
		GAME_STATE.specialsQueued.boss = (n % 10 === 0);
	}
	function spawnOneNormalMob() {
		const s = MOBS["A"].size;
		const x = Math.max(0, Math.min(W - s, Math.random() * (W - s)));
		const y = -s - (Math.random() * 140 + 20);
		GAME_STATE.enemies.push(new Mob(MOBS["A"], x, y));
	}
	function spawnSpecial(type) {
		const s = type.size;
		const x = Math.max(0, Math.min(W - s, Math.random() * (W - s)));
		const y = -s - (Math.random() * 130 + 30);
		GAME_STATE.enemies.push(new Mob(type, x, y));
	}
	function showBossWarning(text = "BOSS APPROACHING") {
		bossWarn.textContent = text;
		bossWarn.classList.add('show');
		const per = Math.max(0.1, BOSS_WARN_TOTAL_DURATION / Math.max(1, BOSS_WARN_FLASHES));
		bossWarn.style.animation = 'none'; void bossWarn.offsetWidth;
		bossWarn.style.animation = `warnPulse ${per}s ease-in-out ${Math.max(1, BOSS_WARN_FLASHES)}`;
		clearTimeout(bossWarn._hideTO);
		bossWarn._hideTO = setTimeout(()=>{ bossWarn.classList.remove('show'); bossWarn.style.animation='none'; }, Math.max(0, BOSS_WARN_TOTAL_DURATION)*1000 + 50);
	}
	function updateSpawning(dt) {
		if (GAME_STATE.groupIndex >= GROUPS_PER_WAVE) return;

		if (GAME_STATE.groupMobIndex === 0 && GAME_STATE.groupIndex > 0 && GAME_STATE.groupIntervalTimer > 0) {
			GAME_STATE.groupIntervalTimer -= dt; return;
		}
		const isLastGroup = (GAME_STATE.groupIndex === GROUPS_PER_WAVE - 1);
		const groupSize = GAME_STATE.groupSizes[GAME_STATE.groupIndex] || 0;
		if (isLastGroup && (GAME_STATE.specialsQueued.mini || GAME_STATE.specialsQueued.boss) && !GAME_STATE.specialsSpawned) {
			if (GAME_STATE.specialsProgress === 0) {
				if (GAME_STATE.specialsQueued.boss) showBossWarning();
				if (GAME_STATE.specialsQueued.mini) {
					spawnSpecial(MINI_BOSS_A);
					GAME_STATE.specialsProgress = 1;
					if (GAME_STATE.specialsQueued.boss) { GAME_STATE.specialsTimer = BOSS_MINI_TO_BOSS_INTERVAL; return; }
					else { GAME_STATE.specialsSpawned = true; }
				}
				else {
					if (GAME_STATE.specialsQueued.boss) spawnSpecial(BOSS_A);
					GAME_STATE.specialsSpawned = true; GAME_STATE.specialsProgress = 2;
				}
			}
			else if (GAME_STATE.specialsProgress === 1 && GAME_STATE.specialsQueued.boss) {
				GAME_STATE.specialsTimer -= dt;
				if (GAME_STATE.specialsTimer <= 0) { spawnSpecial(BOSS_A); GAME_STATE.specialsSpawned = true; GAME_STATE.specialsProgress = 2; }
				else return;
			}
		}
		if (GAME_STATE.groupMobIndex < groupSize) {
			GAME_STATE.mobIntervalTimer -= dt;
			if (GAME_STATE.mobIntervalTimer <= 0) {
				spawnOneNormalMob();
				GAME_STATE.groupMobIndex += 1; GAME_STATE.toSpawn -= 1; GAME_STATE.mobIntervalTimer = GAME_STATE.mobIntervalWave;
			}
		}
		else {
			if (GAME_STATE.groupIndex < GROUPS_PER_WAVE - 1) {
				GAME_STATE.groupIndex += 1; GAME_STATE.groupMobIndex = 0; GAME_STATE.groupIntervalTimer = GROUP_INTERVAL_BASE; GAME_STATE.mobIntervalTimer = 0;
			} else { GAME_STATE.groupIndex = GROUPS_PER_WAVE; }
		}
	}
	function maybeStartNextWave() {
		if (GAME_STATE.groupIndex < GROUPS_PER_WAVE) return;
		const anyAlive = GAME_STATE.enemies.some(e => !e.dead);
		if (!anyAlive) {
			const nextCount = Math.max(1, Math.ceil(waveCountFor(GAME_STATE.wave + 1)));
			openShopOverlay(GAME_STATE.wave + 1, nextCount);
		}
	}
	function startWave(n, totalCount) {
		GAME_STATE.wave = n; waveNumEl.textContent = String(n);
		GAME_STATE.toSpawn = totalCount; GAME_STATE.groupIndex = 0; GAME_STATE.groupMobIndex = 0;
		GAME_STATE.specialsSpawned = false; GAME_STATE.specialsProgress = 0; GAME_STATE.specialsTimer = 0;
		GAME_STATE.groupIntervalTimer = 0; GAME_STATE.mobIntervalWave = computeMobIntervalForWave(n); GAME_STATE.mobIntervalTimer = 0;
		GAME_STATE.groupSizes = splitIntoGroups(totalCount, GROUPS_PER_WAVE);
		GAME_STATE.specialsQueued.mini = (n % 5 === 0);
		GAME_STATE.specialsQueued.boss = (n % 10 === 0);
	}
	function spawnOneNormalMob() {
		const s = MOBS["A"].size;
		const x = Math.max(0, Math.min(W - s, Math.random() * (W - s)));
		const y = -s - (Math.random() * 140 + 20);
		GAME_STATE.enemies.push(new Mob(MOBS["A"], x, y));
	}
	function spawnSpecial(type) {
		const s = type.size;
		const x = Math.max(0, Math.min(W - s, Math.random() * (W - s)));
		const y = -s - (Math.random() * 130 + 30);
		GAME_STATE.enemies.push(new Mob(type, x, y));
	}
	function showBossWarning(text = "BOSS APPROACHING") {
		bossWarn.textContent = text;
		bossWarn.classList.add('show');
		const per = Math.max(0.1, BOSS_WARN_TOTAL_DURATION / Math.max(1, BOSS_WARN_FLASHES));
		bossWarn.style.animation = 'none'; void bossWarn.offsetWidth;
		bossWarn.style.animation = `warnPulse ${per}s ease-in-out ${Math.max(1, BOSS_WARN_FLASHES)}`;
		clearTimeout(bossWarn._hideTO);
		bossWarn._hideTO = setTimeout(()=>{ bossWarn.classList.remove('show'); bossWarn.style.animation='none'; }, Math.max(0, BOSS_WARN_TOTAL_DURATION)*1000 + 50);
	}
	function updateSpawning(dt) {
		if (GAME_STATE.groupIndex >= GROUPS_PER_WAVE) return;
		
		if (GAME_STATE.groupMobIndex === 0 && GAME_STATE.groupIndex > 0 && GAME_STATE.groupIntervalTimer > 0) {
			GAME_STATE.groupIntervalTimer -= dt; return;
		}
		const isLastGroup = (GAME_STATE.groupIndex === GROUPS_PER_WAVE - 1);
		const groupSize = GAME_STATE.groupSizes[GAME_STATE.groupIndex] || 0;
		if (isLastGroup && (GAME_STATE.specialsQueued.mini || GAME_STATE.specialsQueued.boss) && !GAME_STATE.specialsSpawned) {
			if (GAME_STATE.specialsProgress === 0) {
				if (GAME_STATE.specialsQueued.boss) showBossWarning();
				if (GAME_STATE.specialsQueued.mini) {
					spawnSpecial(MINI_BOSS_A);
					GAME_STATE.specialsProgress = 1;
					if (GAME_STATE.specialsQueued.boss) { GAME_STATE.specialsTimer = BOSS_MINI_TO_BOSS_INTERVAL; return; }
					else { GAME_STATE.specialsSpawned = true; }
				}
				else {
					if (GAME_STATE.specialsQueued.boss) spawnSpecial(BOSS_A);
					GAME_STATE.specialsSpawned = true; GAME_STATE.specialsProgress = 2;
				}
			}
			else if (GAME_STATE.specialsProgress === 1 && GAME_STATE.specialsQueued.boss) {
				GAME_STATE.specialsTimer -= dt;
				if (GAME_STATE.specialsTimer <= 0) { spawnSpecial(BOSS_A); GAME_STATE.specialsSpawned = true; GAME_STATE.specialsProgress = 2; }
				else return;
			}
		}
		if (GAME_STATE.groupMobIndex < groupSize) {
			GAME_STATE.mobIntervalTimer -= dt;
			if (GAME_STATE.mobIntervalTimer <= 0) {
				spawnOneNormalMob();
				GAME_STATE.groupMobIndex += 1; GAME_STATE.toSpawn -= 1; GAME_STATE.mobIntervalTimer = GAME_STATE.mobIntervalWave;
			}
		}
		else {
			if (GAME_STATE.groupIndex < GROUPS_PER_WAVE - 1) {
				GAME_STATE.groupIndex += 1; GAME_STATE.groupMobIndex = 0; GAME_STATE.groupIntervalTimer = GROUP_INTERVAL_BASE; GAME_STATE.mobIntervalTimer = 0;
			}else { GAME_STATE.groupIndex = GROUPS_PER_WAVE; }
		}
	}
	
	
	function show_pauseOverlay() {
		updatePauseTraitGrid();
		renderWeaponRemovalRemovedList(overlay_pause_removal_list);
		
		console.log(GAME_STATE)//here
		
		SFX_BTN_PAUSE();
		GAME_STATE.paused = true;
		
        if (pauseOverlay) pauseOverlay.classList.remove('hidden');
    }
    function hidden_pauseOverlay() {
		SFX_PLAY_BGM();
		GAME_STATE.paused = false;
		
        if (pauseOverlay) pauseOverlay.classList.add('hidden');
    }
	
	function show_gameoverOverlay() {
		const fmt = n => Number(n).toLocaleString('en-US');
		
		SFX_GAMEOVER();
		GAME_STATE.paused = true;
		
		const container = document.getElementById('gameover_scoreboard_list');
		if (!container) return;
		
		container.innerHTML = "";
		
		const rows = [
			{ title: "Wave",              score: GAME_STATE.wave },
			{ title: "Enemies Killed",    score: GAME_STATE.kills },
			{ title: "Total Gold Earned", score: "0" },
			{ title: "Gold Spent",        score: "0" },
			{ title: "Remaining Gold",    score: GAME_STATE.coins },
		];
		
		rows.forEach(row => {
			const rowDiv   = document.createElement("div");
			const titleDiv = document.createElement("div");
			const scoreDiv = document.createElement("div");
			
			rowDiv.className   = "gameover-scoreboard-row";
			titleDiv.className = "gameover-scoreboard-title";
			scoreDiv.className = "gameover-scoreboard-score";
			
			titleDiv.textContent = row.title;
			
			const val = row.score;
			scoreDiv.textContent = (val === undefined || val === null) ? 0 : val;

			rowDiv.appendChild(titleDiv);
			rowDiv.appendChild(scoreDiv);
			container.appendChild(rowDiv);
		});
		
		document.getElementById('gameover_total_point').textContent = fmt(GAME_STATE.score);
		
        if (gameoverOverlay) gameoverOverlay.classList.remove('hidden');
    }
	
	
	
	// ----------------- Overlay Select Traits ----------------- //
	function openTraitOverlay() {
		GAME_STATE.traitOverlayOpen = true;
		GAME_STATE.paused = true;
		
		SFX_PAUSE_BGM();
		SFX_OVERLAY_APPEAR_TRAIT();
		
		// How many cards? 3 + maybe 1 extra
		const count = TRAIT_BASE_CARD_COUNT + (Math.random() < TRAIT_EXTRA_CARD_CHANCE ? 1 : 0);
		const offer = [];
		const usedPairs = new Set();
		let guard = 200; // safety to avoid infinite loops if trait pool is too small

		while (offer.length < count && guard-- > 0) {
			const def = TRAITS[(Math.random() * TRAITS.length) | 0];
			const tier = pickTierForLevel(GAME_STATE.player.level);
			const key = def.id + '|' + tier;

			if (usedPairs.has(key)) continue; // skip exact (id,tier) duplicates

			offer.push({ id: def.id, tier });
			usedPairs.add(key);
		}
		
		GAME_STATE.traitSelected = null;
		
		// Render cards
		traitCardsBox.innerHTML = "";
		traitCardsBox.classList.add("trait-vertical");
		offer.forEach(o => {
			const def = TRAITS.find(x => x.id === o.id);
			const nameTxt = typeof def.name === 'function' ? def.name(o.tier) : def.name;
			const descTxt = typeof def.desc === 'function' ? def.desc(o.tier) : (def.desc || '');
			const scaleTxt = typeof def.scaling === 'function' ? def.scaling(o.tier) : (def.scaling ?? '');

			const card = document.createElement('div');
			card.className = 'trait-card';
			card.dataset.tier = String(o.tier);
			
			//trait radio button
			const radio = document.createElement('div');
			radio.className = 'trait-radio';
			const radio_img = document.createElement('div');
			radio_img.className = 'trait-radio-img';
			radio.appendChild(radio_img);
			
			//trait picture
			const icon = document.createElement('div');
			icon.className = 'trait-icon';
			icon.dataset.tier = String(o.tier);
			
			const icon_frame = document.createElement('div');
			icon_frame.className = 'trait-icon-frame';
			icon.appendChild(icon_frame);
			
			const icon_img = document.createElement('div');
			icon_img.className = 'trait-icon-img';
			icon_img.style.backgroundImage = 'url("src/img/UI/trait icon/icon_' + String(o.id) + '.png")';
			icon_frame.appendChild(icon_img);
			
			//text body
			const body = document.createElement('div');
			body.className = 'trait-text';
			const title = document.createElement('div');
			title.className = 'trait-title';
			title.textContent = nameTxt;

			const desc = document.createElement('div');
			desc.className = 'trait-desc';
			desc.innerHTML = descTxt + '<span class="accent">' + scaleTxt + '%' + '</span>';
			
			body.appendChild(title);
			body.appendChild(desc);
			card.appendChild(radio);
			card.appendChild(icon);
			card.appendChild(body);
			
			//Click on Card
			card.addEventListener('click', () => {
				traitCardsBox.querySelectorAll('.trait-card.selected').forEach(el => el.classList.remove('selected'));
				card.classList.add('selected');
				GAME_STATE.traitSelected = { id: o.id, tier: o.tier };
				traitStart.classList.toggle('disabled', false);
				SFX_BTN_TRAIT_CARD();
			});
			
			traitCardsBox.appendChild(card);
		});
		traitCardsBox.style.gridTemplateColumns = `repeat(${offer.length}, 1fr)`;
		traitOverlay.classList.remove('hidden');
		
		if (traitStart && !traitStart._wired) {
			traitStart._wired = true;
			traitStart.addEventListener('click', onTraitStartConfirm);
		}
	}
	function closeTraitOverlay() {
		GAME_STATE.traitOverlayOpen = false;
		traitOverlay.classList.add('hidden');
		traitStart.classList.toggle('disabled', true);
		
		GAME_STATE.traitQueue = Math.max(0, (GAME_STATE.traitQueue || 0) - 1);
		if (GAME_STATE.traitQueue > 0) {
			openTraitOverlay();
			return;
		}
		maybeResumeGameIfNoOverlays();
	}
	function onTraitStartConfirm() {
		const btn = this; // #traitStartBtn
		if (!GAME_STATE.traitSelected) return;
		
		const { id, tier } = GAME_STATE.traitSelected;
		applyTrait(id, tier);
		
		GAME_STATE.traitSelected = null;
		btn.disabled = true;
		closeTraitOverlay();
	}
	function maybeResumeGameIfNoOverlays() {
		const anyShopOpen = !document.getElementById('shopOverlay')?.classList.contains('hidden');
		const anyTraitOpen = GAME_STATE.traitOverlayOpen === true;
		const traitStillQueued = (GAME_STATE.traitQueue || 0) > 0;

		// If anything is still pending, keep paused and keep bgm low.
		if (anyShopOpen || anyTraitOpen || traitStillQueued) {
			GAME_STATE.paused = true;
			return;
		}
		GAME_STATE.paused = false;
		SFX_PLAY_BGM();
	}
	function enqueueTraitChoice(n = 1) {
		GAME_STATE.traitQueue = (GAME_STATE.traitQueue || 0) + n;
		if (!GAME_STATE.traitOverlayOpen) {
			openTraitOverlay();
		}
	}
	function updateTraitViewer() {
		traitListBox.innerHTML = "";

		const groups = new Map(); // id -> tiers[]
		for (const t of (GAME_STATE.traitsOwned || [])) {
			if (!groups.has(t.id)) groups.set(t.id, []);
			groups.get(t.id).push(t.tier);
		}

		if (groups.size === 0) {
			const empty = document.createElement('div');
			empty.className = 'trait-pill';
			empty.textContent = "No traits yet.";
			traitListBox.appendChild(empty);
			return;
		}

		for (const [id, tiers] of groups) {
			const def = TRAITS.find(x => x.id === id);
			if (!def) continue;

			const maxTier  = Math.max(...tiers);
			const total    = getTraitTotal(def);// from GAME_STATE.buffs
			const descTxt  = def.desc(maxTier);
			const suffix   = '%';
			const totalTxt = total + suffix;

			const row = document.createElement('div');
			row.className = 'trait-pill';
			row.innerHTML = '<div>' + descTxt + '<span>' + totalTxt + '</span></div>';
			traitListBox.appendChild(row);
		}
		
		function getTraitTotal(def) {
			if (def.buff_type === 'unique') {
				return GAME_STATE.buffs?.[def.id] ?? 0;
			}
			const node = GAME_STATE.buffs?.[def.gun_type] || {};
			return node[def.buff_type] ?? 0;
		}
	}
	function openTraitViewer() {
		updateTraitViewer();
		traitOverlayViewer.classList.remove('hidden');
	}
	function closeTraitViewer(){
		traitOverlayViewer.classList.add('hidden');
	}
	
	
	// ----------------- Overlay Grid Trait Icon ----------------- //
	function updatePauseTraitGrid() {
		if (!pauseTraitsGrid) return;

		pauseTraitsGrid.innerHTML = '';

		const owned = GAME_STATE.traitsOwned || [];
		if (!owned.length) return; // 0 trait
		
		for (const t of owned) {
			const slot = document.createElement('div');
			slot.className = 'pause-trait-slot';
			slot.dataset.tier = t.tier + ',' + t.id;
			
			const icon = document.createElement('div');
			icon.className = 'trait-icon';
			icon.dataset.tier = String(t.tier);

			const icon_frame = document.createElement('div');
			icon_frame.className = 'trait-icon-frame';
			icon.appendChild(icon_frame);

			const icon_img = document.createElement('div');
			icon_img.className = 'trait-icon-img';
			icon_img.style.backgroundImage = 'url("src/img/UI/trait icon/icon_' + String(t.id) + '.png")';
			icon_frame.appendChild(icon_img);
			
			slot.appendChild(icon);
			pauseTraitsGrid.appendChild(slot);
		}
	}
	
	
	// ----------------- Overlay DPS ----------------- //
    function updateDpsOverlay() {
        if (!dpsList) return;
        const fmt = n => Number(n).toLocaleString('en-US');
		
		const dmgMap  = GAME_STATE.damageByGun || {};
		const weapons = GAME_STATE.weapons || [];
		
		const entries = Object.entries(dmgMap).filter(([_, dmg]) => dmg > 0);
        if (entries.length === 0) return; //no dps

        // sort by total damage desc
        entries.sort((a, b) => b[1] - a[1]);
        const maxDamage = entries[0][1] || 1;
		
        dpsList.innerHTML = '';
		
        for (const [key, dmg] of entries) {
            const pct = Math.max(4, Math.min(100, (dmg / maxDamage) * 100)); // min width so tiny damage still visible

            const row = document.createElement('div');
            row.className = 'dps-card';
            row.innerHTML = `
                <div class="dps-card-icon overlay-background-stripe"><img src="src/img/item/icon/icon_gun_${key}.png"></div>
				<div class="dps-card-detail">
					<div class="dps-card-header">
						<span class="dps-name">${GUN_CONFIG[key].name}</span>
						<span class="dps-damage">${fmt(dmg.toFixed(0))}</span>
					</div>
					<div class="dps-bar">
						<div class="dps-bar-fill" style="width:${pct}%;"></div>
					</div>
				</div>
            `;
            dpsList.appendChild(row);
        }
    }
    function openDpsOverlay() {
        updateDpsOverlay();
        if (dpsOverlay) dpsOverlay.classList.remove('hidden');
    }
    function closeDpsOverlay() {
        if (dpsOverlay) dpsOverlay.classList.add('hidden');
    }

	
  
	//Buttons
	btn_resume.addEventListener('click', hidden_pauseOverlay);
	btn_quickend.addEventListener('click', show_gameoverOverlay);
	btn_restart.addEventListener('click', restart);
	
	pauseBtn.addEventListener('click', show_pauseOverlay);
	speedBtn.addEventListener('click', core_game_speed);
	document.querySelectorAll('.btn_viewTraits').forEach(btn => {btn.addEventListener('click', openTraitViewer);});
	document.querySelectorAll('.btn_viewInventory').forEach(btn => {btn.addEventListener('click', ()=>{ openShopOverlay(0,0,false,true);});});
	closeTraitViewerBtn.addEventListener('click', closeTraitViewer);
	document.querySelectorAll('.btn_view_dps').forEach(btn => {btn.addEventListener('click', openDpsOverlay);});
    btnDPS_close_view.addEventListener('click', closeDpsOverlay);
	
	
	//game speed
	function core_game_speed() {
		if (speedBtn.disabled) return; 
		
		GAME_STATE.speedMult = GAME_STATE.speedMult % 3 + 1;
		speedBtn.innerHTML = GAME_STATE.speedMult + "x";
		
		try {
			localStorage.setItem(SPEED_STORAGE_KEY, String(GAME_STATE.speedMult));
		} catch (_) {}
	}
	
	
	//Apply Traits
	function applyTrait(id, tier) {
		const def = TRAITS.find(t => t.id === id);
		if (!def) return;
		
		def.apply(tier);

		if (!GAME_STATE.traitsOwned) GAME_STATE.traitsOwned = [];
		GAME_STATE.traitsOwned.push({ id, name: def.name, tier });

		updateTraitViewer();
		updatePauseTraitGrid();
	}

	
	//Load Inventory Grid
	function renderInventory() {
		const invGrid = document.getElementById('inventoryGrid');
		invGrid.innerHTML = "";

		for (let i = 0; i < 16; i++) {
			const item = GAME_STATE.inventory[i];
			const d = document.createElement('div');
			d.className = "slot" + (item ? " filled" : "");

			if (item) {
				//tier background
				const bg = document.createElement('img');
				bg.className = 'slot-layer slot-bg';
				bg.alt = 'tier background';
				bg.src = `src/img/UI_battlefield_inventory_slot_background_tier_${item.tier ?? 1}.png`;
				bg.draggable = false;
				bg.addEventListener('dragstart', e => e.preventDefault());
				d.appendChild(bg);
				
				//gun image
				const gun = document.createElement('img');
				gun.className = 'slot-layer slot-gun';
				gun.src = 'src/img/item/icon/icon_gun_' + String(item.key) + '.png';
				gun.draggable = false;
				gun.addEventListener('dragstart', e => e.preventDefault());
				d.appendChild(gun);
				
				//cooldown (clock-wise)
				const cd = document.createElement('div');
				cd.className = 'slot-layer slot-cd';
				cd.dataset.wi = i;
				d.appendChild(cd);
			}
			invGrid.appendChild(d);
		}
	}
	
	function updateInventoryCooldownUI(){
		const grid = document.getElementById('inventoryGrid');
		if (!grid || !GAME_STATE.weapons) return;
		
		const cds = grid.querySelectorAll('.slot-cd');
		cds.forEach(el => {
			const wi = +el.dataset.wi;
			const w = GAME_STATE.weapons[wi];
			if (!w) { el.style.opacity = 0; return; }
			
			const busy = (w.mode === 'burst' || w.mode === 'cooldown');
			if (busy && w.lockoutTotal > 0) {
				const frac = (w.lockoutElapsed || 0) / w.lockoutTotal;  // 0 at fire → 1 when ready
				el.style.opacity = 1;
				el.style.setProperty('--cd', String(Math.max(0, Math.min(1, frac))));
			}
			else {
				el.style.opacity = 0;
				el.style.setProperty('--cd', "0");
			}
		});
	}
	
	
	// ------- Restart/Reset Game ------- //here
	function restart() 
	{
		GAME_STATE = structuredClone(INITIAL_GAME_STATE);
		INITIATE_GAME_STATE_BUFFS(GAME_STATE);
		
		GAME_STATE.paused=false;
		
		//reset game properties
		GAME_STATE.enemies.length=0; GAME_STATE.bullets.length=0;
		GAME_STATE.coins=0; GAME_STATE.score=0; GAME_STATE.kills=0;
		GAME_STATE.player.level=1; GAME_STATE.player.exp=0; GAME_STATE.player.expToNext=50; GAME_STATE.player.mode='idle'; GAME_STATE.player.burstLeft=0; GAME_STATE.player.timer=0;
		GAME_STATE.damageByGun = {};
		GAME_STATE.combatTime = 0;
		GAME_STATE.dmgNums = [];
		GAME_STATE.traitQueue = 0;
		GAME_STATE.traitOverlayOpen = false;
		
		//empty inventory
		GAME_STATE.inventory = new Array(16).fill(null);
		renderInventory();
		
		//get game speed
		const saved = parseInt(localStorage.getItem(SPEED_STORAGE_KEY) || "1", 10);
		GAME_STATE.speedMult = [1,2,3].includes(saved) ? saved : 1;
		speedBtn.innerHTML = GAME_STATE.speedMult+"x";
		
		//reset scoreboard
		coinNumEl.textContent=GAME_STATE.coins;
		scoreNumEl.textContent="0";
		
		//reset EXP
		levelNumEl.textContent="1";
		expFill.style.width='0%';
		
		//reset barrrage HP
		GAME_STATE.barricadeHP = BARRICADE_HP_MAX;
		document.getElementById('hpFill').style.width='100%';
		document.getElementById('hpText').textContent='100%';
		
		//reset traits
		GAME_STATE.traitsOwned = [];
		updateTraitViewer();
		updatePauseTraitGrid();
		
		//restart game
		ensureBgmPlaying(true);
		SFX_PLAY_BGM();
		document.querySelectorAll('.game-overlay').forEach(n => n.classList.add('hidden'));
		
		openShopOverlay(CURRENT_WAVE, waveCountFor(CURRENT_WAVE), true);
	}
	
	
	// ------- Frame Game Loop ------- //
	let __dm=1; addEventListener('keydown',e=>{if(e.code==='Space')__dm=10}); addEventListener('keyup',e=>{if(e.code==='Space')__dm=1});
	requestAnimationFrame(function loop(now)
	{
		const rawDt = Math.min((now - (loop.t||now)) / 1000, 0.05); loop.t = now;
		if (!GAME_STATE.paused)
		{
			const dt = rawDt * GAME_STATE.speedMult * (__dm||1);
			GAME_STATE.combatTime += dt;
			updateSpawning(dt);
			for (const m of GAME_STATE.enemies) m.update(dt);
			for (const b of GAME_STATE.bullets) b.update(dt);
			GAME_STATE.bullets = GAME_STATE.bullets.filter(b => !b.dead);
			updateDamageNumbers(dt);
			updateSoldier(dt);
			updateInventoryCooldownUI();
			maybeStartNextWave();
			
			// Update soldier GIF based on facing band
			if (typeof computeFacingIndex === 'function' && soldierSpriteEl)
			{
				const fIdx = computeFacingIndex();
				if (fIdx !== _soldierIdx) {
					_soldierIdx = fIdx;
					soldierSpriteEl.src = SOLDIER_ANGLES[_soldierIdx];
				}
			}
		}
		ctx.clearRect(0,0,W,H);
		drawBarrage(ctx);
		for (const m of GAME_STATE.enemies) m.draw(ctx);
		for (const b of GAME_STATE.bullets) b.draw(ctx);
		drawDamageNumbers(ctx);
		drawSoldier(ctx);
		requestAnimationFrame(loop);
	});

	restart();
	
	//Bridge
	try {
		window.bgm = bgm;
		window.GUN_CONFIG = GUN_CONFIG;
		window.GAME_STATE = GAME_STATE;
		window.makeSfx = makeSfx;
		window.startWave = startWave;
		window.renderInventory = renderInventory;
		window.makeWeaponInstance = makeWeaponInstance;
		
		window.SFX_ERROR = SFX_ERROR;
		window.SFX_BTN_SHOP_REROLL = SFX_BTN_SHOP_REROLL;
		window.SFX_BTN_SHOP_CLOSE = SFX_BTN_SHOP_CLOSE;
		window.SFX_OVERLAY_APPEAR_SHOP = SFX_OVERLAY_APPEAR_SHOP;
		window.SFX_PLAY_BGM = SFX_PLAY_BGM;
		window.SFX_PAUSE_BGM = SFX_PAUSE_BGM;
		
	} catch(_) {}
})();

// ======= Shop (9x9) =======
(function(){
	const shopOverlay = document.getElementById('shopOverlay');
	const shopGridEl  = document.getElementById('shopGrid');
	const shopOfferEl = document.getElementById('shopOffer');
	const btn_shop_close = document.getElementById('btn_shop_close');
	const btnRerollOffer = document.getElementById('btn_shop_reroll');
	
	//weapon removal
	const btnShopWeaponRemovalMain = document.getElementById('btnShop_weaponRemoval');
	const weaponRemovalOverlay = document.getElementById('weaponRemovalOverlay');
	const weaponRemovalOfferEl = document.getElementById('weaponRemovalOffer');
	const weaponRemovalRemovedListEl = document.getElementById('weaponRemovalRemovedList');
	const weaponRemovalConfirmBtn = document.getElementById('weaponRemovalConfirmBtn');
	const weaponRemovalCancelBtn = document.getElementById('weaponRemovalCancelBtn');
	const btn_subtitle_removal = document.querySelectorAll('.btn_subtitle_removal');
	
	
	if (!shopOverlay || !shopGridEl || !shopOfferEl) return;
	
	// ----------------------- Configs ----------------------- //
	const GRID_ROWS = 9, GRID_COLS = 9;
	const MINI_CELL = 35;
	const CELL = 49;
	const CELL_GAP = 3;
	const cellStep = CELL + CELL_GAP;
	const GHOST_SNAP_OFFSET_X = -10;
	const GHOST_SNAP_OFFSET_Y = -10;
	
	// shop offer reroll
	const num_shop_offer_base_item = 3;
	const num_shop_offer_max_item = 10;
	
	const root = document.documentElement;
	root.style.setProperty('--shop-gun-offer-count',  num_shop_offer_base_item);
	root.style.setProperty('--shop-gun-offer-scale', '1');
	
	const REROLL_CONFIG = Object.freeze({
		basePrice: 1000,
		increment: 1000,
		freeCount: 10,
	});
	const rerollState = {
		price: REROLL_CONFIG.basePrice,
		freeLeft: REROLL_CONFIG.freeCount,
	};
	
	// shop weapon removal
	const shop_removal_max_use = 5;
	let weaponRemovalSelectedItem = null; 

	
	let mergeHighlightSet = new Set();
	
	const TIER_COLORS = {
		1: ['#34d399', '#059669'], // green
		2: ['#60a5fa', '#1d4ed8'], // blue
		3: ['#a78bfa', '#7c3aed'], // purple
		4: ['#facc15', '#eab308'], // yellow-ish/gold
	};
	const SHOP_TIER_CHANCE = {
		1: 50,
		2: 42,
		3: 7.5,
		4: 0.5
	};
	
	// ------- Drag & Drop -------
	let ghost            = null;
	let dragFrom         = null;   // 'grid' or 'offer'
	let startPos         = null;   // { r, c } where the item started
	let activePointerId  = null;
	let draggingItem     = null;   // the shopState.items entry being dragged
	let draggingSourceEl = null;   // the DOM element we picked up from
	let lastSnap         = null;   // { r, c, ok:true } of the current preview
	let previewWrap      = null;   // .placement-preview layer in the grid
	let grabOffsetX      = 0;
	let grabOffsetY      = 0;

	let ghostAnimId   = null;
	let ghostCurrX    = 0;
	let ghostCurrY    = 0;
	let ghostTargetX  = 0;
	let ghostTargetY  = 0;

	let shopState = {
		items: [],
		dragging: null,
		pending: null
	};
	
	//build shop grid
	shopGridEl.innerHTML = '';
	for (let r = 0; r < GRID_ROWS; r++) {
		for (let c = 0; c < GRID_COLS; c++) {
			const slot = document.createElement('div');
			slot.className = 'cell';
			slot.style.position = 'absolute';
			slot.style.left = (c * (CELL + CELL_GAP)) + 'px';
			slot.style.top = (r * (CELL + CELL_GAP)) + 'px';
			slot.style.width = CELL + 'px';
			slot.style.height = CELL + 'px';
			slot.style.backgroundImage = "url('src/img/UI/UI_shop_slot_default.png')";
			slot.style.backgroundRepeat = 'no-repeat';
			slot.style.backgroundSize = '100% 100%';
			slot.style.backgroundPosition = 'center';
			shopGridEl.appendChild(slot);
		}
	}
	shopGridEl.style.width  = (GRID_COLS * (CELL + CELL_GAP) - CELL_GAP) + 'px';
	shopGridEl.style.height = (GRID_ROWS * (CELL + CELL_GAP) - CELL_GAP) + 'px';
	
	
	
	function shapeCells(item, anchorR, anchorC){
		const shape = GUN_CONFIG[item.key].shape || [];
		return shape.map(([dr,dc]) => [anchorR + dr, anchorC + dc]);
	}
	function inBounds(r,c){
		return r>=0 && r<GRID_ROWS && c>=0 && c<GRID_COLS;
	}
	function occupiedMap(ignoreId=null) {
		const occ = new Set();
		for (const it of shopState.items) {
			if (it.r==null || it.c==null) continue;
			if (ignoreId && it.id===ignoreId) continue;
			for (const [r,c] of shapeCells(it, it.r, it.c)) { occ.add(r+','+c); }
		}
		return occ;
	}
	function inBoundsShape(item, r, c) {
		for (const [rr, cc] of shapeCells(item, r, c)) {
			if (!inBounds(rr, cc)) return false;
		}
		return true;
	}
	function canPlace(item, r, c) {
		const occ = occupiedMap(item.id);
		for (const [rr,cc] of shapeCells(item, r, c)) {
			if (!inBounds(rr,cc) || occ.has(rr+','+cc)) return false;
		}
		return true;
	}
	function displaceConflicts(item, placeR, placeC) {
		const newCells = new Set(
			shapeCells(item, placeR, placeC).map(([rr, cc]) => rr + ',' + cc)
		);
		for (const other of shopState.items) {
			if (other === item) continue;
			if (other.r == null || other.c == null) continue;

			let overlaps = false;
			for (const [rr, cc] of shapeCells(other, other.r, other.c)) {
				if (newCells.has(rr + ',' + cc)) {
					overlaps = true;
					break;
				}
			}
			if (overlaps) {
				// kick this gun to offer
				other.r = null;
				other.c = null;
			}
		}
	}
	function getShapeBounds(key) {
		const shape = GUN_CONFIG[key].shape || [];
		let maxDR = 0;
		let maxDC = 0;
		for (const [dr, dc] of shape) {
			if (dr > maxDR) maxDR = dr;
			if (dc > maxDC) maxDC = dc;
		}
		return {
			cellCols: maxDC + 1, // horizontal span in cells
			cellRows: maxDR + 1  // vertical span in cells
		};
	}
	function renderPlaced() {
		shopGridEl.querySelectorAll('.gun-placed').forEach(n => n.remove());
		
		for (const it of shopState.items) {
			if (it.r == null || it.c == null) continue;
			
			const { cellCols, cellRows } = getShapeBounds(it.key);
			const shapeWidthPx  = (cellCols - 1) * cellStep + CELL;
			const shapeHeightPx = (cellRows - 1) * cellStep + CELL;
			
			const anchorX = it.c * cellStep;
			const anchorY = it.r * cellStep;
			const shapeCoords = GUN_CONFIG[it.key].shape;
			let maxDR = 0;
			let maxDC = 0;
			for (const [dr, dc] of shapeCoords) {
				if (dr > maxDR) maxDR = dr;
				if (dc > maxDC) maxDC = dc;
			}
			const wrapW = maxDC * cellStep + CELL;
			const wrapH = maxDR * cellStep + CELL;
			
			const wrap = document.createElement('div');
			wrap.className= 'gun-placed';
			wrap.dataset.id = it.id;
			wrap.style.position = 'absolute';
			wrap.style.left = anchorX + 'px';
			wrap.style.top = anchorY + 'px';
			wrap.style.width = wrapW + 'px';
			wrap.style.height = wrapH + 'px';
			wrap.style.pointerEvents = 'auto'; // so we can drag it
			
			for (const [dr,dc] of GUN_CONFIG[it.key].shape){
				const cell = document.createElement('div');
				cell.className = 'p-cell';
				cell.dataset.dr = dr;
				cell.dataset.dc = dc;
				cell.style.position = 'absolute';
				cell.style.left = (dc * cellStep) + 'px';
				cell.style.top = (dr * cellStep) + 'px';
				cell.style.width = CELL + 'px';
				cell.style.height = CELL + 'px';
				cell.style.backgroundImage = "url('src/img/UI_shop_slot_background_tier_" + it.tier + ".png')";
				cell.style.backgroundSize = '100% 100%';
				cell.style.backgroundRepeat = 'no-repeat';
				cell.style.backgroundPosition = 'center';
				cell.style.borderRadius = '0';
				cell.style.boxShadow = 'none';
				wrap.appendChild(cell);
			}
			
			//gun image
			const sprite = document.createElement('img');
			sprite.className = 'gun-sprite';
			sprite.src = 'src/img/item/shop/gun_shop_' + it.key + '.png';
			sprite.style.width  = shapeWidthPx  + 'px';
			sprite.style.height = shapeHeightPx + 'px';
			sprite.style.objectFit = 'contain';
			wrap.appendChild(sprite);
			
			appendOutlineBorderFull(wrap, GUN_CONFIG[it.key].shape);
			wrap.addEventListener('pointerdown', e => {
				if(document.getElementById('shopGrid').classList.contains('viewMode')) return;
				onDragStart(e, it, 'grid', wrap);
			});
			shopGridEl.appendChild(wrap);
		}
		applyMergeHighlights();
	}
	function renderOffer() {
		const shopOfferEl  = document.getElementById('shopOffer');
		if (!shopOfferEl) return;
		shopOfferEl.innerHTML = '';
		
		const offerItems = shopState.items.filter(it => it.r == null && it.c == null);
		updateShopOfferLayout();

		for (const it of shopState.items) {
			// skip items that are placed on the grid already
			if (it.r != null && it.c != null) continue;
			
			// gun offer preview
			const chip = document.createElement('div');
			chip.className = 'gun-chip';
			chip.dataset.id = it.id;
			
			//gun image size calculate
			const { cellCols, cellRows } = getShapeBounds(it.key);
			const cellSize = MINI_CELL;
			const chipWidth  = cellCols * cellSize;
			const chipHeight = cellRows * cellSize;

			chip.style.width  = chipWidth  + 'px';
			chip.style.height = chipHeight + 'px';
			
			for (const [dr,dc] of GUN_CONFIG[it.key].shape) {
				const d = document.createElement('div');
				d.className = 'mini-cell';
				d.style.position = 'absolute';

				// each cell is one MINI_CELL step
				d.style.left   = (dc * cellSize) + 'px';
				d.style.top    = (dr * cellSize) + 'px';
				d.style.width  = cellSize + 'px';
				d.style.height = cellSize + 'px';

				d.style.backgroundImage  = "url('src/img/UI_shop_slot_background_tier_" + it.tier + ".png')";
				d.style.backgroundSize   = '100% 100%';
				d.style.backgroundRepeat = 'no-repeat';
				d.style.backgroundPosition = 'center';
				chip.appendChild(d);
			}
			
			//gun image
			const spriteMini = document.createElement('img');
			spriteMini.className = 'gun-sprite-mini';
			spriteMini.src = 'src/img/item/shop/gun_shop_' + it.key + '.png';
			spriteMini.style.position = 'absolute';
			spriteMini.style.left = '0px';
			spriteMini.style.top = '0px';
			spriteMini.style.width = chipWidth  + 'px';
			spriteMini.style.height = chipHeight + 'px';
			spriteMini.style.objectFit = 'contain';
			spriteMini.style.pointerEvents = 'none';
			chip.appendChild(spriteMini);
			
			appendOutlineBorderMini(chip, GUN_CONFIG[it.key].shape, cellSize);
			chip.addEventListener('pointerdown', e => onDragStart(e, it, 'offer', chip));
			shopOfferEl.appendChild(chip);
		}
		applyMergeHighlights();
	}
	function updateShopOfferLayout() {
		const offerItems = shopState.items.filter(it => it.r == null && it.c == null);
		const count = offerItems.length;
		
		const cols = Math.min(Math.max(count || 1, 1), 5);
		root.style.setProperty('--shop-gun-offer-count', String(cols));

		// scale:
		// 1–3 guns: full size
		// 4–5 guns: slightly smaller
		// 6–10 guns: smaller so 2 rows look good
		let scale = 1;
		if (count > 3 && count <= 5) {
			scale = 0.9;
		} else if (count > 5) {
			scale = 0.8;
		}

		root.style.setProperty('--shop-gun-offer-scale', String(scale));
	}
	function resolveDropOnGrid(item, newR, newC) {
		const overlaps = overlappingItemsAt(item, newR, newC);
		let mergeTarget = null;
		for (const o of overlaps) {
			if (canMergeItems(item, o)) {
				mergeTarget = o;
				break;
			}
		}
		if (mergeTarget) {
			mergeIntoTarget(mergeTarget, item);
			return;
		}
		for (const o of overlaps) {
			o.r = null;
			o.c = null;
		}
		item.r = newR;
		item.c = newC;
	}
	function resolveDropInOffer(e, item) {
		const offerCount = shopState.items.filter(it => it.r == null && it.c == null && it !== item).length;
		const elUnder = document.elementFromPoint(e.clientX, e.clientY);
		const chipEl = elUnder ? elUnder.closest('.gun-chip') : null;

		if (chipEl) {
			const targetId = chipEl.dataset.id;
			const targetItem = shopState.items.find(it => String(it.id) === String(targetId));
			if (targetItem) {
				const isSameObject = (targetItem === item);
				const canMerge = !isSameObject && canMergeItems(item, targetItem);
				
				if (canMerge) {
					const cameFromGridAndWasLast = (dragFrom === 'grid' && countPlaced() <= 1);
					if (!cameFromGridAndWasLast) {
						mergeIntoTarget(targetItem, item);
						return;
					}
				}
				if (dragFrom === 'grid' && offerCount >= num_shop_offer_max_item) {
					item.r = startPos.r;
					item.c = startPos.c;
					return;
				}

				if (dragFrom === 'grid' && countPlaced() <= 1) {
					item.r = startPos.r;
					item.c = startPos.c;
				}
				else {
					item.r = null;
					item.c = null;
				}
				return;
			}
		}
		if (dragFrom === 'grid' && offerCount >= num_shop_offer_max_item) {
			item.r = startPos.r;
			item.c = startPos.c;
		}
		else if (dragFrom === 'grid' && countPlaced() <= 1) {
			item.r = startPos.r;
			item.c = startPos.c;
		}
		else {
			item.r = null;
			item.c = null;
		}
	}
	function buildOutlineSegments(coords, {
		cellStepX,
		cellStepY,
		cellSize,
		borderPx,
		offX,
		offY,
	}) {
		const occ = new Set(coords.map(([r,c]) => r + "," + c));
		const topEdges = new Map();
		const bottomEdges = new Map();
		const leftEdges = new Map();
		const rightEdges = new Map();

		for (const [dr, dc] of coords) {
			if (!occ.has((dr - 1) + "," + dc)) {
				if (!topEdges.has(dr)) topEdges.set(dr, []);
				topEdges.get(dr).push(dc);
			}
			if (!occ.has((dr + 1) + "," + dc)) {
				if (!bottomEdges.has(dr)) bottomEdges.set(dr, []);
				bottomEdges.get(dr).push(dc);
			}
			if (!occ.has(dr + "," + (dc - 1))) {
				if (!leftEdges.has(dc)) leftEdges.set(dc, []);
				leftEdges.get(dc).push(dr);
			}
			if (!occ.has(dr + "," + (dc + 1))) {
				if (!rightEdges.has(dc)) rightEdges.set(dc, []);
				rightEdges.get(dc).push(dr);
			}
		}

		function makeRuns(sortedList) {
			const runs = [];
			if (!sortedList.length) return runs;
			let start = sortedList[0];
			let prev  = sortedList[0];
			for (let i = 1; i < sortedList.length; i++) {
				const v = sortedList[i];
				if (v === prev + 1) {
					prev = v;
				}
				else {
					runs.push([start, prev]);
					start = v;
					prev = v;
				}
			}
			runs.push([start, prev]);
			return runs;
		}

		const segs = [];
		for (const [row, dcs] of topEdges.entries()) {
			const sorted = dcs.slice().sort((a,b)=>a-b);
			const runs = makeRuns(sorted);
			for (const [dcStart, dcEnd] of runs) {
				const leftPx  = offX + dcStart * cellStepX;
				const rightPx = offX + dcEnd * cellStepX + cellSize;
				const cellTopY = offY + row * cellStepY;
				const yPx = cellTopY - borderPx;
				segs.push({
					x: leftPx,
					y: yPx,
					w: rightPx - leftPx,
					h: borderPx,
				});
			}
		}
		for (const [row, dcs] of bottomEdges.entries()) {
			const sorted = dcs.slice().sort((a,b)=>a-b);
			const runs = makeRuns(sorted);
			for (const [dcStart, dcEnd] of runs) {
				const leftPx  = offX + dcStart * cellStepX;
				const rightPx = offX + dcEnd * cellStepX + cellSize;
				const cellBottomY = offY + row * cellStepY + cellSize;
				const yPx = cellBottomY;
				segs.push({
					x: leftPx,
					y: yPx,
					w: rightPx - leftPx,
					h: borderPx,
				});
			}
		}
		for (const [col, drs] of leftEdges.entries()) {
		const sorted = drs.slice().sort((a,b)=>a-b);
			const runs = makeRuns(sorted);
			for (const [drStart, drEnd] of runs) {
				const topPx    = offY + drStart * cellStepY;
				const bottomPx = offY + drEnd   * cellStepY + cellSize;
				const cellLeftX = offX + col * cellStepX;
				const xPx = cellLeftX - borderPx;
				segs.push({
					x: xPx,
					y: topPx,
					w: borderPx,
					h: bottomPx - topPx,
				});
			}
		}
		for (const [col, drs] of rightEdges.entries()) {
			const sorted = drs.slice().sort((a,b)=>a-b);
			const runs = makeRuns(sorted);
			for (const [drStart, drEnd] of runs) {
				const topPx    = offY + drStart * cellStepY;
				const bottomPx = offY + drEnd   * cellStepY + cellSize;
				const cellRightX = offX + col * cellStepX + cellSize;
				const xPx = cellRightX;
				segs.push({
					x: xPx,
					y: topPx,
					w: borderPx,
					h: bottomPx - topPx,
				});
			}
		}
		
		let minR = Infinity, maxR = -Infinity, minC = Infinity, maxC = -Infinity;
		for (const [dr, dc] of coords) {
			if (dr < minR) minR = dr;
			if (dr > maxR) maxR = dr;
			if (dc < minC) minC = dc;
			if (dc > maxC) maxC = dc;
		}

		for (let r = minR - 1; r <= maxR + 1; r++) {
			for (let c = minC - 1; c <= maxC + 1; c++) {
				const hereKey = r + "," + c;
				if (occ.has(hereKey)) continue;

				const up    = occ.has((r-1) + "," + c);
				const down  = occ.has((r+1) + "," + c);
				const left  = occ.has(r + "," + (c-1));
				const right = occ.has(r + "," + (c+1));

				// Up + Left occupied -> outside patch goes UP-LEFT from that corner
				if (up && left && !down && !right) {
					const cornerX = offX + c * cellStepX - borderPx;
					const cornerY = offY + r * cellStepY - borderPx;
					segs.push({
						x: cornerX,
						y: cornerY,
						w: borderPx,
						h: borderPx,
					});
				}
				// Up + Right occupied -> patch goes UP-RIGHT
				if (up && right && !down && !left) {
					const cornerX = offX + c * cellStepX + cellSize;
					const cornerY = offY + r * cellStepY - borderPx;
					segs.push({
						x: cornerX,
						y: cornerY,
						w: borderPx,
						h: borderPx,
					});
				}
				// Down + Left occupied -> patch goes DOWN-LEFT
				if (down && left && !up && !right) {
					const cornerX = offX + c * cellStepX - borderPx;
					const cornerY = offY + r * cellStepY + cellSize;
					segs.push({
						x: cornerX,
						y: cornerY,
						w: borderPx,
						h: borderPx,
					});
				}
				// Down + Right occupied -> patch goes DOWN-RIGHT
				if (down && right && !up && !left) {
					const cornerX = offX + c * cellStepX + cellSize;
					const cornerY = offY + r * cellStepY + cellSize;
					segs.push({
						x: cornerX,
						y: cornerY,
						w: borderPx,
						h: borderPx,
					});
				}
			}
		}
		return segs;
	}
	function appendOutlineBorderFull(container, shapeCoords) {
		const segs = buildOutlineSegments(shapeCoords, {
			cellStepX: CELL + CELL_GAP,
			cellStepY: CELL + CELL_GAP,
			cellSize: CELL,
			borderPx: 2,
			offX: 0,
			offY: 0,
		});

		for (const seg of segs) {
			const edgeDiv = document.createElement('div');
			edgeDiv.style.position = 'absolute';
			edgeDiv.style.left = seg.x + 'px';
			edgeDiv.style.top = seg.y + 'px';
			edgeDiv.style.width = seg.w + 'px';
			edgeDiv.style.height = seg.h + 'px';
			edgeDiv.style.background = '#E7E2DE';
			edgeDiv.style.pointerEvents = 'none';
			edgeDiv.style.zIndex = '10002';
			container.appendChild(edgeDiv);
		}
	}
	function appendOutlineBorderMini(container, shapeCoords, cellSize) {
		const segs = buildOutlineSegments(shapeCoords, {
			cellStepX: cellSize,
			cellStepY: cellSize,
			cellSize: cellSize,
			borderPx: 1,
			offX: 0,
			offY: 0,
		});

		for (const seg of segs) {
			const edgeDiv = document.createElement('div');
			edgeDiv.style.position = 'absolute';
			edgeDiv.style.left = seg.x + 'px';
			edgeDiv.style.top = seg.y + 'px';
			edgeDiv.style.width = seg.w + 'px';
			edgeDiv.style.height = seg.h + 'px';
			edgeDiv.style.background = '#DBD7D4';
			edgeDiv.style.pointerEvents = 'none';
			edgeDiv.style.zIndex = '10002';
			container.appendChild(edgeDiv);
		}
	}
	
	// -------------------- Drag and Drop ----------------------------- //
	function getShapeExtents(item) {
		const shape = GUN_CONFIG[item.key].shape || [];
		let maxDR = 0;
		let maxDC = 0;
		for (const [dr, dc] of shape) {
			if (dr > maxDR) maxDR = dr;
			if (dc > maxDC) maxDC = dc;
		}
		return { maxDR, maxDC };
	}
	function clampPlacementToGrid(item, baseR, baseC) {
		const { maxDR, maxDC } = getShapeExtents(item);

		const maxRowStart = GRID_ROWS - 1 - maxDR;
		const maxColStart = GRID_COLS - 1 - maxDC;

		let r = baseR;
		let c = baseC;

		if (r < 0) r = 0;
		if (c < 0) c = 0;
		if (r > maxRowStart) r = maxRowStart;
		if (c > maxColStart) c = maxColStart;
		
		return { r, c };
	}
	function getPreviewTopLeftPixels(r, c) {
		const gridRect = shopGridEl.getBoundingClientRect();
		return {
			left: gridRect.left + c * cellStep + GHOST_SNAP_OFFSET_X,
			top: gridRect.top  + r * cellStep + GHOST_SNAP_OFFSET_Y
		};
	}
	function positionGhostAtPreview(r, c) {
		if (!ghost) return;
		const { left, top } = getPreviewTopLeftPixels(r, c);
		ghostTargetX = left;
		ghostTargetY = top;
	}

	function positionGhostCenteredOnPointer(pointerX, pointerY) {
		if (!ghost) return;
		ghostTargetX = pointerX - grabOffsetX;
		ghostTargetY = pointerY - grabOffsetY;
	}
	function isInside(el, x, y) {
		const r = el.getBoundingClientRect();
		return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
	}
	function countPlaced(){
		return shopState.items.filter(it => it.r!=null && it.c!=null).length;
	}
	function startGhostAnim() {
		// avoid multiple loops if already running
		if (ghostAnimId != null) return;

		function step() {
			const SMOOTH = 0.25; // smaller = slower, larger = snappier
			ghostCurrX += (ghostTargetX - ghostCurrX) * SMOOTH;
			ghostCurrY += (ghostTargetY - ghostCurrY) * SMOOTH;

			if (ghost) {
				ghost.style.left = ghostCurrX + 'px';
				ghost.style.top  = ghostCurrY + 'px';
			}
			ghostAnimId = requestAnimationFrame(step);
		}
		ghostAnimId = requestAnimationFrame(step);
	}
	function stopGhostAnim() {
		if (ghostAnimId != null) {
			cancelAnimationFrame(ghostAnimId);
			ghostAnimId = null;
		}
	}
	function onDragStart(e, item, from, sourceEl) {
		if (draggingItem) return;
		e.preventDefault();

		activePointerId  = e.pointerId ?? null;
		draggingItem     = item;
		dragFrom         = from;
		draggingSourceEl = sourceEl || null;
		startPos         = { r: item.r, c: item.c };
		
		mergeHighlightSet.clear();
		for (const other of shopState.items) {
			if (other === item) continue;
			if (canMergeItems(item, other)) {
				mergeHighlightSet.add(other.id);
			}
		}
		
		applyMergeHighlights();
		ghost = createGhostFromItem(item);
		ghost.style.transform = 'none';

		if (draggingSourceEl) {
			draggingSourceEl.classList.add('drag-hidden');
		}
		
		const gRect = ghost.getBoundingClientRect();
		grabOffsetX = gRect.width  / 2;
		grabOffsetY = gRect.height / 2;
		
		if (e.target.setPointerCapture && activePointerId != null) {
			try { e.target.setPointerCapture(activePointerId); } catch (_) {}
		}
		
		window.addEventListener('pointermove', onDragMove, { passive: false });
		window.addEventListener('pointerup',   onDragEnd,  { passive: false, once: true });
		
		if (item.r != null && item.c != null) {
			lastSnap = { r: item.r, c: item.c, ok: true };
			showPlacementPreview(item.r, item.c, item, true);
			positionGhostAtPreview(item.r, item.c);
		}
		else {
			if (isInside(shopGridEl, e.clientX, e.clientY)) {
				const snap = snapToGrid(e.clientX, e.clientY);
				const { r: clampedR, c: clampedC } = clampPlacementToGrid(item, snap.r, snap.c);
				lastSnap = { r: clampedR, c: clampedC, ok: true };
				showPlacementPreview(clampedR, clampedC, item, true);
				positionGhostAtPreview(clampedR, clampedC);
			}
			else {
				lastSnap = null;
				hidePlacementPreview();
				positionGhostCenteredOnPointer(e.clientX, e.clientY);
			}
		}

		ghostCurrX = ghostTargetX;
		ghostCurrY = ghostTargetY;
		startGhostAnim();
		makeSfx(`src/sfx/shop/shop_item_pickup_${item.key}.mp3`, { volume: 0.8, pool: 2 })();
	}
	function onDragMove(e) {
		if (activePointerId != null && e.pointerId !== activePointerId) return;
		e.preventDefault();
		if (!draggingItem) return;

		const overGrid = isInside(shopGridEl, e.clientX, e.clientY);

		if (!overGrid) {
			lastSnap = null;
			hidePlacementPreview();
			positionGhostCenteredOnPointer(e.clientX, e.clientY);
			return;
		}
		
		const snap = snapToGrid(e.clientX, e.clientY);
		const { r: clampedR, c: clampedC } = clampPlacementToGrid(draggingItem, snap.r, snap.c);
		lastSnap = { r: clampedR, c: clampedC, ok: true };
		showPlacementPreview(clampedR, clampedC, draggingItem, true);
		
		positionGhostAtPreview(clampedR, clampedC);
	}
	function isInside(el, x, y){
		const r=el.getBoundingClientRect();
		return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
	}
	function snapToGrid(clientX, clientY) {
		const r = shopGridEl.getBoundingClientRect();
		const gx = clientX - r.left;
		const gy = clientY - r.top;
		const c  = Math.floor(gx / cellStep);
		const rr = Math.floor(gy / cellStep);
		return { r: rr, c };
	}
	function onDragEnd(e) {
		if (activePointerId != null && e.pointerId !== activePointerId) return;
		e.preventDefault();
		
		window.removeEventListener('pointermove', onDragMove);
		
		// release pointer capture
		if (e.target.releasePointerCapture && activePointerId != null) {
			try { e.target.releasePointerCapture(activePointerId); } catch (_) {}
		}
		
		activePointerId = null;
		stopGhostAnim();
		
		if (draggingSourceEl) {
			draggingSourceEl.classList.remove('drag-hidden');
		}
		
		if (ghost) {
			ghost.remove();
			ghost = null;
		}
		
		hidePlacementPreview();
		
		const item = draggingItem;
		draggingItem = null;
		shopState.dragging = null;
		
		clearMergeHighlights();

		if (lastSnap && lastSnap.ok) {
			const newR = lastSnap.r;
			const newC = lastSnap.c;
			resolveDropOnGrid(item, newR, newC);
		}
		else {
			resolveDropInOffer(e, item);
		}
		lastSnap = null;
		renderPlaced();
		renderOffer();
		makeSfx(`src/sfx/shop/shop_item_place_${item.key}.mp3`, { volume: 0.8, pool: 2 })();
	}
	function applyTierColor(it) {
		const grad = TIER_COLORS[Math.min(it.tier,4)] || TIER_COLORS[1];
		it.color = grad;
	}
	function getShapeCellsAt(item, baseR, baseC) {
		const shape = GUN_CONFIG[item.key].shape || [];
		const out = [];
		for (const [dr, dc] of shape) {
			out.push([baseR + dr, baseC + dc]);
		}
		return out;
	}
	function getCurrentCells(item) {
		if (item.r == null || item.c == null) return [];
		return getShapeCellsAt(item, item.r, item.c);
	}
	function overlappingItemsAt(item, placeR, placeC) {
		const hits = new Set();
		const newCells = getShapeCellsAt(item, placeR, placeC)
		.map(([rr,cc]) => rr + ',' + cc);
		
		for (const other of shopState.items) {
			if (other === item) continue;
			if (other.r == null || other.c == null) continue; // only placed
			const ocells = getCurrentCells(other);
			for (const [orow, ocol] of ocells) {
				if (newCells.includes(orow + ',' + ocol)) {
					hits.add(other);
					break;
				}
			}
		}
		return [...hits];
	}
	// -------------- Merge -------------- //
	function canMergeItems(a, b) {
		if (!a || !b) return false;
		if (a.key !== b.key) return false;
		if (a.tier !== b.tier) return false;
		if (a.tier >= 4) return false;
		return true;
	}
	function mergeIntoTarget(target, source) {
		target.tier = Math.min(4, target.tier + 1);
		applyTierColor(target);
		
		shopState.items = shopState.items.filter(it => it !== source);
		makeSfx('src/sfx/shop/shop_item_merge.mp3', { volume: 0.8, pool: 2 })();
	}
	// -------------- Glow Animation -------------- //
	function applyMergeHighlights() {
		document.querySelectorAll('.merge-glow').forEach(el => {el.classList.remove('merge-glow');});
		
		for (const id of mergeHighlightSet) {
			const placed = shopGridEl.querySelector(`.gun-placed[data-id="${id}"]`);
			if (placed) placed.classList.add('merge-glow');
			const chip = shopOfferEl.querySelector(`.gun-chip[data-id="${id}"]`);
			if (chip) chip.classList.add('merge-glow');
		}
	}
	function clearMergeHighlights() {
		document.querySelectorAll('.merge-glow').forEach(el => {el.classList.remove('merge-glow');});
		mergeHighlightSet.clear();
	}
	function createGhostFromItem(item) {
		const g = document.createElement('div');
		g.className = 'drag-ghost';
		g.style.zIndex = '10001';
		g.style.pointerEvents = 'none';
		g.style.touchAction = 'none';
		g.style.position = 'fixed';
		
		//gun image size calculate
		const MINI_STEP = MINI_CELL;
		const { cellCols, cellRows } = getShapeBounds(item.key);
		const shapeWidthPx  = (cellCols - 1) * cellStep + CELL;
		const shapeHeightPx = (cellRows - 1) * cellStep + CELL;
		
		for (const [dr, dc] of GUN_CONFIG[item.key].shape) {
			const cell = document.createElement('div');
			cell.className = 'p-cell';
			cell.style.position = 'absolute';
			cell.dataset.dr = dr;
			cell.dataset.dc = dc;
			cell.style.left = (dc * MINI_CELL) + 'px';
			cell.style.top  = (dr * MINI_CELL) + 'px';
			cell.style.width  = MINI_CELL + 'px';
			cell.style.height = MINI_CELL + 'px';
			g.appendChild(cell);
		}
		
		//gun image
		const spriteMini = document.createElement('img');
		spriteMini.className = 'gun-sprite-mini';
		spriteMini.src = 'src/img/item/shop/gun_shop_' + item.key + '.png';
		spriteMini.style.position = 'absolute';
		spriteMini.style.width  = shapeWidthPx  + 'px';
		spriteMini.style.height = shapeHeightPx + 'px';
		spriteMini.style.objectFit = 'contain';
		spriteMini.style.pointerEvents = 'none';
		g.appendChild(spriteMini);
		
		document.body.appendChild(g);
		return g;
	}
	function ensurePreviewWrap() {
		if (!previewWrap) {
			previewWrap = document.createElement('div');
			previewWrap.className = 'placement-preview';
			shopGridEl.appendChild(previewWrap);
		}
	}
	function showPlacementPreview(r, c, item, valid) {
		ensurePreviewWrap();
		previewWrap.innerHTML = '';

		for (const [dr, dc] of GUN_CONFIG[item.key].shape) {
			const cell = document.createElement('div');
			cell.className = 'placement-preview-cell' + (valid ? '' : ' invalid');
			
			const baseLeft = c * (CELL + CELL_GAP);
			const baseTop  = r * (CELL + CELL_GAP);
			cell.style.left = (baseLeft + dc * (CELL + CELL_GAP)) + 'px';
			cell.style.top  = (baseTop  + dr * (CELL + CELL_GAP)) + 'px';
			cell.style.width  = CELL + 'px';
			cell.style.height = CELL + 'px';
			cell.style.position = 'absolute';
			cell.style.backgroundImage = "url('src/img/UI/UI_shop_slot_preview.png')";
			cell.style.backgroundRepeat = 'no-repeat';
			cell.style.backgroundSize = '100% 100%';
			cell.style.backgroundPosition = 'center';
			cell.style.opacity = (valid ? '1' : '0.8');
			previewWrap.appendChild(cell);
		}
		previewWrap.style.display = 'block';
	}
	function hidePlacementPreview() {
		if (previewWrap) {
			previewWrap.style.display = 'none';
		}
	}
	
	// --------------------- Shop Offer --------------------- //
	function pickTierForShop() {
		const bag = [];
		for (const tierStr in SHOP_TIER_CHANCE) {
			const tierNum = parseInt(tierStr, 10);
			const w = SHOP_TIER_CHANCE[tierNum] || 0;
			if (w > 0) {
				bag.push({ tier: tierNum, weight: w });
			}
		}
		
		let total = 0;
		for (const entry of bag) {
			total += entry.weight;
		}
		if (total <= 0) return 1;

		// Roll
		let roll = Math.random() * total;
		for (const entry of bag) {
			if (roll < entry.weight) return entry.tier;
			roll -= entry.weight;
		}
		return 1;
	}
	
	
	// -------------------------- Shop Reroll -------------------------- //
	function hasFreeReroll() {
		return GAME_STATE.shop.reroll_count > 0;
	}
	function canPayForReroll() {
		return GAME_STATE.coins >= GAME_STATE.shop.reroll_price;
	}
	function shop_offer_rerollItem(isButton = false) {
		if (isButton) {
			const hasFree = hasFreeReroll();
			const canPay  = canPayForReroll();
			
			if (!hasFree && !canPay) {
				shop_offer_updateRerollUI();
				SFX_ERROR();
				return;
			}
			
			//charge for reroll
			if (hasFreeReroll()) {
				GAME_STATE.shop.reroll_count -= 1;
			}
			else {
				GAME_STATE.coins -= GAME_STATE.shop.reroll_price;
				GAME_STATE.shop.reroll_price += REROLL_CONFIG.increment;
			}
		}
		shop_offer_addNewOffers();
		renderOffer();
		shop_offer_updateRerollUI();
		
		SFX_BTN_SHOP_REROLL();
	}
	function shop_offer_updateRerollUI() {
		const fmt = n => Number(n).toLocaleString('en-US');
		const labelEl = document.querySelector('#btn_shop_reroll .subtitle-label');
		const valueEl = document.getElementById('subtitle_btn_shop_reroll');
		
		if (hasFreeReroll()) {
			labelEl.classList.remove('is-coin');
			labelEl.textContent = 'Remaining attempt(s):';

			valueEl.textContent = GAME_STATE.shop.reroll_count;
			btnRerollOffer.classList.remove('disabled');
		}
		else {
			labelEl.textContent = '';
			labelEl.classList.add('is-coin');

			valueEl.textContent = `${fmt(GAME_STATE.coins)} / ${fmt(GAME_STATE.shop.reroll_price)}`;

			const disabled = !canPayForReroll();
			btnRerollOffer.classList.toggle('disabled', disabled);
		}
	}
	function shop_offer_addNewOffers(){
		shopState.items = shopState.items.filter(it => it.r != null && it.c != null);
		for (let i = 0; i < num_shop_offer_base_item; i++) {
			shopState.items.push(shop_offer_makeOfferItem());
		}
	}
	function shop_offer_makeOfferItem() {
		const allKeys = Object.keys(GUN_CONFIG);
		const availableKeys = allKeys.filter(k => !GAME_STATE.shop.removal_set.has(k));
		const key = availableKeys[(Math.random() * availableKeys.length) | 0];
		const tier = pickTierForShop();
		const colorPair = TIER_COLORS[tier] || TIER_COLORS[1];

		return {
			id: 'itm_' + Math.random().toString(36).slice(2,8),
			key,
			tier,
			color: colorPair,
			r: null,
			c: null,
		};
	}
	
	
	// ----------------- Shop Weapon Removal ----------------- //
	function update_btn_subtitle_removal() {
		btn_subtitle_removal.forEach(el => {
			el.textContent = String(GAME_STATE.shop.removal_count);
		});
	}
	function openWeaponRemovalOverlay() {
		const offerItems = shopState.items.filter(it => it.r == null && it.c == null);
		if (!offerItems.length || GAME_STATE.shop.removal_count <= 0) {
			SFX_ERROR();
			return;
		}

		weaponRemovalSelectedItem = null;
		update_btn_subtitle_removal();
		renderWeaponRemovalOffer();
		renderWeaponRemovalRemovedList(weaponRemovalRemovedListEl);

		weaponRemovalOverlay.classList.remove('hidden');
	}
	function closeWeaponRemovalOverlay() {
		weaponRemovalOverlay.classList.add('hidden');
		weaponRemovalOverlay.classList.remove('visible');
		weaponRemovalSelectedItem = null;
	}
	if (btnShopWeaponRemovalMain) {
		btnShopWeaponRemovalMain.addEventListener('click', openWeaponRemovalOverlay);
	}
	if (weaponRemovalCancelBtn) {
		weaponRemovalCancelBtn.addEventListener('click', closeWeaponRemovalOverlay);
	}
	function renderWeaponRemovalOffer() {
		if (!weaponRemovalOfferEl) return;
		weaponRemovalOfferEl.innerHTML = '';

		const offerItems = shopState.items.filter(it => it.r == null && it.c == null);

		for (const it of offerItems) {
			const chip = document.createElement('div');
			chip.className = 'gun-chip';
			chip.dataset.id = it.id;

			// --- mini background cells (like shop-offer) ---
			const { cellCols, cellRows } = getShapeBounds(it.key);
			const cellSize = MINI_CELL;
			const chipWidth  = cellCols * cellSize;
			const chipHeight = cellRows * cellSize;
			
			chip.style.width  = chipWidth  + 'px';
			chip.style.height = chipHeight + 'px';

			for (const [dr, dc] of GUN_CONFIG[it.key].shape) {
				const d = document.createElement('div');
				d.className = 'mini-cell';
				d.style.position = 'absolute';

				// each cell is one MINI_CELL step
				d.style.left   = (dc * cellSize) + 'px';
				d.style.top    = (dr * cellSize) + 'px';
				d.style.width  = cellSize + 'px';
				d.style.height = cellSize + 'px';

				d.style.backgroundImage  = "url('src/img/UI_shop_slot_background_tier_" + it.tier + ".png')";
				d.style.backgroundSize   = '100% 100%';
				d.style.backgroundRepeat = 'no-repeat';
				d.style.backgroundPosition = 'center';

				chip.appendChild(d);
			}

			const spriteMini = document.createElement('img');
			spriteMini.className = 'gun-sprite-mini';
			spriteMini.src = 'src/img/item/shop/gun_shop_' + it.key + '.png';
			spriteMini.style.position = 'absolute';
			spriteMini.style.left   = '0px';
			spriteMini.style.top    = '0px';
			spriteMini.style.width  = chipWidth  + 'px';
			spriteMini.style.height = chipHeight + 'px';
			spriteMini.style.objectFit = 'contain';
			spriteMini.style.pointerEvents = 'none';

			chip.appendChild(spriteMini);

			// selection behaviour
			chip.addEventListener('click', () => {
				weaponRemovalSelectedItem = it;
				// clear others
				weaponRemovalOfferEl.querySelectorAll('.gun-chip').forEach(el => {
					el.classList.remove('weapon-removal-selected');
				});
				chip.classList.add('weapon-removal-selected');
			});

			weaponRemovalOfferEl.appendChild(chip);
		}
	}
	function renderWeaponRemovalRemovedList(elementId) {
		if (!elementId) return;
		elementId.innerHTML = '';
		
		const keysAll = Array.from(GAME_STATE.shop.removal_set);
		const count = Math.min(keysAll.length, shop_removal_max_use);
		
		if (!count) return; // 0 removal
		
		let rowScale = 1;
		if (count > 3 && count <= 5) {
			rowScale = 0.8;
		}
		
		for (let i = 0; i < count; i++) {
			const key = keysAll[i];

			const itemDiv = document.createElement('div');
			itemDiv.className = 'weapon-removal-removed-item';
			itemDiv.style.transform = `scale(${rowScale})`;
			
			const default_tier = 1;
			const { cellCols, cellRows } = getShapeBounds(key);

			const BASE_VISIBLE_CELLS = 3;
			const maxDim = Math.max(cellCols, cellRows);
			const shapeScale = maxDim > BASE_VISIBLE_CELLS ? BASE_VISIBLE_CELLS / maxDim : 1;

			const miniCell = MINI_CELL * shapeScale;
			const miniWidthPx  = cellCols * miniCell;
			const miniHeightPx = cellRows * miniCell;
			
			const OFFSET_X = 15;
			const OFFSET_Y = 20;
			
			for (const [dr, dc] of GUN_CONFIG[key].shape) {
				const d = document.createElement('div');
				d.className = 'mini-cell';
				d.style.left = (OFFSET_X + dc * miniCell) + 'px';
				d.style.top = (OFFSET_Y + dr * miniCell) + 'px';
				d.style.width  = miniCell + 'px';
				d.style.height = miniCell + 'px';
				d.style.backgroundImage = "url('src/img/UI_shop_slot_background_tier_" + default_tier + ".png')";
				d.style.backgroundSize = '100% 100%';
				d.style.backgroundRepeat = 'no-repeat';
				d.style.backgroundPosition = 'center';
				itemDiv.appendChild(d);
			}

			const spriteMini = document.createElement('img');
			spriteMini.className = 'gun-sprite-mini';
			spriteMini.src = 'src/img/item/shop/gun_shop_' + key + '.png';
			spriteMini.style.left = OFFSET_X + 'px';
			spriteMini.style.top = OFFSET_Y + 'px';
			spriteMini.style.width = miniWidthPx  + 'px';
			spriteMini.style.height = miniHeightPx + 'px';
			spriteMini.style.position = 'absolute';
			spriteMini.style.objectFit = 'contain';
			itemDiv.appendChild(spriteMini);

			elementId.appendChild(itemDiv);
		}
	}
	weaponRemovalConfirmBtn.addEventListener('click', () => {
		if (GAME_STATE.shop.removal_count <= 0) {
			return;// no uses left
		}
		if (!weaponRemovalSelectedItem) {
			return;// nothing selected
		}

		const id = weaponRemovalSelectedItem.id;
		const key = weaponRemovalSelectedItem.key;
		
		if (!GAME_STATE.shop.removal_set.has(key)) {
			// add
			GAME_STATE.shop.removal_set.add(key);
			
			// consume a use
			GAME_STATE.shop.removal_count -= 1;
			update_btn_subtitle_removal();
		}
		
		// remove item
		shopState.items = shopState.items.filter(it => {
			if (it.id !== id) return true;
			return false;
		});

		// re-render shop offer + this overlay’s offer mirror
		renderOffer();
		renderWeaponRemovalOffer();
		renderWeaponRemovalRemovedList(weaponRemovalRemovedListEl);
		
		closeWeaponRemovalOverlay();
	});


	
	
	// -------------------------- Open / Close Shop -------------------------- //
	function openShopOverlay(nextWave, nextCount, initial=false, view=false) {
		if (!GAME_STATE) {
			// Queue until game GAME_STATE exists
			window.__pendingShopCalls = window.__pendingShopCalls || [];
			window.__pendingShopCalls.push([nextWave, nextCount, initial]);
			if (!window.__shopWaiter2) {
				window.__shopWaiter2 = true;
				const wait = () => {
					if (GAME_STATE && typeof window.openShopOverlay === 'function') {
						const q = window.__pendingShopCalls.splice(0);
						for (const a of q) window.openShopOverlay.apply(null, a);
					}
					else {
						requestAnimationFrame(wait);
					}
				};
				requestAnimationFrame(wait);
			}
			return;
		}
		
		shopState.pending = { n: nextWave, count: nextCount };
		GAME_STATE.paused = true;
		SFX_PAUSE_BGM();
		SFX_OVERLAY_APPEAR_SHOP();
		
		if (initial) {
			shopState.items = [];
			const starter = {
				id: 'itm_starter',
				key: 'submachinegun',
				tier: 1,
				color: TIER_COLORS[1],
				r: 0,
				c: 0
			};
			shopState.items.push(starter);
		}
		
		renderPlaced();
		shopOverlay.classList.remove('hidden');
		
		//View Mode / Shop Mode
		if(!view) shop_offer_rerollItem(false);
		document.querySelector('.shop-panel-body').classList.toggle('viewMode', view);
		document.getElementById('shopGrid').classList.toggle('viewMode',view); //If "Viewing Inventory" or "Shopping"
		document.getElementById('shopLayoutOffer').classList.toggle('viewMode',view);
		document.getElementById('btn_shop_close').classList.toggle('viewMode',view);
		document.getElementById('btnShop_weaponRemoval').classList.toggle('viewMode',view);
		document.getElementById('btn_shop_reroll').classList.toggle('viewMode',view);
		document.getElementById('btnShop_close_view').classList.toggle('viewMode',!view);
	}
	function closeShopOverlayAndStart() {
		if (!GAME_STATE) return;

		// Collect guns that are placed on shop grid
		const placed = shopState.items.filter(it => it.r != null && it.c != null);
		if (placed.length < 1) {return;}

		// Convert placed guns into in game
		GAME_STATE.weapons = placed.map(it => {return makeWeaponInstance(it.key, it.tier);});
		GAME_STATE.inventory = new Array(16).fill(null);
		for (let i = 0; i < placed.length && i < 16; i++) {
			GAME_STATE.inventory[i] = {
				key: placed[i].key,
				tier: placed[i].tier
			};
		}
		renderInventory();

		const shopOverlayEl = document.getElementById('shopOverlay');
		if (shopOverlayEl) {shopOverlayEl.classList.add('hidden');}

		const nextWaveNum   = (shopState.pending && shopState.pending.n) || (GAME_STATE.wave + 1);
		const nextWaveCount = (shopState.pending && shopState.pending.count) || 1;
		startWave(nextWaveNum, nextWaveCount);

		//close shop
		const traitsStillPending =(GAME_STATE.traitOverlayOpen === true) || ((GAME_STATE.traitQueue || 0) > 0);
		if (traitsStillPending) {
			GAME_STATE.paused = true;
		}
		else {
			GAME_STATE.paused = false;
			SFX_PLAY_BGM();
		}
		SFX_BTN_SHOP_CLOSE();
	}
	function closeViewInventory() {
		document.getElementById('shopOverlay').classList.add('hidden');
	}
	
	
	//Buttons
	btn_shop_close?.addEventListener('click', closeShopOverlayAndStart);
	document.getElementById('btnShop_close_view')?.addEventListener('click', closeViewInventory);
	btnRerollOffer?.addEventListener('click', ()=>{ shop_offer_rerollItem(true); });
	
	
	
	if (Array.isArray(window.__pendingShopCalls)) {
		const q = window.__pendingShopCalls.splice(0);
		for (const a of q) openShopOverlay.apply(null, a);
	}
	
	//Open Shop on start / restart
	let openedOnce = false;
	requestAnimationFrame(()=>{
		if (!openedOnce && GAME_STATE && GAME_STATE.wave>=1 && ((GAME_STATE.weapons||[]).length||0)===1) {
			openedOnce=true;
		}
	});
	
	
	//Bridge
	try {
		window.openShopOverlay = openShopOverlay;
		window.renderWeaponRemovalRemovedList = renderWeaponRemovalRemovedList;
	} catch(_) {}
})();

</script>
</body>
</html>