<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rogue-like Gun Mini-Game â€” v8.4.2</title>
<style>
  :root {
    --bg: #0b0f1a;
    --panel: #101827;
    --text: #e5e7eb;
    --muted: #94a3b8;
    --accent: #22c55e;
    --danger: #ef4444;
    --canvas-border: #1f2937;
    --track: #0f172a;
    --canvas-w: 400px;
    --canvas-h: 500px;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial;
    background: linear-gradient(180deg, #0b0f1a 0%, #0e1526 100%);
    color: var(--text);
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 24px;
  }
  .game-frame {
    display: inline-block;
    background: rgba(16,24,39,0.75);
    border: 1px solid #1f2937;
    border-radius: 14px;
    padding: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.45);
    max-width: calc(var(--canvas-w) + 24px);
  }
  .game-shell { width: var(--canvas-w); max-width: 100%; }
  .hud {
    display: grid;
    grid-template-columns: auto 1fr auto;
    align-items: center;
    gap: 12px;
    background: var(--panel);
    border: 1px solid #1f2937;
    border-radius: 12px;
    padding: 10px 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.25);
    margin-bottom: 10px;
  }
  .hud .left { display: flex; align-items: center; gap: 8px; min-height: 28px; font-weight: 700; letter-spacing: .2px; }
  .hud .right { display: flex; align-items: center; gap: 8px; min-height: 28px; justify-content: flex-end; }
  .hud .center { display: grid; grid-template-rows: auto auto; gap: 6px; align-items: center; justify-items: center; padding: 2px 0; }
  .hud .stat { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; background: #0f172a; border: 1px solid #1e293b; border-radius: 999px; font-size: 12px; line-height: 1; }
  #levelStat, #waveStat { border: none; }
  .hud .stat.two-line { flex-direction: column; align-items: center; gap: 2px; text-align: center; line-height: 1.1; min-width: 64px; }
  .hud .stat.two-line .label { font-size: 11px; color: var(--muted); }
  .hud .stat.two-line .num { font-size: 13px; font-weight: 800; color: var(--text); }
  .hud .exp-row { display: grid; grid-template-columns: auto 1fr; gap: 8px; align-items: center; width: 100%; }
  .exp-track { position: relative; height: 14px; border-radius: 999px; background: var(--track); border: 1px solid #1e293b; overflow: hidden; }
  .exp-fill { position: absolute; top:0; left:0; height:100%; width:0%; background: linear-gradient(90deg,#22c55e,#16a34a); transition: width .2s ease; }
  .exp-text { position: absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:11px; color:#e5e7eb; text-shadow:0 1px 2px rgba(0,0,0,.4); pointer-events:none; }
  .hud .meta-row { display:flex; align-items:center; justify-content:center; gap:10px; }
  .hud .meta-row .stat { min-width:86px; justify-content:center; }
  .hud button { background:#111827; border:1px solid #1f2937; color:var(--text); padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600; }
  .hud button:hover { background:#0b1220; transform: translateY(-1px); }
  .hud button:disabled { opacity:.5; cursor:not-allowed; filter:grayscale(.2); transform:none; }

  .stage-wrap { display:flex; align-items:center; justify-content:center; padding:10px 0 8px; }
  .stage {
    width: var(--canvas-w); height: var(--canvas-h); border-radius: 12px; border: 1px solid var(--canvas-border);
    background: radial-gradient(100% 100% at 50% 0%, #0d1b2a 0%, #0b1220 40%, #0a0f1a 100%);
    position: relative; box-shadow: inset 0 0 40px rgba(0,0,0,0.45);
  }
  canvas { display:block; width:var(--canvas-w); height:var(--canvas-h); border-radius:12px; }

  /* Barricade HP */
  .hp-container { margin-top: 10px; }
  .hp-bar { position:relative; width:100%; height:18px; border-radius:999px; background:transparent; overflow:hidden; border:none; }
  .hp-bar .fill { position:absolute; top:0; left:0; height:100%; width:100%; background: linear-gradient(90deg, var(--danger), #f43f5e); border-radius:999px; transition: width .2s ease; }
  .hp-bar .text { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:12px; color:white; text-shadow:0 1px 2px rgba(0,0,0,.6); pointer-events:none; }

  /* Overlay */
  .overlay { position:absolute; inset:0; background:rgba(0,0,0,0.55); display:none; align-items:center; justify-content:center; border-radius:12px; z-index:2; }
  .overlay.show { display:flex; }
  .overlay .panel { background:#0b1220; border:1px solid #1f2937; border-radius:14px; padding:18px; text-align:center; width:80%; max-width:320px; box-shadow:0 10px 40px rgba(0,0,0,0.4); }
  .overlay .actions { display:flex; gap:10px; justify-content:center; }
  .overlay .actions button { background:#111827; border:1px solid #1f2937; color:var(--text); padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700; }
  .overlay .actions button:hover { filter: brightness(1.1); transform: translateY(-1px); }
  .overlay .actions button.primary { background:#14532d; border-color:#166534; }

  /* Inventory */
  .inventory-wrap { margin-top:10px; background:#101827; border:1px solid #1f2937; border-radius:12px; padding:10px; }
  .inventory-grid { display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(2,1fr); gap:8px; }
  .slot { position:relative; aspect-ratio:1/1; border:1px dashed #334155; border-radius:10px; background:#0b1220; display:grid; place-items:center; overflow:hidden; }
  .slot.filled { border-style:solid; border-color:#475569; background: radial-gradient(120% 120% at 100% 0%, rgba(124,58,237,0.25) 0%, rgba(2,6,23,0) 60%), #0b1220; }
  .slot .label { font-size:12px; color:#e5e7eb; padding:2px 6px; border-radius:999px; background: rgba(2,6,23,0.75); border:1px solid #1e293b; }

  /* Boss warning banner */
  .warn-banner {
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    padding: 6px 12px;
    background: rgba(220,38,38,0.6);
    color: #ffffff;
    border: 1px solid rgba(220,38,38,0.85);
    border-radius: 10px;
    font-weight: 900;
    letter-spacing: 1px;
    text-transform: uppercase;
    pointer-events: none;
    backdrop-filter: blur(2px);
    z-index: 3;
    opacity: 0;
    text-shadow: 0 1px 2px rgba(0,0,0,0.45);
  }
  .warn-banner.show { opacity: 1; }
  @keyframes warnPulse { 0% { opacity: 0; } 30% { opacity: 1; } 70% { opacity: 1; } 100% { opacity: 0; } }
</style>
</head>
<body>
  <div class="game-frame">
    <div class="game-shell">
      <!-- Top HUD -->
      <div class="hud" id="topHUD">
        <div class="left">
          <div class="stat two-line" id="waveStat">
            <div class="label">Waves</div>
            <div class="num" id="waveNum">1</div>
          </div>
        </div>
        <div class="center">
          <div class="exp-row">
            <div class="stat" id="levelStat">Lv. 1</div>
            <div class="exp-track" aria-label="Experience">
              <div class="exp-fill" id="expFill" style="width:0%"></div>
              <div class="exp-text" id="expText">0 / 50</div>
            </div>
          </div>
          <div class="meta-row">
            <div class="stat" id="coinStat">ðŸª™ 0</div>
            <div class="stat" id="scoreStat">Score 0</div>
          </div>
        </div>
        <div class="right">
          <button id="speedBtn" aria-label="Game speed"><strong>x1</strong></button>
          <button id="pauseBtn" aria-label="Pause or resume"><strong>||</strong></button>
        </div>
      </div>

      <!-- Battlefield -->
      <div class="stage-wrap">
        <div class="stage">
          <canvas id="game" width="400" height="500"></canvas>

          <!-- Boss warning banner -->
          <div id="bossWarn" class="warn-banner">BOSS APPROACHING</div>

          <div class="overlay" id="overlay">
            <div class="panel">
              <h2 id="overlayTitle">Paused</h2>
              <p id="overlaySubtitle">Take a breather.</p>
              <div class="actions">
                <button id="resumeBtn" class="primary"><strong>â–¶ï¸Ž</strong></button>
                <button id="restartBtn"><strong>Restart</strong></button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Barricade HP -->
      <div class="hp-container">
        <div class="hp-bar" id="hpBar">
          <div class="fill" id="hpFill"></div>
          <div class="text" id="hpText">100%</div>
        </div>
      </div>

      <!-- Inventory -->
      <div class="inventory-wrap">
        <div class="inventory-grid" id="inventoryGrid"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Config =====
  const W = 400, H = 500;
  const BARRICADE_Y = H - 50;
  const BARRICADE_HP_MAX = 500;

  const CURRENT_WAVE = 1;
  const WAVE_1_COUNT = 8;
  const WAVE_INCREASE = 1.01;

  const GROUPS_PER_WAVE = 5;
  const GROUP_INTERVAL_BASE = 20.0;
  const MOB_INTERVAL_BASE = 0.50;
  const MOB_INTERVAL_MIN  = 0.30;
  const MOB_INTERVAL_DECAY_PER_WAVE = 0.3;

  const CONTACT_DAMAGE_INTERVAL = 3.0;

  // Banner + spacing config
  const BOSS_WARN_FLASHES = 2;
  const BOSS_WARN_TOTAL_DURATION = 2.8;
  const BOSS_MINI_TO_BOSS_INTERVAL = 0.6;

  const MOB_A = { name: "Mob A", hp: 50, exp: 10, speed: 10, dps: 20, size: 30, coin: 100, score: 100 };
  const MINI_BOSS_A = { name: "Mini-boss Type A", hp: 500, exp: 100, speed: 8, dps: 30, size: 50, coin: 500, score: 500, tier: "mini" };
  const BOSS_A = { name: "Boss Type A", hp: 1000, exp: 1000, speed: 5, dps: 50, size: 70, coin: 1000, score: 1000, tier: "boss" };

  const GUN_A = { name: "Gun A", range: 320, bulletsPerUse: 6, timeBetweenBullets: 0.1, damage: 18, postUseCooldown: (5/2), bulletSpeed: 200 };

  // ===== State =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const resumeBtn = document.getElementById('resumeBtn');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const speedBtn = document.getElementById('speedBtn');
  const bossWarn = document.getElementById('bossWarn');

  const waveNumEl = document.getElementById('waveNum');
  const levelStat = document.getElementById('levelStat');
  const expFill = document.getElementById('expFill');
  const expText = document.getElementById('expText');
  const coinStat = document.getElementById('coinStat');
  const scoreStat = document.getElementById('scoreStat');
  const invGrid = document.getElementById('inventoryGrid');

  const SPEED_STORAGE_KEY = 'rlg_speed_v1';

  const state = {
    paused: false,
    gameOver: false,
    wave: 1,

    toSpawn: 0,
    enemies: [],
    bullets: [],

    coins: 0,
    score: 0,
    kills: 0,

    player: {
      x: W/2, y: H - 12, size: 16,
      gun: GUN_A, level: 1, exp: 0, expToNext: 50,
      mode: 'idle', burstLeft: 0, timer: 0
    },

    speedMult: 1,
    inventory: new Array(16).fill(null),

    groupIndex: 0,
    groupSizes: [],
    groupMobIndex: 0,
    groupIntervalTimer: 0,
    mobIntervalTimer: 0,
    mobIntervalWave: MOB_INTERVAL_BASE,

    specialsQueued: { mini: false, boss: false },
    specialsSpawned: false,

    specialsProgress: 0,
    specialsTimer: 0
  };

  // ===== Utilities =====
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const randRange = (min,max)=>Math.random()*(max-min)+min;
  const dist2 = (x1,y1,x2,y2)=>{ const dx=x2-x1, dy=y2-y1; return dx*dx+dy*dy; };

  function waveCountFor(n) {
    let c = WAVE_1_COUNT;
    for (let i = 1; i < n; i++) c = Math.max(1, Math.ceil(c * WAVE_INCREASE));
    return c;
  }

  function splitIntoGroups(total, groups) {
    const sizes = new Array(groups).fill(0);
    if (total <= 0) return sizes;
    const base = Math.floor(total / groups);
    let rem = total - base * groups;
    for (let i = 0; i < groups; i++) sizes[i] = base;
    while (rem-- > 0) sizes[Math.floor(Math.random()*groups)]++;
    for (let i = 0; i < groups; i++) if (sizes[i] === 0 && total >= groups) sizes[i] = 1;
    let sum = sizes.reduce((a,b)=>a+b,0);
    while (sum > total) { const i = sizes.findIndex(s=>s>1); sizes[i]--; sum--; }
    return sizes;
  }

  // ===== Entities =====
  class Mob {
    constructor(type, x, yStart) {
      this.type = type;
      this.x = x;
      this.y = yStart;
      this.w = type.size;
      this.h = type.size;
      this.hp = type.hp;
      this.contact = false;
      this.contactTimer = 0;
      this.dead = false;
      this.tookDamage = false;
    }
    get cx() { return this.x + this.w/2; }
    get cy() { return this.y + this.h/2; }

    update(dt) {
      if (this.dead) return;
      if (!this.contact) {
        this.y += this.type.speed * dt;
        if (this.y + this.h >= BARRICADE_Y) {
          this.y = BARRICADE_Y - this.h;
          this.contact = true;
          this.contactTimer = 0;
        }
      } else {
        this.contactTimer += dt;
        while (this.contactTimer >= CONTACT_DAMAGE_INTERVAL) {
          this.contactTimer -= CONTACT_DAMAGE_INTERVAL;
          applyBarrageDamage(this.type.dps);
        }
      }
    }

    hit(dmg) {
      if (this.dead) return;
      this.hp -= dmg;
      if (this.type.tier) this.tookDamage = true;
      if (this.hp <= 0) {
        this.dead = true;
        onMobKilled(this);
      }
    }

    draw(ctx) {
      if (this.dead) return;
      ctx.save();
      if (this.type.tier === "boss")      { ctx.fillStyle = '#ef4444'; ctx.strokeStyle = '#b91c1c'; }
      else if (this.type.tier === "mini") { ctx.fillStyle = '#f59e0b'; ctx.strokeStyle = '#b45309'; }
      else                                { ctx.fillStyle = '#22d3ee'; ctx.strokeStyle = '#0ea5b7'; }
      ctx.lineWidth = 1.5;
      roundRect(ctx, this.x, this.y, this.w, this.h, 6);
      ctx.fill(); ctx.stroke();

      if (this.type.tier && this.tookDamage) {
        const ratio = clamp(this.hp / this.type.hp, 0, 1);
        const barW = this.w, barH = 4;
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(this.x, this.y - 6, barW, barH);
        ctx.fillStyle = '#fca5a5';
        ctx.fillRect(this.x, this.y - 6, barW * ratio, barH);
      }
      ctx.restore();
    }
  }

  class Bullet {
    constructor(x, y, dirX, dirY, speed, dmg) {
      const len = Math.hypot(dirX, dirY) || 1;
      this.vx = (dirX/len) * speed;
      this.vy = (dirY/len) * speed;
      this.x = x; this.y = y;
      this.r = 3; this.dmg = dmg;
      this.dead = false;
    }
    update(dt) {
      if (this.dead) return;
      this.x += this.vx * dt;
      this.y += this.vy * dt;

      if (this.x < -12 || this.x > W + 12 || this.y < -12 || this.y > H + 12) {
        this.dead = true;
        return;
      }
      for (const m of state.enemies) {
        if (m.dead) continue;
        const cx = clamp(this.x, m.x, m.x + m.w);
        const cy = clamp(this.y, m.y, m.y + m.h);
        const dx = this.x - cx, dy = this.y - cy;
        if (dx*dx + dy*dy <= this.r*this.r) { m.hit(this.dmg); this.dead = true; break; }
      }
    }
    draw(ctx) {
      if (this.dead) return;
      ctx.save();
      ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fillStyle = '#fbbf24'; ctx.fill();
      ctx.shadowColor = '#fde68a'; ctx.shadowBlur = 8;
      ctx.restore();
    }
  }

  // Player rendering
  function drawSoldier(ctx) {
    const p = state.player;
    ctx.save();
    ctx.translate(p.x, p.y);
    // body
    ctx.fillStyle = '#a78bfa';
    ctx.strokeStyle = '#7c3aed';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, -p.size);
    ctx.lineTo(p.size * 0.9, p.size);
    ctx.lineTo(-p.size * 0.9, p.size);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // barrel aims at nearest target
    const t = findClosestInRange();
    if (t) {
      const dx = t.cx - p.x, dy = t.cy - p.y;
      const len = Math.hypot(dx, dy) || 1;
      const ux = dx/len, uy = dy/len;
      ctx.beginPath();
      ctx.moveTo(0, -p.size * 0.5);
      ctx.lineTo(ux * 18, uy * 18 - p.size * 0.5);
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 3;
      ctx.stroke();
    }
    ctx.restore();
  }

  // Helpers
  function roundRect(ctx,x,y,w,h,r){ const m=Math.min(w,h)/2; r=Math.min(r,m);
    ctx.beginPath(); ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  }

  // ===== Visual helpers (re-added) =====
  function drawBackground(ctx) {
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = '#93c5fd';
    ctx.lineWidth = 1;
    for (let x=0; x<=W; x+=40) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for (let y=0; y<=H; y+=40) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.restore();
  }
  function drawRange(ctx) {
    const p = state.player;
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#22c55e';
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.gun.range, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  function drawBarrage(ctx) {
    ctx.save();
    const y = BARRICADE_Y;
    ctx.strokeStyle = 'rgba(148,163,184,0.9)';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(12,y);
    ctx.lineTo(W-12,y);
    ctx.stroke();
    ctx.fillStyle = '#475569';
    for (let x=12; x<=W-12; x+=50) ctx.fillRect(x-2, y-12, 4, 12);
    ctx.restore();
  }

  function applyBarrageDamage(dmg) {
    if (state.gameOver) return;
    const maxHP = BARRICADE_HP_MAX;
    const bar = document.getElementById('hpFill');
    const txt = document.getElementById('hpText');
    state.barricadeHP = (state.barricadeHP ?? maxHP) - dmg;
    state.barricadeHP = clamp(state.barricadeHP, 0, maxHP);
    const pct = Math.round((state.barricadeHP / maxHP) * 100);
    bar.style.width = pct + '%'; txt.textContent = pct + '%';
    if (state.barricadeHP <= 0) gameOver();
  }

  function onMobKilled(m) {
    state.kills++;
    state.coins += m.type.coin || 0;
    state.score += m.type.score || 0;
    coinStat.textContent = `ðŸª™ ${state.coins}`;
    scoreStat.textContent = `Score ${state.score}`;
    state.player.exp += m.type.exp;
    while (state.player.exp >= state.player.expToNext) {
      state.player.exp -= state.player.expToNext;
      state.player.level += 1;
      state.player.expToNext = Math.ceil(state.player.expToNext * 1.3);
    }
    levelStat.textContent = `Lv. ${state.player.level}`;
    expText.textContent = `${state.player.exp} / ${state.player.expToNext}`;
    const pct = Math.round((state.player.exp / state.player.expToNext) * 100);
    expFill.style.width = pct + '%';
  }

  function findClosestInRange() {
    const p = state.player;
    const r2 = p.gun.range * p.gun.range;
    let best=null, bestD2=Infinity;
    for (const m of state.enemies) {
      if (m.dead) continue;
      const d2 = dist2(p.x, p.y, m.cx, m.cy);
      if (d2 <= r2 && d2 < bestD2) { bestD2 = d2; best = m; }
    }
    return best;
  }

  function updateSoldier(dt) {
    const p = state.player; p.timer -= dt;
    if (p.mode === 'idle') {
      const t = findClosestInRange();
      if (t) { p.mode='burst'; p.burstLeft=p.gun.bulletsPerUse; p.timer=0; }
    } else if (p.mode === 'burst') {
      while (p.burstLeft > 0 && p.timer <= 0) {
        const t = findClosestInRange();
        if (t) {
          state.bullets.push(new Bullet(
            p.x, p.y - p.size*0.6,
            t.cx - p.x, t.cy - p.y,
            p.gun.bulletSpeed, p.gun.damage
          ));
        }
        p.burstLeft--; p.timer += p.gun.timeBetweenBullets;
      }
      if (p.burstLeft === 0 && p.timer <= 0) { p.mode='cooldown'; p.timer=p.gun.postUseCooldown; }
    } else if (p.mode === 'cooldown') {
      if (p.timer <= 0) p.mode='idle';
    }
  }

  // ===== Spawn System =====
  function computeMobIntervalForWave(wave) {
    const t = Math.pow(MOB_INTERVAL_DECAY_PER_WAVE, Math.max(0, wave-1));
    return clamp(MOB_INTERVAL_BASE * t, MOB_INTERVAL_MIN, MOB_INTERVAL_BASE);
  }

  function startWave(n, totalCount) {
    state.wave = n; waveNumEl.textContent = n;
    state.toSpawn = totalCount;
    state.groupIndex = 0;
    state.groupMobIndex = 0;
    state.specialsSpawned = false;
    state.specialsProgress = 0;
    state.specialsTimer = 0;
    state.groupIntervalTimer = 0;
    state.mobIntervalWave = computeMobIntervalForWave(n);
    state.mobIntervalTimer = 0;
    state.groupSizes = splitIntoGroups(totalCount, GROUPS_PER_WAVE);
    state.specialsQueued.mini = (n % 5 === 0);
    state.specialsQueued.boss = (n % 10 === 0);
    showToast(`Wave ${n}`, `Groups: ${GROUPS_PER_WAVE} â€¢ Mobs: ${totalCount} â€¢ Mob interval: ${state.mobIntervalWave.toFixed(2)}s`);
  }

  function spawnOneNormalMob() {
    const s = MOB_A.size;
    const x = clamp(randRange(0, W - s), 0, W - s);
    const y = -s - randRange(20, 160);
    const m = new Mob(MOB_A, x, y);
    state.enemies.push(m);
  }

  function spawnSpecial(type) {
    const s = type.size;
    const x = clamp(randRange(0, W - s), 0, W - s);
    const y = -s - randRange(30, 160);
    state.enemies.push(new Mob(type, x, y));
  }

  function showBossWarning(text = "BOSS APPROACHING") {
    bossWarn.textContent = text;
    bossWarn.classList.add('show');
    const per = Math.max(0.1, BOSS_WARN_TOTAL_DURATION / Math.max(1, BOSS_WARN_FLASHES));
    bossWarn.style.animation = 'none'; void bossWarn.offsetWidth;
    bossWarn.style.animation = `warnPulse ${per}s ease-in-out ${Math.max(1, BOSS_WARN_FLASHES)}`;
    clearTimeout(bossWarn._hideTO);
    bossWarn._hideTO = setTimeout(()=>{ bossWarn.classList.remove('show'); bossWarn.style.animation='none'; }, Math.max(0, BOSS_WARN_TOTAL_DURATION)*1000 + 50);
  }

  function updateSpawning(dt) {
    if (state.groupIndex >= GROUPS_PER_WAVE) return;

    if (state.groupMobIndex === 0 && state.groupIndex > 0 && state.groupIntervalTimer > 0) {
      state.groupIntervalTimer -= dt;
      return;
    }

    const isLastGroup = (state.groupIndex === GROUPS_PER_WAVE - 1);
    const groupSize = state.groupSizes[state.groupIndex] || 0;

    if (isLastGroup && (state.specialsQueued.mini || state.specialsQueued.boss) && !state.specialsSpawned) {
      if (state.specialsProgress === 0) {
        if (state.specialsQueued.boss) showBossWarning();
        if (state.specialsQueued.mini) {
          spawnSpecial(MINI_BOSS_A);
          state.specialsProgress = 1;
          if (state.specialsQueued.boss) {
            state.specialsTimer = BOSS_MINI_TO_BOSS_INTERVAL;
            return;
          } else {
            state.specialsSpawned = true;
          }
        } else {
          if (state.specialsQueued.boss) spawnSpecial(BOSS_A);
          state.specialsSpawned = true;
          state.specialsProgress = 2;
        }
      } else if (state.specialsProgress === 1 && state.specialsQueued.boss) {
        state.specialsTimer -= dt;
        if (state.specialsTimer <= 0) {
          spawnSpecial(BOSS_A);
          state.specialsSpawned = true;
          state.specialsProgress = 2;
        } else {
          return;
        }
      }
    }

    if (state.groupMobIndex < groupSize) {
      state.mobIntervalTimer -= dt;
      if (state.mobIntervalTimer <= 0) {
        spawnOneNormalMob();
        state.groupMobIndex += 1;
        state.toSpawn -= 1;
        state.mobIntervalTimer = state.mobIntervalWave;
      }
    } else {
      if (state.groupIndex < GROUPS_PER_WAVE - 1) {
        state.groupIndex += 1;
        state.groupMobIndex = 0;
        state.groupIntervalTimer = GROUP_INTERVAL_BASE;
        state.mobIntervalTimer = 0;
      } else {
        state.groupIndex = GROUPS_PER_WAVE;
      }
    }
  }

  function maybeStartNextWave() {
    if (state.groupIndex < GROUPS_PER_WAVE) return;
    const anyAlive = state.enemies.some(e => !e.dead);
    if (!anyAlive) {
      const nextCount = Math.max(1, Math.ceil(waveCountFor(state.wave + 1)));
      startWave(state.wave + 1, nextCount);
    }
  }

  // ===== UI =====
  function setHUDEnabled(enabled){ speedBtn.disabled=!enabled; pauseBtn.disabled=!enabled; }
  function setOverlay(show, title="Paused", subtitle="Take a breather."){
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlaySubtitle = document.getElementById('overlaySubtitle');
    overlay.classList.toggle('show', show);
    overlayTitle.textContent = title; overlaySubtitle.textContent = subtitle;
    const resumeBtn = document.getElementById('resumeBtn');
    const resumeVisible = !(state.gameOver && title === "Game Over");
    resumeBtn.style.display = resumeVisible ? 'inline-block' : 'none';
    const playing = !(show && title !== "Game Over");
    pauseBtn.innerHTML = playing ? "<strong>||</strong>" : "<strong>â–¶ï¸Ž</strong>";
  }
  function pauseToggle(){
    if (state.gameOver) return;
    state.paused = !state.paused;
    if (state.paused) setOverlay(true, "Paused", "Take a breather.");
    else setOverlay(false);
  }
  resumeBtn.addEventListener('click', ()=>{ if (state.gameOver) return; state.paused=false; setOverlay(false); });
  restartBtn.addEventListener('click', ()=>{ restart(); });
  pauseBtn.addEventListener('click', pauseToggle);
  speedBtn.addEventListener('click', ()=>{
    if (speedBtn.disabled) return;
    state.speedMult = state.speedMult % 3 + 1;
    speedBtn.innerHTML = "<strong>x"+state.speedMult+"</strong>";
    try { localStorage.setItem(SPEED_STORAGE_KEY, String(state.speedMult)); } catch (_) {}
  });

  function renderInventory(){
    invGrid.innerHTML = "";
    for (let i=0;i<16;i++){
      const item = state.inventory[i];
      const d = document.createElement('div');
      d.className = "slot" + (item ? " filled" : "");
      if (item) {
        const l = document.createElement('div');
        l.className = "label";
        l.textContent = item.name;
        d.appendChild(l);
      }
      invGrid.appendChild(d);
    }
  }

  function showToast(title, subtitle) {
    const toast = document.createElement('div');
    toast.style.position = 'absolute'; toast.style.top = '12px'; toast.style.left = '50%'; toast.style.transform = 'translateX(-50%)';
    toast.style.background = 'rgba(0,0,0,0.45)'; toast.style.backdropFilter = 'blur(2px)';
    toast.style.border = '1px solid #1f2937'; toast.style.borderRadius = '10px';
    toast.style.padding = '8px 12px'; toast.style.fontSize = '12px'; toast.style.pointerEvents = 'none'; toast.style.zIndex = '1';
    toast.innerHTML = `<strong>${title}</strong> <span style="color:#94a3b8">â€” ${subtitle}</span>`;
    canvas.parentElement.appendChild(toast);
    setTimeout(()=>{ toast.style.transition = 'opacity .5s ease, transform .5s ease'; toast.style.opacity='0'; toast.style.transform+=' translateY(-6px)'; setTimeout(()=>toast.remove(), 550); }, 1200);
  }

  function restart(){
    state.paused=false; state.gameOver=false;
    state.enemies.length=0; state.bullets.length=0;
    state.coins=0; state.score=0; state.kills=0;
    coinStat.textContent="ðŸª™ 0"; scoreStat.textContent="Score 0";
    state.player.level=1; state.player.exp=0; state.player.expToNext=50; state.player.mode='idle'; state.player.burstLeft=0; state.player.timer=0;
    levelStat.textContent="Lv. 1"; expText.textContent="0 / 50"; expFill.style.width='0%';

    // Inventory: seed slot 0 with current gun and render
    state.inventory = new Array(16).fill(null);
    state.inventory[0] = { name: state.player.gun.name };
    renderInventory();

    // Speed: default x1, but remember last choice across page reloads
    const saved = parseInt(localStorage.getItem(SPEED_STORAGE_KEY) || "1", 10);
    state.speedMult = [1,2,3].includes(saved) ? saved : 1;
    speedBtn.innerHTML = "<strong>x"+state.speedMult+"</strong>";

    state.barricadeHP = BARRICADE_HP_MAX; document.getElementById('hpFill').style.width='100%'; document.getElementById('hpText').textContent='100%';
    const startWaveNum = Math.max(1, Math.floor(CURRENT_WAVE));
    const startCount = waveCountFor(startWaveNum);
    startWave(startWaveNum, startCount);
    setHUDEnabled(true); setOverlay(false);
  }

  restart();
  requestAnimationFrame(function loop(now){
    const rawDt = Math.min((now - (loop.t||now)) / 1000, 0.05);
    loop.t = now;
    if (!state.paused && !state.gameOver) {
      const dt = rawDt * state.speedMult;
      updateSpawning(dt);
      for (const m of state.enemies) m.update(dt);
      for (const b of state.bullets) b.update(dt);
      state.bullets = state.bullets.filter(b => !b.dead);
      updateSoldier(dt);
      maybeStartNextWave();
    }
    ctx.clearRect(0,0,W,H);
    drawBackground(ctx); drawBarrage(ctx); drawRange(ctx);
    for (const m of state.enemies) m.draw(ctx);
    for (const b of state.bullets) b.draw(ctx);
    drawSoldier(ctx);
    requestAnimationFrame(loop);
  });
})();
</script>
</body>
</html>
