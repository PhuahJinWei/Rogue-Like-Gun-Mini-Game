
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Rogue-like Gun Mini-Game — v8.4.9</title>
<style>
  :root {
    --frame-w: 600px;
    --frame-h: 1080px;
    --canvas-h: 750px;

    /* Adjustable HUD element positions (px) */
    --wave-left: 45px;  --wave-top: 82px;  --wave-w: 72px;
    --level-left: 180px; --level-top: 25px;
    --exp-left: 268px; --exp-top: 34px; --exp-w: 188px; --exp-h: 14.5px;
    --coin-left: 180px; --coin-top: 69px; --coin-w: 100px;
    --score-left: 340px; --score-top: 69px; --score-w: 100px;
    --speed-left: 474px; --speed-top: 33px; --speed-size: 49px;
    --pause-left: 534px; --pause-top: 33px; --pause-size: 49px;
  }
  * { box-sizing: border-box; }
  html, body { height:100%; width:100%; overflow:hidden; overscroll-behavior:none; }
  body {
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial;
    background: linear-gradient(180deg, #0b0f1a 0%, #0e1526 100%);
    color:#fff;
    display:flex; align-items:center; justify-content:center;
    padding:0;
    touch-action: manipulation;
  }
  .fit-wrap { transform-origin:center center; width:var(--frame-w); height:var(--frame-h); }
  .game-frame {
    display:inline-block;
    background: rgba(16,24,39,0.75);
    border: 1px solid #1f2937;
    border-radius: 14px;
    padding: 0;
    box-shadow: 0 10px 40px rgba(0,0,0,0.45);
    width: var(--frame-w); height: var(--frame-h);
    overflow: hidden;
  }
  .game-shell { width:var(--frame-w); max-width:100%; }

  /* ===== TOP HUD ===== */
  .hud {
    position: relative;
    height: 168px;                 /* (1) fixed height */
    width: 100%;
    background-image: url('src/img/UI_battlefield_topHUD.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
    margin: 0 0 -60px 0;           /* (2) overlap canvas by 19px */
    z-index: 3;
  }
  .hud .num { position:absolute; color:#fff; font-weight:900; text-shadow: 0 1px 2px rgba(0,0,0,.6); }
  .hud .num.big { font-size: 28px; line-height: 1; }
  .hud .num.sm  { font-size: 18px; font-weight:800; }
  .hud .right { text-align:right; }

  /* Placements (3) */
  #waveNum { left: var(--wave-left); top: var(--wave-top); width: var(--wave-w); text-align:center; }
  #levelNum { left: var(--level-left); top: var(--level-top); width: 40px; text-align:center; font-size: 22px; font-weight:900; }

  .exp-track {
    position:absolute; left: var(--exp-left); top: var(--exp-top);
    width: var(--exp-w); height: var(--exp-h);
    border: 1px solid rgba(255,255,255,0.25); border-radius: 6px;
    background: rgba(0,0,0,0.25); overflow:hidden;
  }
  .exp-fill { position:absolute; left:0; top:0; height:100%; width:0%; background: linear-gradient(90deg,#22c55e,#16a34a); }

  #coinNum { left: var(--coin-left); top: var(--coin-top); width: var(--coin-w); text-align: right; }
  #scoreNum { left: var(--score-left); top: var(--score-top); width: var(--score-w); text-align: right; }

  .hud-btn { position:absolute; background: transparent; border: none; color:#fff; cursor:pointer; }
  
  #speedBtn {
    left: var(--speed-left);
	top: var(--speed-top);
	font-size: 20px;
	font-weight:900;
	width: var(--speed-size);
	height: var(--speed-size);
  }
  #pauseBtn {
    left: var(--pause-left);
	top: var(--pause-top);
	font-size: 22px;
	font-weight:900;
	width: var(--pause-size);
	height: var(--pause-size);
  }

  .stage-wrap { display:flex; align-items:center; justify-content:center; padding:0; margin:0; }
  .stage {
    width: var(--frame-w);
    height: var(--canvas-h);
    position: relative;
    background-image: url('src/img/background_battlefield_1000x1250.png');
    background-size: cover; background-position:center;
    border:none; border-radius:0; box-shadow:none;
  }
  canvas { display:block; width:100%; height:100%; }

  /* Barricade HP */
  .hp-container { margin: 0; padding: 8px 12px; }
  .hp-bar { position:relative; width:100%; height:18px; border-radius:999px; background:transparent; overflow:hidden; border:none; }
  .hp-bar .fill { position:absolute; top:0; left:0; height:100%; width:100%; background: linear-gradient(90deg, #ef4444, #f43f5e); border-radius:999px; transition: width .2s ease; }
  .hp-bar .text { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:12px; color:white; text-shadow: 0 1px 2px rgba(0,0,0,.6); pointer-events:none; }

  /* Overlay panel */
  .overlay { position:absolute; inset:0; background:rgba(0,0,0,0.55); display:none; align-items:center; justify-content:center; z-index:2; }
  .overlay.show { display:flex; }
  .overlay .panel { background:#0b1220; border:1px solid #1f2937; border-radius:14px; padding:18px; text-align:center; width:80%; max-width:360px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); }
  .overlay .actions { display:flex; gap:10px; justify-content:center; }
  .overlay .actions button { background:#111827; border:1px solid #1f2937; color:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700; }
  .overlay .actions button:hover { filter: brightness(1.1); transform: translateY(-1px); }
  .overlay .actions button.primary { background:#14532d; border-color:#166534; }

  /* Inventory */
  .inventory-wrap { margin:0; background:#101827; border-top:1px solid #1f2937; padding:10px 12px; }
  .inventory-grid { display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(2,1fr); gap:8px; }
  .slot { position:relative; aspect-ratio:1/1; border:1px dashed #334155; border-radius:10px; background:#0b1220; display:grid; place-items:center; overflow:hidden; }
  .slot.filled { border-style:solid; border-color:#475569; background: radial-gradient(120% 120% at 100% 0%, rgba(124,58,237,0.25) 0%, rgba(2,6,23,0) 60%), #0b1220; }
  .slot .label { font-size:12px; color:#e5e7eb; padding:2px 6px; border-radius:999px; background: rgba(2,6,23,0.75); border:1px solid #1e293b; }

  /* Boss warning banner */
  .warn-banner {
    position: absolute;
    top: 8px; left: 50%; transform: translateX(-50%);
    padding: 6px 12px;
    background: rgba(220,38,38,0.6); color:#fff;
    border: 1px solid rgba(220,38,38,0.85);
    border-radius: 10px; font-weight: 900; letter-spacing: 1px;
    text-transform: uppercase; pointer-events: none; backdrop-filter: blur(2px);
    z-index: 3; opacity: 0; text-shadow: 0 1px 2px rgba(0,0,0,0.45);
  }
  .warn-banner.show { opacity:1; }
  @keyframes warnPulse { 0% {opacity:0;} 30% {opacity:1;} 70% {opacity:1;} 100% {opacity:0;} }
</style>
</head>
<body>
  <div id="fitWrap" class="fit-wrap">
    <div class="game-frame">
      <div class="game-shell">

        <!-- TOP HUD -->
        <div class="hud" id="topHUD">
          <div id="waveNum"  class="num big">1</div>
          <div id="levelNum" class="num">1</div>
          <div class="exp-track"><div class="exp-fill" id="expFill"></div></div>
          <div id="coinNum"  class="num sm right">0</div>
          <div id="scoreNum" class="num sm right">0</div>
          <button id="speedBtn" class="hud-btn">1x</button>
          <button id="pauseBtn" class="hud-btn"></button>
        </div>

        <!-- Battlefield -->
        <div class="stage-wrap">
          <div class="stage">
            <canvas id="game"></canvas>
            <!-- Boss warning banner -->
            <div id="bossWarn" class="warn-banner">BOSS APPROACHING</div>
            <div class="overlay" id="overlay">
              <div class="panel">
                <h2 id="overlayTitle">Paused</h2>
                <p id="overlaySubtitle">Take a breather.</p>
                <div class="actions">
                  <button id="resumeBtn" class="primary">▶︎</button>
                  <button id="restartBtn">Restart</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Barricade HP -->
        <div class="hp-container">
          <div class="hp-bar" id="hpBar">
            <div class="fill" id="hpFill"></div>
            <div class="text" id="hpText">100%</div>
          </div>
        </div>

        <!-- Inventory -->
        <div class="inventory-wrap">
          <div class="inventory-grid" id="inventoryGrid"></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Config =====
  const FRAME_W  = 600, FRAME_H  = 1080; // frame design size
  const CANVAS_W = FRAME_W, CANVAS_H = 750;

  const W = CANVAS_W, H = CANVAS_H;
  const BARRICADE_Y = H - 150;
  const BARRICADE_HP_MAX = 500;

  const CURRENT_WAVE = 50;
  const WAVE_1_COUNT = 8;
  const WAVE_INCREASE = 1.01;

  const GROUPS_PER_WAVE = 5;
  const GROUP_INTERVAL_BASE = 20.0;
  const MOB_INTERVAL_BASE = 0.50;
  const MOB_INTERVAL_MIN  = 0.30;
  const MOB_INTERVAL_DECAY_PER_WAVE = 0.3;

  const CONTACT_DAMAGE_INTERVAL = 3.0;

  // Banner + spacing config
  const BOSS_WARN_FLASHES = 2;
  const BOSS_WARN_TOTAL_DURATION = 2.1;
  const BOSS_MINI_TO_BOSS_INTERVAL = 0.3;

  const MOB_A = { name: "Mob A", hp: 50, exp: 10, speed: 10, dps: 20, size: 30, coin: 100, score: 100 };
  const MINI_BOSS_A = { name: "Mini-boss Type A", hp: 500, exp: 100, speed: 8, dps: 30, size: 50, coin: 500, score: 500, tier: "mini" };
  const BOSS_A = { name: "Boss Type A", hp: 1000, exp: 1000, speed: 5, dps: 50, size: 70, coin: 1000, score: 1000, tier: "boss" };

  const GUN_A = { name: "Gun A", range: 420, bulletsPerUse: 6, timeBetweenBullets: 0.1, damage: 18, postUseCooldown: (5/3), bulletSpeed: 200 };

  // ===== Bind constants to DOM/CSS =====
  const root = document.documentElement;
  root.style.setProperty('--frame-w',  FRAME_W  + 'px');
  root.style.setProperty('--frame-h',  FRAME_H  + 'px');
  root.style.setProperty('--canvas-h', CANVAS_H + 'px');

  const canvas = document.getElementById('game');
  canvas.width  = CANVAS_W;
  canvas.height = CANVAS_H;

  const fitWrap = document.getElementById('fitWrap');
  function fitToViewport() {
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    const scaleW = vw / FRAME_W;
    const scaleH = vh / FRAME_H;
    const s = Math.min(scaleW, scaleH, 1);
    fitWrap.style.transform = `scale(${s})`;
  }
  window.addEventListener('resize', fitToViewport);
  window.addEventListener('orientationchange', fitToViewport);
  fitToViewport();

  // Prevent zoom/scroll gestures
  const preventMultiTouch = (e) => { if (e.touches && e.touches.length > 1) e.preventDefault(); };
  document.addEventListener('touchstart', preventMultiTouch, { passive: false });
  document.addEventListener('touchmove',  preventMultiTouch, { passive: false });
  document.addEventListener('gesturestart', (e)=> e.preventDefault());
  document.addEventListener('gesturechange', (e)=> e.preventDefault());
  document.addEventListener('gestureend',   (e)=> e.preventDefault());
  document.addEventListener('wheel', (e)=> { if (e.ctrlKey) e.preventDefault(); }, { passive: false });
  document.addEventListener('dblclick', (e)=> e.preventDefault(), { passive: false });

  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const resumeBtn = document.getElementById('resumeBtn');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const speedBtn = document.getElementById('speedBtn');
  const bossWarn = document.getElementById('bossWarn');

  const waveNumEl  = document.getElementById('waveNum');
  const levelNumEl = document.getElementById('levelNum');
  const expFill    = document.getElementById('expFill');
  const coinNumEl  = document.getElementById('coinNum');
  const scoreNumEl = document.getElementById('scoreNum');

  const SPEED_STORAGE_KEY = 'rlg_speed_v1';

  const state = {
    paused: false, gameOver: false, wave: 1,
    toSpawn: 0, enemies: [], bullets: [],
    coins: 0, score: 0, kills: 0,
    player: { x: W/2, y: H - 12, size: 16, gun: GUN_A, level: 1, exp: 0, expToNext: 50, mode: 'idle', burstLeft: 0, timer: 0 },
    speedMult: 1, inventory: new Array(16).fill(null),
    groupIndex: 0, groupSizes: [], groupMobIndex: 0, groupIntervalTimer: 0, mobIntervalTimer: 0, mobIntervalWave: 0,
    specialsQueued: { mini: false, boss: false }, specialsSpawned: false,
    specialsProgress: 0, specialsTimer: 0
  };

  // ===== Utilities =====
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function waveCountFor(n) {
    let c = WAVE_1_COUNT;
    for (let i = 1; i < n; i++) c = Math.max(1, Math.ceil(c * WAVE_INCREASE));
    return c;
  }

  function splitIntoGroups(total, groups) {
    const sizes = new Array(groups).fill(0);
    if (total <= 0) return sizes;
    const base = Math.floor(total / groups);
    let rem = total - base * groups;
    for (let i = 0; i < groups; i++) sizes[i] = base;
    while (rem-- > 0) sizes[Math.floor(Math.random()*groups)]++;
    for (let i = 0; i < groups; i++) if (sizes[i] === 0 && total >= groups) sizes[i] = 1;
    let sum = sizes.reduce((a,b)=>a+b,0);
    while (sum > total) { const i = sizes.findIndex(s=>s>1); sizes[i]--; sum--; }
    return sizes;
  }

  // ===== Entities =====
  class Mob {
    constructor(type, x, yStart) {
      this.type = type; this.x = x; this.y = yStart;
      this.w = type.size; this.h = type.size; this.hp = type.hp;
      this.contact = false; this.contactTimer = 0; this.dead = false; this.tookDamage = false;
    }
    get cx() { return this.x + this.w/2; }
    get cy() { return this.y + this.h/2; }

    update(dt) {
      if (this.dead) return;
      if (!this.contact) {
        this.y += this.type.speed * dt;
        if (this.y + this.h >= BARRICADE_Y) { this.y = BARRICADE_Y - this.h; this.contact = true; this.contactTimer = 0; }
      } else {
        this.contactTimer += dt;
        while (this.contactTimer >= CONTACT_DAMAGE_INTERVAL) { this.contactTimer -= CONTACT_DAMAGE_INTERVAL; applyBarrageDamage(this.type.dps); }
      }
    }

    hit(dmg) {
      if (this.dead) return;
      this.hp -= dmg;
      if (this.type.tier) this.tookDamage = true;
      if (this.hp <= 0) { this.dead = true; onMobKilled(this); }
    }

    draw(ctx) {
      if (this.dead) return;
      ctx.save();
      if (this.type.tier === "boss")      { ctx.fillStyle = '#ef4444'; ctx.strokeStyle = '#b91c1c'; }
      else if (this.type.tier === "mini") { ctx.fillStyle = '#f59e0b'; ctx.strokeStyle = '#b45309'; }
      else                                { ctx.fillStyle = '#22d3ee'; ctx.strokeStyle = '#0ea5b7'; }
      ctx.lineWidth = 1.5;
      roundRect(ctx, this.x, this.y, this.w, this.h, 6);
      ctx.fill(); ctx.stroke();

      if (this.type.tier && this.tookDamage) {
        const ratio = clamp(this.hp / this.type.hp, 0, 1);
        const barW = this.w, barH = 4;
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(this.x, this.y - 6, barW, barH);
        ctx.fillStyle = '#fca5a5';
        ctx.fillRect(this.x, this.y - 6, barW * ratio, barH);
      }
      ctx.restore();
    }
  }

  class Bullet {
    constructor(x, y, dirX, dirY, speed, dmg) {
      const len = Math.hypot(dirX, dirY) || 1;
      this.vx = (dirX/len) * speed; this.vy = (dirY/len) * speed;
      this.x = x; this.y = y; this.r = 3; this.dmg = dmg; this.dead = false;
    }
    update(dt) {
      if (this.dead) return;
      this.x += this.vx * dt; this.y += this.vy * dt;
      if (this.x < -12 || this.x > W + 12 || this.y < -12 || this.y > H + 12) { this.dead = true; return; }
      for (const m of state.enemies) {
        if (m.dead) continue;
        const cx = Math.max(m.x, Math.min(this.x, m.x + m.w));
        const cy = Math.max(m.y, Math.min(this.y, m.y + m.h));
        const dx = this.x - cx, dy = this.y - cy;
        if (dx*dx + dy*dy <= this.r*this.r) { m.hit(this.dmg); this.dead = true; break; }
      }
    }
    draw(ctx) {
      if (this.dead) return;
      ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fillStyle = '#fbbf24'; ctx.fill(); ctx.shadowColor = '#fde68a'; ctx.shadowBlur = 8; ctx.restore();
    }
  }

  // Player rendering
  function drawSoldier(ctx) {
    const p = state.player;
    ctx.save(); ctx.translate(p.x, p.y);
    ctx.fillStyle = '#a78bfa'; ctx.strokeStyle = '#7c3aed'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0,-p.size); ctx.lineTo(p.size*.9,p.size); ctx.lineTo(-p.size*.9,p.size); ctx.closePath();
    ctx.fill(); ctx.stroke();
    const t = findClosestInRange();
    if (t) {
      const dx = t.cx - p.x, dy = t.cy - p.y;
      const len = Math.hypot(dx, dy) || 1; const ux = dx/len, uy = dy/len;
      ctx.beginPath(); ctx.moveTo(0, -p.size*0.5); ctx.lineTo(ux*18, uy*18 - p.size*0.5);
      ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 3; ctx.stroke();
    }
    ctx.restore();
  }

  function roundRect(ctx,x,y,w,h,r){ const m=Math.min(w,h)/2; r=Math.min(r,m);
    ctx.beginPath(); ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  }

  function drawBarrage(ctx) {
    ctx.save();
    const y = BARRICADE_Y;
    ctx.strokeStyle = 'rgba(148,163,184,0.9)'; ctx.lineWidth = 6;
    ctx.beginPath(); ctx.moveTo(12,y); ctx.lineTo(W-12,y); ctx.stroke();
    ctx.fillStyle = '#475569'; for (let x=12; x<=W-12; x+=50) ctx.fillRect(x-2, y-12, 4, 12);
    ctx.restore();
  }

  function gameOver() {
    if (state.gameOver) return;
    state.gameOver = true; state.paused = true;
    setHUDEnabled(false); setOverlay(true, "Game Over", "The barricade fell.");
  }

  function applyBarrageDamage(dmg) {
    if (state.gameOver) return;
    const maxHP = BARRICADE_HP_MAX;
    const bar = document.getElementById('hpFill');
    const txt = document.getElementById('hpText');
    state.barricadeHP = (state.barricadeHP ?? maxHP) - dmg;
    state.barricadeHP = Math.max(0, Math.min(maxHP, state.barricadeHP));
    const pct = Math.round((state.barricadeHP / maxHP) * 100);
    bar.style.width = pct + '%'; txt.textContent = pct + '%';
    if (state.barricadeHP <= 0) gameOver();
  }

  function onMobKilled(m) {
    state.kills++;
    state.coins += m.type.coin || 0;
    state.score += m.type.score || 0;
    coinNumEl.textContent  = String(state.coins);
    scoreNumEl.textContent = String(state.score);
    state.player.exp += m.type.exp;
    while (state.player.exp >= state.player.expToNext) {
      state.player.exp -= state.player.expToNext;
      state.player.level += 1;
      state.player.expToNext = Math.ceil(state.player.expToNext * 1.3);
    }
    levelNumEl.textContent = String(state.player.level);
    const pct = Math.round((state.player.exp / state.player.expToNext) * 100);
    expFill.style.width = pct + '%';
  }

  function findClosestInRange() {
    const p = state.player; const r2 = p.gun.range * p.gun.range;
    let best=null, bestD2=Infinity;
    for (const m of state.enemies) {
      if (m.dead) continue;
      const dx = p.x - m.cx, dy = p.y - m.cy; const d2 = dx*dx + dy*dy;
      if (d2 <= r2 && d2 < bestD2) { bestD2 = d2; best = m; }
    }
    return best;
  }

  function updateSoldier(dt) {
    const p = state.player; p.timer -= dt;
    if (p.mode === 'idle') {
      const t = findClosestInRange();
      if (t) { p.mode='burst'; p.burstLeft=p.gun.bulletsPerUse; p.timer=0; }
    } else if (p.mode === 'burst') {
      while (p.burstLeft > 0 && p.timer <= 0) {
        const t = findClosestInRange();
        if (t) {
          state.bullets.push(new Bullet(p.x, p.y - p.size*0.6, t.cx - p.x, t.cy - p.y, p.gun.bulletSpeed, p.gun.damage));
        }
        p.burstLeft--; p.timer += p.gun.timeBetweenBullets;
      }
      if (p.burstLeft === 0 && p.timer <= 0) { p.mode='cooldown'; p.timer=p.gun.postUseCooldown; }
    } else if (p.mode === 'cooldown') {
      if (p.timer <= 0) p.mode='idle';
    }
  }

  function computeMobIntervalForWave(wave) {
    const t = Math.pow(MOB_INTERVAL_DECAY_PER_WAVE, Math.max(0, wave-1));
    return Math.max(MOB_INTERVAL_MIN, Math.min(MOB_INTERVAL_BASE, MOB_INTERVAL_BASE * t));
  }

  function startWave(n, totalCount) {
    state.wave = n; waveNumEl.textContent = String(n);
    state.toSpawn = totalCount; state.groupIndex = 0; state.groupMobIndex = 0;
    state.specialsSpawned = false; state.specialsProgress = 0; state.specialsTimer = 0;
    state.groupIntervalTimer = 0; state.mobIntervalWave = computeMobIntervalForWave(n); state.mobIntervalTimer = 0;
    state.groupSizes = splitIntoGroups(totalCount, GROUPS_PER_WAVE);
    state.specialsQueued.mini = (n % 5 === 0);
    state.specialsQueued.boss = (n % 10 === 0);
  }

  function spawnOneNormalMob() {
    const s = MOB_A.size;
    const x = Math.max(0, Math.min(W - s, Math.random() * (W - s)));
    const y = -s - (Math.random() * 140 + 20);
    state.enemies.push(new Mob(MOB_A, x, y));
  }

  function spawnSpecial(type) {
    const s = type.size;
    const x = Math.max(0, Math.min(W - s, Math.random() * (W - s)));
    const y = -s - (Math.random() * 130 + 30);
    state.enemies.push(new Mob(type, x, y));
  }

  function showBossWarning(text = "BOSS APPROACHING") {
    bossWarn.textContent = text;
    bossWarn.classList.add('show');
    const per = Math.max(0.1, BOSS_WARN_TOTAL_DURATION / Math.max(1, BOSS_WARN_FLASHES));
    bossWarn.style.animation = 'none'; void bossWarn.offsetWidth;
    bossWarn.style.animation = `warnPulse ${per}s ease-in-out ${Math.max(1, BOSS_WARN_FLASHES)}`;
    clearTimeout(bossWarn._hideTO);
    bossWarn._hideTO = setTimeout(()=>{ bossWarn.classList.remove('show'); bossWarn.style.animation='none'; }, Math.max(0, BOSS_WARN_TOTAL_DURATION)*1000 + 50);
  }

  function updateSpawning(dt) {
    if (state.groupIndex >= GROUPS_PER_WAVE) return;

    if (state.groupMobIndex === 0 && state.groupIndex > 0 && state.groupIntervalTimer > 0) {
      state.groupIntervalTimer -= dt; return;
    }

    const isLastGroup = (state.groupIndex === GROUPS_PER_WAVE - 1);
    const groupSize = state.groupSizes[state.groupIndex] || 0;

    if (isLastGroup && (state.specialsQueued.mini || state.specialsQueued.boss) && !state.specialsSpawned) {
      if (state.specialsProgress === 0) {
        if (state.specialsQueued.boss) showBossWarning();
        if (state.specialsQueued.mini) {
          spawnSpecial(MINI_BOSS_A);
          state.specialsProgress = 1;
          if (state.specialsQueued.boss) { state.specialsTimer = BOSS_MINI_TO_BOSS_INTERVAL; return; }
          else { state.specialsSpawned = true; }
        } else {
          if (state.specialsQueued.boss) spawnSpecial(BOSS_A);
          state.specialsSpawned = true; state.specialsProgress = 2;
        }
      } else if (state.specialsProgress === 1 && state.specialsQueued.boss) {
        state.specialsTimer -= dt;
        if (state.specialsTimer <= 0) { spawnSpecial(BOSS_A); state.specialsSpawned = true; state.specialsProgress = 2; }
        else return;
      }
    }

    if (state.groupMobIndex < groupSize) {
      state.mobIntervalTimer -= dt;
      if (state.mobIntervalTimer <= 0) {
        spawnOneNormalMob();
        state.groupMobIndex += 1; state.toSpawn -= 1; state.mobIntervalTimer = state.mobIntervalWave;
      }
    } else {
      if (state.groupIndex < GROUPS_PER_WAVE - 1) {
        state.groupIndex += 1; state.groupMobIndex = 0; state.groupIntervalTimer = GROUP_INTERVAL_BASE; state.mobIntervalTimer = 0;
      } else { state.groupIndex = GROUPS_PER_WAVE; }
    }
  }

  function maybeStartNextWave() {
    if (state.groupIndex < GROUPS_PER_WAVE) return;
    const anyAlive = state.enemies.some(e => !e.dead);
    if (!anyAlive) {
      const nextCount = Math.max(1, Math.ceil(waveCountFor(state.wave + 1)));
      startWave(state.wave + 1, nextCount);
    }
  }

  // ===== UI =====
  function setHUDEnabled(enabled){ speedBtn.disabled=!enabled; pauseBtn.disabled=!enabled; }
  function setOverlay(show, title="Paused", subtitle="Take a breather."){
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlaySubtitle = document.getElementById('overlaySubtitle');
    overlay.classList.toggle('show', show);
    overlayTitle.textContent = title; overlaySubtitle.textContent = subtitle;
    const resumeBtn = document.getElementById('resumeBtn');
    const resumeVisible = !(state.gameOver && title === "Game Over");
    resumeBtn.style.display = resumeVisible ? 'inline-block' : 'none';
  }
  function pauseToggle(){ if (state.gameOver) return; state.paused = !state.paused; if (state.paused) setOverlay(true,"Paused","Take a breather."); else setOverlay(false); }
  resumeBtn.addEventListener('click', ()=>{ if (state.gameOver) return; state.paused=false; setOverlay(false); });
  restartBtn.addEventListener('click', ()=>{ restart(); });
  pauseBtn.addEventListener('click', pauseToggle);
  speedBtn.addEventListener('click', ()=>{ if (speedBtn.disabled) return; state.speedMult = state.speedMult % 3 + 1; speedBtn.innerHTML = state.speedMult+"x"; try { localStorage.setItem(SPEED_STORAGE_KEY, String(state.speedMult)); } catch (_) {} });

  function renderInventory(){
    const invGrid = document.getElementById('inventoryGrid');
    invGrid.innerHTML = "";
    for (let i=0;i<16;i++){ const item = state.inventory[i]; const d=document.createElement('div'); d.className="slot"+(item?" filled":""); if(item){ const l=document.createElement('div'); l.className="label"; l.textContent=item.name; d.appendChild(l); } invGrid.appendChild(d); }
  }

  function restart(){
    state.paused=false; state.gameOver=false;
    state.enemies.length=0; state.bullets.length=0;
    state.coins=0; state.score=0; state.kills=0;
    coinNumEl.textContent="0"; scoreNumEl.textContent="0";
    state.player.level=1; state.player.exp=0; state.player.expToNext=50; state.player.mode='idle'; state.player.burstLeft=0; state.player.timer=0;
    levelNumEl.textContent="1"; expFill.style.width='0%';
    state.inventory = new Array(16).fill(null); state.inventory[0] = { name: state.player.gun.name }; renderInventory();

    const saved = parseInt(localStorage.getItem(SPEED_STORAGE_KEY) || "1", 10);
    state.speedMult = [1,2,3].includes(saved) ? saved : 1;
    speedBtn.innerHTML = state.speedMult+"x";

    state.barricadeHP = BARRICADE_HP_MAX;
    document.getElementById('hpFill').style.width='100%';
    document.getElementById('hpText').textContent='100%';

    const startWaveNum = Math.max(1, Math.floor(CURRENT_WAVE));
    const startCount = waveCountFor(startWaveNum);
    startWave(startWaveNum, startCount);
    setHUDEnabled(true); setOverlay(false);
  }

  restart();
  requestAnimationFrame(function loop(now){
    const rawDt = Math.min((now - (loop.t||now)) / 1000, 0.05); loop.t = now;
    if (!state.paused && !state.gameOver) {
      const dt = rawDt * state.speedMult;
      updateSpawning(dt);
      for (const m of state.enemies) m.update(dt);
      for (const b of state.bullets) b.update(dt);
      state.bullets = state.bullets.filter(b => !b.dead);
      updateSoldier(dt);
      maybeStartNextWave();
    }
    ctx.clearRect(0,0,W,H);
    drawBarrage(ctx);
    for (const m of state.enemies) m.draw(ctx);
    for (const b of state.bullets) b.draw(ctx);
    drawSoldier(ctx);
    requestAnimationFrame(loop);
  });
})();
</script>
</body>
</html>
